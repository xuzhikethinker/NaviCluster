/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package main;

/**
 *
 * @author Knacky
 */
import edu.uci.ics.jung.algorithms.layout.AggregateLayout;
import edu.uci.ics.jung.algorithms.layout.CircleLayout;
import edu.uci.ics.jung.algorithms.layout.GraphElementAccessor;
import edu.uci.ics.jung.algorithms.layout.Layout;

import edu.uci.ics.jung.algorithms.layout.StaticLayout;
import edu.uci.ics.jung.algorithms.layout.util.Relaxer;
import edu.uci.ics.jung.algorithms.layout.util.VisRunner;


import edu.uci.ics.jung.algorithms.util.IterativeContext;
import edu.uci.ics.jung.graph.Graph;


import edu.uci.ics.jung.graph.SparseMultigraph;

import edu.uci.ics.jung.graph.util.Context;
import edu.uci.ics.jung.graph.util.Pair;

import edu.uci.ics.jung.visualization.GraphZoomScrollPane;

import edu.uci.ics.jung.visualization.RenderContext;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.AbstractGraphMousePlugin;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;

import edu.uci.ics.jung.visualization.control.ModalGraphMouse.Mode;
import edu.uci.ics.jung.visualization.decorators.AbstractVertexShapeTransformer;
import edu.uci.ics.jung.visualization.decorators.EdgeWeightLabeller;
import edu.uci.ics.jung.visualization.decorators.PickableEdgePaintTransformer;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.layout.LayoutTransition;
import edu.uci.ics.jung.visualization.renderers.Renderer;
import edu.uci.ics.jung.visualization.util.Animator;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileFilter;
import kmean.DataCluster;
import kmean.DataVector;
import kmean.KMeanClusterer;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.collections15.Transformer;
import org.apache.commons.collections15.functors.ConstantTransformer;
import org.apache.commons.collections15.functors.MapTransformer;
import org.apache.commons.collections15.map.LazyMap;

import util.StopWatch;
import org.geneontology.oboedit.datamodel.OBOSession;




/**
 *
 * @author Thanet Praneenararat (Knack) 
 * Department of Computational Biology, Graduate School of Frontier Sciences, University of Tokyo
 */
public class IntBioGraphNaviSysApp extends JFrame {

    private boolean UIWanted;
//    private String stringStream = "";
    private boolean isWeightGraph = false;
    private int[] sArr = null;
    private int[] dArr = null;
    private double[] wArr = null;

    public Color mainColor = new Color(255,204,22);
    public Color peripheralColor = new Color(0xF6FEAC);
    public Color bioObjColor = new Color(145, 214, 134);
//    public Color searchedColor = new Color(135,137,211);
    public Color searchedColor = new Color(0xECA3AE);
//    public Color mainColor = new Color(138,240,87);
//    public Color mainColor = new Color(153,255,102);

    VisualizationViewer<Object, Object> vv;
    Map<Object, Paint> vertexPaints = LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(bioObjColor));
    Map<Object, Paint> edgePaints =  LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.BLACK));
    Map<Integer, BioObject> nodeMap = new HashMap<Integer, BioObject>();

    /* TO-DO I might allow users to adjust threshold for louvain clustering in the future */
//    private double threshold;
    private EdgeDisplayPredicate medp;
    private EdgeWeightLabeller ew;

//    String filename = "expmore3.mnet";
//    String filename = "refmore3.mnet";
    String filename = "curmore2.mnet";

    File fileToOpen = null;
    Graph<Object, Object> realGraph, originalGraph;
    Graph dynamicGraph,currentLevelGraph;
    AggregateLayout<Object, Object> layout;
    private boolean firstLoad = true;
    
    JButton zoomInButton;
    JButton zoomOutButton;

    JScrollPane listScroller = new JScrollPane();
    DefaultListModel listModel = new DefaultListModel();
    JList searchResList = new JList();
    JTextField searchTextField = new JTextField(10);

    JTextField thresholdTextField = new JTextField("12",4);
    JTextField numHops = new JTextField("2",5);

    JSlider ccSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider bpSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider mfSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider goEdgeSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 9);

//    Set<Set<Object>>[] hierCSet = null;
//    Set<Set<Object>>[] comNodehierSet = null;
    Set<Set>[] hierCSet = null;
    Set<Set>[] comNodeHierSet = null;

    public Object highlightedNode = null;
    public BioObject searchedBioObj = null;
    public Color highlightedNodeFormerColor = null;

    private int currentLevel = 0;

    /* now cSetToComNodeCSet is not used anywhere, it is only inputed*/
    Map<Set<Set>,Set<Set>> cSetToComNodeCSet = new HashMap<Set<Set>,Set<Set>>();
    Map<Set, Set> flatClustToComNodeClust = new HashMap<Set, Set>();
    Map<Set, Set> comNodeClustToFlatClust = new HashMap<Set, Set>();
//    Map<Set, DataCluster> nodeToDataCluster = new HashMap<Set, DataCluster>();

    private GOProcessor curGOP = null;
    private GOProcessor curGOPCentered = null;

    private boolean inConcentrationMode = false;
    private Set<Set> curCSetCentered = null;
    private Set<Set> curCSetCenteredBPC = null;
    private Set<Set> curComNodeCSetCenteredBPC = null;
    private Set<Set> curComNodeCSetCentered = null;
    private Set centerNodeSet = null;
    private Set<Set> curCSet = null;
    private Set<Set> curCSetBeforePropClust = null;
    private Set<Set> curComNodeCSet = null;
    private Set<Set> curComNodeCSetBeforePropClust = null;
//    private ArrayList historyCSetList = new ArrayList<Set<Set<Object>>>();
//    private ArrayList historyComNodeCSetList = new ArrayList<Set<Set<Object>>>();
//    private ArrayList<GOProcessor> historyGOProcessors = new ArrayList<GOProcessor>();
    private ArrayList<ViewHistory> viewHistoryList = new ArrayList<ViewHistory>();

    OBOSession obosession = null;
    /* numOfLouvainClusters is not used for specific purposes yet */
    public int numOfLouvainClusters = 0;
    DataVector centroid = new DataVector();

    DataCluster[] semanticClusterList = new DataCluster[1];
    Map <Object,DataVector> nodesGOVectorMap = new HashMap<Object, DataVector>();
    Map<BioObject,Object> nodeToClusterMap;

    public static void main(String[] args) {

        IntBioGraphNaviSysApp test = new IntBioGraphNaviSysApp();

        test.setTitle("Interactive Bio Graph Explorer");
        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        test.start();
        test.pack();
//        test.setLocationByPlatform(true);
        test.setVisible(true);


    }

    public void start() {

        UIWanted = true;

        try {
//            JFileChooser fileChooser = new JFileChooser(new File(filename + ".txt"));
//            fileChooser.setAcceptAllFileFilterUsed(false);
//            fileChooser.addChoosableFileFilter(new TextFileFilter());

//            System.out.println(new File(filename+".txt").getPath());
//            fileChooser.showOpenDialog(IntBioGraphNaviSysApp.this);
//            fileToOpen = fileChooser.getSelectedFile();
            fileToOpen = new File(filename);
//            System.out.println(fileToOpen.getName());
            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));

            realGraph = new SparseMultigraph<Object, Object>();
            StopWatch loadingTime = new StopWatch();
            loadingTime.start();

            realGraph = loadModNet(br);
            originalGraph = realGraph;
            dynamicGraph = realGraph;
            
            loadingTime.stop();
            System.out.println("Time used for loading from input file: " + loadingTime);

            /* This is top level. */
            ArrayList retList = louvainCluster(realGraph, realGraph.getVertexCount(), true);
            preparePropertyInfoProcessor();
            numOfLouvainClusters = ((Set)retList.get(0)).size();
            Set<Set> cSet = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1), null,true,true,true);
            /* if do on all nodes in canvas, visualize the result also, or else just do clustering */
            dynamicGraph = createGraph(cSet);
            colorCluster(cSet, mainColor);
            currentLevelGraph = dynamicGraph;
            
            initVV();
            initComponents();

        } catch (IOException e) {
            // TODO Auto-generated catch block
            System.out.println("Error in loading graph");
            e.printStackTrace();
        }
    }
    /**
     * Load input file in modified .net pajek format
     * @param br
     * @return
     * @throws java.io.IOException
     */
    public Graph<Object, Object> loadModNet(BufferedReader br) throws IOException {

        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1, numNode = -1;

        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        BioObject bioObj = null;

        int id = -1;
        String stdName = "", name = "", sgdid = "", type = "";
        String goId = "", ref = "", aspect = "";
        StopWatch sw = new StopWatch();

        //check header of vertices zone
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Vertices")) {
                    numNode = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }


        sw.start();
        for (int i = 0; i < numNode; i++) {
            st = br.readLine();
//            System.out.println(st);
            stn = new StringTokenizer(st, "\t", true);
            assert (stn.hasMoreTokens());
            id = Integer.parseInt(stn.nextToken());
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            stdName = stn.nextToken();
            if (stdName.equals("\t")) {
                stdName = "";
            } else {
                stn.nextToken();
            }

            assert (stn.hasMoreTokens());
            name = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            sgdid = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            if (sgdid.equals("\t")) {
                bioObj = new BioObject(id, name);
                bioObj.setStandardName(stdName);
            } else {
//                assert (stn.hasMoreTokens());
//                sgdid = stn.nextToken();
//                if (stn.nextToken().equals("\t"));
                assert (stn.hasMoreTokens());
                type = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                goId = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                ref = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                aspect = stn.nextToken();
//            if (stn.nextToken().equals("\t"));

                bioObj = new BioObject(id, sgdid, name);
                bioObj.setStandardName(stdName);
                bioObj.setType(type);

                StringTokenizer stz = new StringTokenizer(goId, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getGoIdList().add(stz.nextToken());
                }

                stz = new StringTokenizer(ref, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getRefList().add(stz.nextToken());
                }

                stz = new StringTokenizer(aspect, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getAspectList().add(stz.nextToken());
                }
            }
            newgraph.addVertex(bioObj);
            nodeMap.put(id, bioObj);
        }
        sw.stop();
        System.out.println("load vertices time: "+sw);
        sw.start();

        int numEdge = -1;

        //check header of edges zone
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Edges")) {
                    numEdge = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        /* the previous version made use of StringBuilder which is faster than normal string
         * but slower than current version
         */
//        StringBuilder stb = new StringBuilder(10000);

        sArr = new int[numEdge];
        dArr = new int[numEdge];
        wArr = new double[numEdge];
        boolean isWeight = false;

        ew = new EdgeWeightLabeller<Number>();
        for (int i = 0; i < numEdge; i++) {

            st = br.readLine();
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
//            stb.append(src).append("\t").append(dest).append("\t");
            sArr[i] = src; dArr[i] = dest;

//            Number vSrc = null,vDest = null;
//            newgraph.addVertex(src);
//            newgraph.addVertex(dest);
//            System.out.println("src: "+src+" dest: "+dest);
            String e1 = src + ":" + dest;
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
//                stringStream += weight;
//                stb.append(weight);
                wArr[i] = weight;
                ew.setWeight(e1, weight);
                isWeight = true;
            }
//            stringStream += "\n";
//            stb.append("\n");
            newgraph.addEdge(e1, nodeMap.get(src), nodeMap.get(dest));
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));

        }
        sw.stop();
//        stringStream = stb.toString();
        if (!isWeight){
            wArr = null;
        }
        isWeightGraph = isWeight;
        System.out.println("Load edges time: "+sw);
        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
        System.out.println("Num nodes double checked: " + numNode + " Num edges double checked: " + numEdge);
//        System.out.println(newgraph.getEdges());
        return newgraph;
    }

    /* Business logic zones (Core methods) */
    /**
     * Perform Louvain-clustering by taking g as an input
     * It is used at first after loading input file
     * If we would like to re-run louvain-clustering after loading, please use reLouvainCluster method
     * @param g
     * @param clustering
     */
    public ArrayList louvainCluster(Graph g, int numNode, boolean isTopLevel) {
        ArrayList retList = null;
        try {
            StopWatch stopwatch = new StopWatch();
            stopwatch.start();
            MainLouvain ml = new MainLouvain();
            int[][] hierarchyComNode = null;

            if (sArr != null){
                hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
            } else {
                hierarchyComNode = new int[2][];
                for (int i = 0; i < hierarchyComNode.length; i++){
                    hierarchyComNode[i] = new int[numNode];
                    for (int j = 0; j < hierarchyComNode[i].length; j++){
                        hierarchyComNode[i][j] = j;
                    }
                }
            }
            
            System.out.println("After Louvain Clustering");
            
            retList = processLouvainClusterSet(g, hierarchyComNode, isTopLevel);
            System.out.println("After processing LC and running property-based clustering");
            stopwatch.stop();

            /* we can stop program in hard-code manner by setting UIWanted to false */
            if (!UIWanted) 
                System.exit(0);
            

        } catch (FileNotFoundException ex) {
            System.out.println("File not found! "+ex.getMessage());
            Logger.getLogger(IntBioGraphNaviSysApp.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            System.out.println("IOException! "+ex.getMessage());
            Logger.getLogger(IntBioGraphNaviSysApp.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            return retList;
        }
    }
    /** Initialize many things that will be used in property-based clustering
     * Currently, it loads GO terms map, namespace weight map
     */
    public void preparePropertyInfoProcessor() throws FileNotFoundException, IOException{
        /* load GO terms map from text file */
        GOProcessor.loadGOTermsMap();
        /* initialize map for GO namespac */
        Map<NameSpace, Double> map = new HashMap<NameSpace, Double>();
        map.put(NameSpace.BP, 1.0);
        map.put(NameSpace.MF, 1.0);
        map.put(NameSpace.CC, 1.0);
        GOProcessor.setWeightMap(map);
    }

    /**
     * Process raw cluster set information from louvain clustering by correspondingly putting
     * BioObjects into sets.
     * isTopLevel boolean is used to specify if we want to input information of overall structure
     * into hierCSet and comNodehierSet.
     * Then, perform property-based clustering if appropriate.
     * Also, it visualizes the result as a graph of metanodes and metaedges
     * @param g
     * @param hierarchyComNode
     * @param isTopLevel
     * @param doOnAllNodesInCanVas
     * @return
     * @throws java.io.IOException
     */
    private ArrayList processLouvainClusterSet(Graph g, int[][] hierarchyComNode,boolean isTopLevel) throws IOException {
        ArrayList retList = putLouvainResultToSet(hierarchyComNode,isTopLevel);
//        Set<Set> cSet = new HashSet<Set>((Set)retList.get(0));
//        Set<Set> comNodeCSet = new HashSet<Set>((Set)retList.get(1));
//        if (isTopLevel) {
//            printStatAboutClusters(g,(Set)retList.get(0));
//        }

        /* TO-DO: I will move below codes to outside louvainCluster in the near future */
        

        return retList;

    }

    /**
     * Put raw louvain clustering results into the set of set of BioObjects
     * really used in the graph.
     * @param hierarchyComNode
     * @param isTopLevel
     * @return
     */
    private ArrayList putLouvainResultToSet(int[][] hierarchyComNode, boolean isTopLevel){
        ArrayList<Integer> labelList = new ArrayList();
        ArrayList<Set<Object>> csList = new ArrayList();
        ArrayList<Set<Object>> newCsList = new ArrayList();
        ArrayList<Set<Object>> arrComNode = new ArrayList();
        ArrayList<Set<Object>> newArrComNode = new ArrayList();
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();

        if (isTopLevel) {
            hierCSet = new HashSet[hierarchyComNode.length];
            comNodeHierSet = new HashSet[hierarchyComNode.length];
        }

        System.out.println("Start process raw cluster set!");

        // hierarchyComNode should have length >= 2
        // process level 0-1 of hierarchy array
        for (int j = 0; j < hierarchyComNode[1].length; j++) {
            csList.add(new HashSet<Object>());
            arrComNode.add(new HashSet());
        }
        for (int j = 0; j < hierarchyComNode[0].length; j++) {
            if (!labelList.contains(hierarchyComNode[0][j])) {
                labelList.add(hierarchyComNode[0][j]);
            }
            int index = labelList.indexOf(hierarchyComNode[0][j]);
            Set<Object> cluster = csList.get(index);
            Set clusterOfComNode = arrComNode.get(index);
            cluster.add(nodeMap.get(j));
            clusterOfComNode.add(nodeMap.get(j));
        }

        comNodeCSet = new HashSet<Set>();
        for (int l = 0; l < csList.size(); l++) {
            /* only at this level we can use cluster instead of clusterOfComNode */
            Set<Object> cluster = csList.get(l);
            cSet.add(cluster);
            comNodeCSet.add(cluster);

            flatClustToComNodeClust.put(cluster, cluster);
            comNodeClustToFlatClust.put(cluster, cluster);
//            System.out.println(cluster);
        }

        cSetToComNodeCSet.put(cSet, comNodeCSet);

        if (isTopLevel) {
            hierCSet[0] = cSet;
            comNodeHierSet[0] = comNodeCSet;
//            System.out.println("\ncomNodehierSet "+0+": "+comNodehierSet[0]+"\n");
//            System.out.println("\nhierCSet "+0+": "+hierCSet[0]+"\n");
        }

        // process level i and i+1
        for (int i = 1; i < hierarchyComNode.length - 1; i++) {
            labelList.clear();
            newCsList.clear();
            newArrComNode.clear();
//            System.out.println("size "+(i)+" "+hierarchyComNode[i].length);
//            System.out.println("size "+(i+1)+" "+hierarchyComNode[i+1].length);
            for (int j = 0; j < hierarchyComNode[i + 1].length; j++) {
                newCsList.add(new HashSet<Object>());
                newArrComNode.add(new HashSet());
            }
//            System.out.println("size of csList "+csList.size());
//            System.out.println("size of new csList "+newCsList.size());
            for (int j = 0; j < hierarchyComNode[i].length; j++) {
                if (!labelList.contains(hierarchyComNode[i][j])) {
                    labelList.add(hierarchyComNode[i][j]);
                }

                int index = labelList.indexOf(hierarchyComNode[i][j]);
                Set<Object> cluster = newCsList.get(index);
                Set clusterOfComNode = newArrComNode.get(index);

                cluster.addAll(csList.get(j));
                clusterOfComNode.add(arrComNode.get(j));
            }

            //clone newCsList to csList safely
            csList.clear();
            for (Set<Object> av : newCsList) {
                Set<Object> list = new HashSet<Object>();
                csList.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }

            //clone newArrComNode to arrComNode safely
            arrComNode.clear();
            for (Set<Object> av : newArrComNode) {
                Set<Object> list = new HashSet<Object>();
                arrComNode.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }

            cSet = new HashSet<Set>();
            comNodeCSet = new HashSet<Set>();

            for (int l = 0; l < csList.size(); l++) {

                Set<Object> cluster = csList.get(l);
                Set clusterOfComNode = arrComNode.get(l);

                cSet.add(cluster);
                comNodeCSet.add(clusterOfComNode);

                flatClustToComNodeClust.put(cluster, clusterOfComNode);
                comNodeClustToFlatClust.put(clusterOfComNode, cluster);

//                System.out.println("ClusterOfComNode: "+clusterOfComNode);
//                System.out.println(cluster);
            }

            cSetToComNodeCSet.put(cSet, comNodeCSet);

            if (isTopLevel) {
                hierCSet[i] = cSet;
                comNodeHierSet[i] = comNodeCSet;

//                System.out.println("\ncomNodehierSet " + i + ": " + comNodeHierSet[i] + "\n");
//                System.out.println("\nhierCSet " + i + ": " + hierCSet[i] + "\n");
            }

        }
        ArrayList retList = new ArrayList();
        retList.add(cSet); retList.add(comNodeCSet);
        return retList;
    }
    
    /**
     * Print statistics about louvain clusters
     * @param g
     * @param cSet
     */
    private void printStatAboutClusters(Graph g, Set<Set> cSet) {

        int numSingle = 0;
        int numClustSizeMore1 = 0;
        double avgClustSize = 0;
        int biggestClustSize = -1;
        int sumClustSize = 0;

        /* calculate some stats */

        for (Set<Object> set : cSet) {
            int size = set.size();
            if (size == 1) {
                numSingle++;
            } else {
                numClustSizeMore1++;
            }
            if (size > biggestClustSize) {
                biggestClustSize = size;
            }
            sumClustSize += size;
        }

        avgClustSize = (double) sumClustSize / cSet.size();
        double percSingle = (double) numSingle / g.getVertexCount();
        double percBiggest = (double) biggestClustSize / g.getVertexCount();

        System.out.println("\n======================");
        System.out.println("Statistics of louvain clusters");
        System.out.println("======================");
        System.out.println("Single node num: " + numSingle + " percent: " + percSingle);
        System.out.println("No. cluster size > 1: " + numClustSizeMore1);
        System.out.println("Avg. cluster size: " + avgClustSize);
        System.out.println("Biggest cluster size: " + biggestClustSize + " percent: " + (percBiggest * 100));
        System.out.println("======================\n");
    }

    /**
     * Do property-based clustering by using the result from cSet and comNodeCSet
     * @param cSet
     * @param comNodeCSet
     * @param isTopLevel
     * @param doOnAllNodesInCanVas
     * @return
     */
    public Set<Set> propertyBasedCluster(Set<Set> cSet, Set<Set>comNodeCSet, GOProcessor gop,boolean isTopLevel, boolean doOnAllNodesInCanVas, boolean populateGOTerm){
        
        if (doOnAllNodesInCanVas) {
            curCSetBeforePropClust = cSet;
            curComNodeCSetBeforePropClust = comNodeCSet;
        } else {
            /* for now we assume that if this method does not run on all nodes, it runs on peripheral nodes
             * of the node currently being concentrated and curCSetCentered et al. are used instead.
             */
            curCSetCentered = curCSetCenteredBPC = cSet;
            curComNodeCSetCentered = curComNodeCSetCenteredBPC = comNodeCSet;
        }
        
        GOProcessor gp = null;
        /* if we provides GOProcessor, use it */
        if (gop != null){
            gp = gop;
            if (populateGOTerm)
                gp.populateGOTerms(cSet);
        }
        else {
            gp = new GOProcessor();
//        StopWatch sw = new StopWatch();
//        sw.start();
            gp.populateGOTerms(cSet);
//        sw.stop();
//        System.out.println("Populate GO Terms Time Used "+sw);
        }

//        int thresh = 12;
        if ((cSet.size() == 1) && (cSet.iterator().next().size() >= Integer.parseInt(thresholdTextField.getText()))) {
            /* In this case, cSet is composed of only BioObjects, so destroy it to get them */
            System.out.println("\ncSet size = 1, destroy cSet to get raw BioObjs\n");
            System.out.println("Start special property-based clustering!");
            Set newset = new HashSet();
            newset.addAll(cSet.iterator().next());
            System.out.println("New cSet which comprises BioObjects: "+newset);

            gp.populateGOTerms(newset);
            semanticClusterList = gp.preCluster(newset, Integer.parseInt(thresholdTextField.getText()));
            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);

//            System.out.println("cSet after transform "+cSet);
            /*tentative*/
            if (doOnAllNodesInCanVas)
                curCSetBeforePropClust = newset;
            else
                curCSetCenteredBPC = newset;
            System.out.println("End special property-based clustering!");

        } else if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())){

            System.out.println("Start property-based clustering!");
            semanticClusterList = gp.preCluster(comNodeClustToFlatClust,comNodeCSet,cSet,Integer.parseInt(thresholdTextField.getText()));
            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);
            System.out.println("End property-based clustering!");

        } else {
            /* Do not run property-based clustering */
            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
        }

        if (doOnAllNodesInCanVas) {
            curGOP = gp;
            System.out.println("GO Processor clusterScoreMap size: "+curGOP.clusterScoreMap.size());
        } else {
            /* if do not run on all nodes, assume that it runs on peripheral nodes */
            curGOPCentered = gp;
        }
//        System.out.println("cSet: "+cSet.size());
        return cSet;
    }

    /**
     * put obtained nodesGoVectorMap into the global one.
     * GO Vector to be put will be subtracted from the local centroid of the data set
     * @param localNodesGOVectorMap
     */
    public void putInNodesGOVectorMapRelatively(Map<Object,DataVector> localNodesGOVectorMap){
        int allNumMember = 0;

        DataCluster dc = new DataCluster();
        dc.addAll(localNodesGOVectorMap.values());
        allNumMember = dc.getMembers().size();
//        for (DataVector dv: dc.getMembers()){
//            allNumMember += ((Set)dv.nodeRef).size();
//        }
//        System.out.println("putInNodesGOVectorMap all num member "+allNumMember);
        DataVector localCentroid = DataCluster.findCentroidFromDCList(new DataCluster[]{dc},allNumMember);

        for (DataVector dv: dc.getMembers()){
            DataVector resultVector = DataVector.minusVector(dv, localCentroid);
            nodesGOVectorMap.put(dv.nodeRef, resultVector);
        }

    }

    /**
     * Transform the result from data cluster list to metanodes really used in the graph.
     * @param dcList
     * @param topLevel
     * @param doOnAllNodesInCanvas
     * @return cSet containing new metanodes
     */
    public Set<Set> transformDataClusterList(DataCluster[] dcList,boolean topLevel,boolean doOnAllNodesInCanvas){
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();
        Set cluster;
        Set clusterComNode;

        System.out.println("Start transform data cluster to metanodes...");
        
        int sumOfAllMembers = 0;
        for (DataCluster dc : dcList){
                sumOfAllMembers += dc.getMembers().size();
        }

//        System.out.println("sum of all: "+sumOfAllMembers);
//        System.out.println("num of louvain "+numOfLouvainClusters);

        centroid = DataCluster.findCentroidFromDCList(dcList,sumOfAllMembers);

        for (int i = 0; i < dcList.length; i++){
            DataCluster dc = dcList[i];

            if (dc.getMembers().size() == 0){
                System.out.println("BUG!!!!: Found cluster with zero members !!!!!!");
                continue;
            }

            DataVector[] dvList = dc.getMembers().toArray(new DataVector[1]);
            cluster = new HashSet();
            clusterComNode = new HashSet();

            for (DataVector dv :dvList) {
                //nodeRef points to a cluster (set of set) not a real metanode in the graph
                if (dv.nodeRef instanceof Set){
                    cluster.addAll((Set)dv.nodeRef);
                } else {// nodeRef is BioObject
                    cluster.add(dv.nodeRef);
                }
                clusterComNode.add(dv.comNodeClusterRef);
            }
            
//            nodeToDataCluster.put(cluster, dc);
            flatClustToComNodeClust.put(cluster, clusterComNode);
            comNodeClustToFlatClust.put(clusterComNode,cluster);
            cSet.add(cluster);
            comNodeCSet.add(clusterComNode);

            DataVector resultVector = DataVector.minusVector(dc.getRepresentative(), centroid);
            nodesGOVectorMap.put(cluster, resultVector);

        }

        /* Input new information of hierCSet if this method is performed at the topLevel */
        if (topLevel){
            //extend capacity and copy the contents for hierCSet and ComNodeHierSet
            Set<Set>[] tmpHierCSet = new HashSet[hierCSet.length + 1];
            for (int i = 0; i < hierCSet.length; i++) {
                tmpHierCSet[i] = hierCSet[i];
            }
            tmpHierCSet[hierCSet.length - 1] = cSet;
            hierCSet = tmpHierCSet;

            tmpHierCSet = new HashSet[comNodeHierSet.length + 1];
            for (int i = 0; i < comNodeHierSet.length; i++) {
                tmpHierCSet[i] = comNodeHierSet[i];
            }
            tmpHierCSet[comNodeHierSet.length - 1] = comNodeCSet;
            comNodeHierSet = tmpHierCSet;
//            System.out.println("\ncomNodehierSet " + (comNodeHierSet.length-2) + ": " + comNodeHierSet[comNodeHierSet.length-2] + "\n");
//            System.out.println("\nhierCSet " + (hierCSet.length-2) + ": " + hierCSet[hierCSet.length-2] + "\n");
        }

        /* do it on all nodes or else just do it on peripheral nodes of node being concentrated. */
        if (doOnAllNodesInCanvas) {
            curComNodeCSet = comNodeCSet;
            curCSet = cSet;
        } else {
            curComNodeCSetCentered = comNodeCSet;
            curCSetCentered = cSet;
        }

        cSetToComNodeCSet.put(cSet, comNodeCSet);

//        for (Set set : cSet){
//            System.out.println("cluster with size "+set.size());
//        }

        System.out.println("End transform data cluster to metanodes...");

        return cSet;

    }

    /**
     * Visualize the result (cSet) on the canvas
     * @param cSet
     */
    public void visualizeResults(Set<Set> cSet) {
        colorCluster(cSet, mainColor);
        layout.setGraph(dynamicGraph);
        currentLevelGraph = dynamicGraph;
        vv.setGraphLayout(layout);
        vv.repaint();
    }
    
    /**
     * Create a graph from cSet 
     * @param cSet
     * @return
     */
    public Graph createGraph(Set cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        nodeToClusterMap = new HashMap<BioObject, Object>();
        Map<Pair,MetaEdge> newEdgeMap = new HashMap<Pair,MetaEdge>();
        Set newSet = new HashSet(cSet);

        for (Object obj : cSet){
            if (obj instanceof Set){
                Set set = (Set)obj;
                Object suspect = set.iterator().next();
                /* Destroy a set of one BioObject and get its content */
                if ((set.size() == 1) && (suspect instanceof BioObject)){
//                    System.out.println("suspect detected "+suspect);
                    newgraph.addVertex(suspect);
                    newSet.add(suspect);
                    newSet.remove(obj);
                    nodesGOVectorMap.put(suspect, nodesGOVectorMap.get(obj));
                    nodesGOVectorMap.remove(obj);
                    continue;
                }
            }
            newgraph.addVertex(obj);
        }

        /* calculate property edge between cluster */
        Object[] cSetArr = newSet.toArray(new Object[1]);
        for (int i = 0; i < cSetArr.length; i++){
            for (int j = i+1; j < cSetArr.length; j++){

                Object edge = newgraph.findEdge(cSetArr[i], cSetArr[j]);
                if (edge == null){
                    edge = new PropertyEdge(cSetArr[i]+"<->"+cSetArr[j], nodesGOVectorMap.get(cSetArr[i]), nodesGOVectorMap.get(cSetArr[j]));
                    newgraph.addEdge(edge, cSetArr[i],cSetArr[j]);
                }
                else if (!(edge instanceof PropertyEdge))
                    System.out.println("What 's edge!!!");

            }
            if (cSetArr[i] instanceof Set) {
                for (Object obj : (Set) cSetArr[i]) {
                    nodeToClusterMap.put((BioObject) obj, cSetArr[i]);
                }
            } else {
                nodeToClusterMap.put((BioObject) cSetArr[i], cSetArr[i]);
            }
        }

        /* Create metaedges between clusters */
        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
            Object preClusterFirst = nodeToClusterMap.get(pair.getFirst());
            Object preClusterSecond = nodeToClusterMap.get(pair.getSecond());

            if (preClusterFirst == null || preClusterSecond == null)
                continue;
            if (preClusterFirst == preClusterSecond)
                continue;

            Pair newPair = new Pair(preClusterFirst,preClusterSecond);
            Object tmpEdge = newEdgeMap.get(newPair);
            /* if no such metaedge, create an edge, or else just add new edge into existing metaedge */
            if (tmpEdge == null)
            {
                newPair = new Pair(preClusterSecond,preClusterFirst);
                tmpEdge = newEdgeMap.get(newPair);
                if (tmpEdge == null){
                    newEdgeMap.put(newPair, new MetaEdge(preClusterFirst+":"+preClusterSecond, edge));
                }
            } else {
                ((MetaEdge)tmpEdge).addEdge(edge);
            }

        }

        /* Add metaedges into graph */
        for (Pair key : newEdgeMap.keySet()){
            if (newEdgeMap.get(key).getNumEdgeSetBundled() > 0)
                newgraph.addEdge(newEdgeMap.get(key),key.getFirst(),key.getSecond());
        }

        return newgraph;
    }


    /* Initialize components zone */
    /**
     * Initialize components in the GUI.
     */
    private void initComponents(){
        Container content = getContentPane();
        JPanel east = initCompEast();
        JPanel west = initCompWest();
        JPanel p = new JPanel();

        content.add(east, BorderLayout.EAST);
        content.add(west, BorderLayout.WEST);
        pack();
        setVisible(true);
    }

    public JPanel initCompEast(){
        JPanel east = new JPanel();
        east.setPreferredSize(new Dimension(180, 600));

        JButton openFile = new JButton("Open");
        openFile.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent arg0) {
                inConcentrationMode = false;
                JFileChooser fileChooser = new JFileChooser(fileToOpen);
                File tempFile = fileToOpen;

                fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                fileChooser.setFileFilter(new MNetFileFilter());
//                    fileChooser.setFileHidingEnabled(false);
                fileChooser.showOpenDialog(IntBioGraphNaviSysApp.this);

                fileToOpen = fileChooser.getSelectedFile();

                if (fileToOpen != null) {
                    try {
                        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));

                        StopWatch loadingTime = new StopWatch();
                        loadingTime.start();

                        realGraph = loadModNet(br);
                        originalGraph = realGraph;
                        dynamicGraph = realGraph;
                        currentLevelGraph = dynamicGraph;

                        loadingTime.stop();
                        System.out.println("Time used for loading from input file: " + loadingTime);

                        louvainCluster(realGraph, realGraph.getVertexCount(),true);
                        vv.setGraphLayout(layout);
//                        vv.getRenderContext().getParallelEdgeIndexFunction().reset();

                        currentLevel = 0;
                        zoomInButton.setEnabled(true);
                        zoomOutButton.setEnabled(false);

                    } catch (IOException ex) {
                        Logger.getLogger(IntBioGraphNaviSysApp.class.getName()).log(Level.SEVERE, null, ex);
                    }
                } else {
                    fileToOpen = tempFile;
                }
            }
        });


        JButton saveButton = new JButton("Save");
        saveButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                JFileChooser chooser = new JFileChooser(new File("."));
//                    chooser.setAcceptAllFileFilterUsed(false);
                int option = chooser.showSaveDialog(IntBioGraphNaviSysApp.this);

                if (option == JFileChooser.APPROVE_OPTION) {
                    File file = chooser.getSelectedFile();
                    int width = vv.getWidth();
                    int height = vv.getHeight();

                    BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
                    Graphics2D graphics = bi.createGraphics();
                    vv.paint(graphics);
                    graphics.dispose();

                    try {
                        ImageIO.write(bi, "jpeg", file);
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }
            }
        });

        
        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent arg0) {
                inConcentrationMode = false;
//                    Layout layout = vv.getGraphLayout();
                dynamicGraph = currentLevelGraph;
//                    layout.setDelegate(new CircleLayout<Object,Object>(currentLevelGraph));
                layout.removeAll();
                layout.setGraph(currentLevelGraph);
                layout.initialize();

                curCSetCentered = null;
                curCSetCenteredBPC = null;
                curComNodeCSetCentered = null;
                curComNodeCSetCenteredBPC = null;

                colorCluster(curCSet, mainColor);

                vv.setGraphLayout(layout);
                vv.repaint();

            }
        });

        zoomOutButton = new JButton("Zoom Out");
        zoomOutButton.setEnabled(false);
        zoomOutButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {

                zoomInButton.setEnabled(true);

                ViewHistory vh = viewHistoryList.remove(viewHistoryList.size() - 1);
                /* retrieve system information from viewhistory */
                nodeToClusterMap = vh.getNodeToClusterMap();
                dynamicGraph = vh.getStoredGraph();
                GOProcessor gp = vh.gop;
                curCSetBeforePropClust = vh.cSetBeforeVis;
                curComNodeCSetBeforePropClust = vh.comNodeCSetBeforeVis;

//                System.out.println("cset before vis clust size " + curCSetBeforePropClust.size());

                /* meaning that this is the top level, cannot zoom out anymore */
                if (viewHistoryList.size() == 0) 
                {
                    zoomOutButton.setEnabled(false);
                }
                curCSet = curCSetBeforePropClust;
                curComNodeCSet = curComNodeCSetBeforePropClust;
                curGOP = gp;
//                    System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
//                    System.out.println("GO Proc: "+curGOP.clusterScoreMap);

                layout.setGraph(dynamicGraph);
                currentLevelGraph = vh.getUsualGraph();

                vv.setGraphLayout(layout);
                vv.repaint();

            }
        });


        zoomInButton = new JButton("Zoom In");
        zoomInButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {

                Set pickedSet = vv.getPickedVertexState().getPicked();
                System.out.println("pickedSet size: " + pickedSet.size());
                boolean bad = false;
                if (pickedSet.size() != 0) {
                    for (Object obj : pickedSet) {
                        if (obj instanceof BioObject) {
                            bad = true;
                            break;
                        }
                    }
                    if (!bad) {
                        zoomInAction(pickedSet);
//                        reLouvainCluster(curCSetBeforePropClust, true);
                    }
                }
                

            }
        });

        

        JPanel grid = new JPanel(new GridLayout(1, 2));
        grid.add(openFile);
        grid.add(saveButton);
        east.add(grid);

        JPanel grid2 = new JPanel(new GridLayout(1, 1));
        grid2.add(resetButton);
        east.add(grid2);
        
        JPanel zoomPanel = new JPanel(new GridLayout(2, 1));
        zoomPanel.setBorder(BorderFactory.createTitledBorder("Zooming"));
        zoomPanel.add(zoomInButton);
        zoomPanel.add(zoomOutButton);
        east.add(zoomPanel);

        JPanel p = new JPanel();

        final JPanel eastControls = new JPanel();
        eastControls.setOpaque(true);
        eastControls.setLayout(new BoxLayout(eastControls, BoxLayout.Y_AXIS));
        eastControls.add(Box.createVerticalGlue());

        //eastControls.add(eastSize);
        eastControls.add(Box.createVerticalGlue());
        east.add(eastControls);

        p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Louvain Clustering"));

        JButton reLouvainButton = new JButton("     Run     ");
        reLouvainButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                /* if we want to cluster peripheral clusters, not all clusters */
                if (inConcentrationMode) {
//                if (curCSetCenteredBPC != null) {
                    Set cSet = new HashSet();
                    ArrayList retList = reLouvainCluster(curCSetCenteredBPC, false);
                    Set<Set> cSetFromPropClust = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1),null,false,false,true);
//                    curCSetCentered = (Set<Set>) retList.get(0);

                    for (Object picked : centerNodeSet) {
                        cSet.add(picked);
                    }
//                    cSet.addAll(curCSetCentered);
                    cSet.addAll(cSetFromPropClust);

                    dynamicGraph = createGraph(cSet);

                    colorCluster(centerNodeSet, mainColor);
                    colorCluster(cSetFromPropClust, peripheralColor);

                    layout.setGraph(dynamicGraph);
                    vv.setGraphLayout(layout);
                    
                } else {
                    /* redo louvainCluster on all nodes */
                    ArrayList retList = null;
                    Set<Set> cSet = null;
                    if (!zoomOutButton.isEnabled()){
                        retList = reLouvainCluster(curCSetCenteredBPC, true);
                        cSet = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1),null,true,true,true);
                    }
                    else {
                        retList = reLouvainCluster(curCSetCenteredBPC, false);
                        cSet = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1),null,false,true,true);
                    }
                    
                    dynamicGraph = createGraph(cSet);
                    visualizeResults(cSet);
                }
            }
        });
        p.add(reLouvainButton);
        east.add(p);

        p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Search For: (Name)"));

        JPanel grids = new JPanel(new GridLayout(2, 1));

        JPanel tmpPanel = new JPanel();
        tmpPanel.add(searchTextField);
        grids.add(tmpPanel);

        searchTextField.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (searchTextField.getText().length() != 0) {
                    searchFor();
                }

            }
        });

        JButton sButton = new JButton("  Run  ");
        sButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (searchTextField.getText().length() != 0) {
                    searchFor();
                }
            }
        });

        tmpPanel = new JPanel();
        tmpPanel.add(sButton);
        grids.add(tmpPanel);

        p.add(grids);
        east.add(p);

        searchResList = new JList(listModel);
        searchResList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        searchResList.setLayoutOrientation(JList.VERTICAL);
        searchResList.setVisibleRowCount(7);

        listScroller = new JScrollPane(searchResList);
        listScroller.setPreferredSize(new Dimension(150, 150));

        final JButton focusSearchButton = new JButton("Focus");
        focusSearchButton.setActionCommand("Focus");
        focusSearchButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                focusNodeBySearch((BioObject) searchResList.getSelectedValue());
            }
        });

        searchResList.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    focusSearchButton.doClick(); //emulate button click
                }
            }
        });

        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));
        listScroller.setAlignmentX(JComponent.CENTER_ALIGNMENT);
        focusSearchButton.setAlignmentX(JComponent.CENTER_ALIGNMENT);
    
        panel.add(listScroller);
        panel.add(focusSearchButton);

        east.add(panel);

        return east;
    }

    public JPanel initCompWest(){
        JPanel west = new JPanel();
        west.setPreferredSize(new Dimension(200, 600));

        JPanel p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Property-Based Clustering"));
        JPanel grid3 = new JPanel(new GridLayout(3, 1));

        ccSlider.setMajorTickSpacing(2);

        ccSlider.setMinorTickSpacing(1);
        ccSlider.setPaintTicks(true);
        TitledBorder title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Cellular Component");
        title.setTitleColor(new Color(0xED143F));
        title.setTitlePosition(TitledBorder.CENTER);
        ccSlider.setBorder(title);


        bpSlider.setMajorTickSpacing(2);
        bpSlider.setMinorTickSpacing(1);
        bpSlider.setPaintTicks(true);
        title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Biological Process");
        title.setTitlePosition(TitledBorder.CENTER);
        title.setTitleColor(new Color(0x3425B1));
        bpSlider.setBorder(title);

        mfSlider.setMajorTickSpacing(2);
        mfSlider.setMinorTickSpacing(1);
        mfSlider.setPaintTicks(true);
        title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Molecular Function");
        title.setTitlePosition(TitledBorder.CENTER);
        title.setTitleColor(new Color(0x338F06));
        mfSlider.setBorder(title);

        grid3.add(ccSlider);
        grid3.add(mfSlider);
        grid3.add(bpSlider);
//            grid3.setPreferredSize(new Dimension(p.getPreferredSize().width-10,grid3.getPreferredSize().height));
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));
        p.add(grid3);

        JPanel grid2 = new JPanel(new GridLayout(2, 1));

        grid3 = new JPanel();

//            p = new JPanel();
//            p.setBorder(BorderFactory.createTitledBorder("Vis Threshold"));
//            grid3 = new JPanel(new GridLayout(2, 1));
        JLabel lab = new JLabel("#Clusters: ");
        lab.setLabelFor(thresholdTextField);
        grid3.add(lab);
        grid3.add(thresholdTextField);
        thresholdTextField.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
//                    rePropCluster(false);
                refineGOAnnot(e);
            }
        });
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));
        grid2.add(grid3);

        JButton GORefineButton = new JButton("Run/Modify");
        GORefineButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                refineGOAnnot(e);
            }
        });
//            p.add(GORefineButton);
        JPanel tmpPanel = new JPanel();
        tmpPanel.add(GORefineButton);
        grid2.add(tmpPanel);

        p.add(grid2);
        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height + grid2.getPreferredSize().height));
        west.add(p);

        p = new JPanel();

        p.setBorder(BorderFactory.createTitledBorder("GO Edge Filter"));
        goEdgeSlider.setMajorTickSpacing(2);
        goEdgeSlider.setMinorTickSpacing(1);
        goEdgeSlider.setPaintTicks(true);
        goEdgeSlider.addChangeListener(new ChangeListener() {

            public void stateChanged(ChangeEvent e) {
                JSlider source = (JSlider) e.getSource();
                if (!source.getValueIsAdjusting()) {
                    double threshold = source.getValue();
//                        System.out.println("threshold "+threshold);
                    if (threshold == source.getMaximum()) {
//                        System.out.println("thresh max: " + threshold);
                        medp.setThresholdForSE(0.0);
                    } else if (threshold == 0.0) {
                        /* inner product will never be more than 1, i.e. show all edges */
                        medp.setThresholdForSE(2.0);
                    } else {
                        System.out.println("thresh " + (source.getMaximum() - threshold));
                        medp.setThresholdForSE(0.1 * (source.getMaximum() - threshold));
                    }
                    vv.repaint();
                }
            }
        });

        grid3 = new JPanel(new GridLayout(1, 1));
        grid3.add(goEdgeSlider);
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));
        p.add(grid3);
        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height));
        west.add(p);

        p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Concentrate on node(s)"));
        grid3 = new JPanel(new GridLayout(1, 2));
        grid3.add(new JLabel("Num Hops: "));
        grid3.add(numHops);
        numHops.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                concentrateNodes();
            }
        });
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));

        JButton centerButton = new JButton("  Run  ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
        centerButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                concentrateNodes();
            }
        });

        p.add(grid3);
        p.add(centerButton);
        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height + 30));
        west.add(p);

        return west;
    }

    /* Action performed when acting with components on the GUI zone*/
    /**
     * Highlight node being searched for.
     * @param nodeToFocus
     */
    public void focusNodeBySearch(BioObject nodeToFocus){

        if (highlightedNode != null)
        {
            vertexPaints.put(highlightedNode,highlightedNodeFormerColor);
        }
        searchedBioObj = nodeToFocus;
        highlightedNode =  nodeToClusterMap.get(nodeToFocus);
        highlightedNodeFormerColor = (Color) vertexPaints.get(highlightedNode);
        vertexPaints.put(highlightedNode, searchedColor);

        vv.repaint();
          
    }

    /**
     * Search for BioObject specified in the searchTextField
     * and populate the list shown on GUI
     */
    public void searchFor(){
        Set listRes = new HashSet();
        for (Object obj : dynamicGraph.getVertices())
        {
            if (obj instanceof Set){
                for (Object bioObj : (Set)obj){
                    BioObject bio = (BioObject)bioObj;
                    if (bio.getName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else if (bio.getStandardName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else {
                        for (String st: bio.getSynonym())
                        {
                            if (st.contains(searchTextField.getText())){
                                listRes.add(bio);
                                break;
                            }
                        }
                    }
                        
                }
            }
            else if (obj instanceof BioObject) {
                BioObject bio = (BioObject)obj;
                if (bio.getName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else if (bio.getStandardName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else {
                        for (String st: bio.getSynonym())
                        {
                            if (st.contains(searchTextField.getText())){
                                listRes.add(bio);
                                break;
                            }
                        }
                    }
            }
        }
        listModel.removeAllElements();
        System.out.println("Search result: ");
        for (Object res : listRes){
            System.out.println(res);
            listModel.addElement(res);

        }

    }
    
    public void refineGOAnnot(ActionEvent e){
        double ccValue = (double)ccSlider.getValue()/10;
        double mfValue = (double)mfSlider.getValue()/10;
        double bpValue = (double)bpSlider.getValue()/10;
//        System.out.println("cc "+ccValue);
//        System.out.println("mf "+mfValue);
//        System.out.println("bp "+bpValue);
        boolean nochange = true;
        if ((GOProcessor.getWeightMap().get(NameSpace.BP) != bpValue) || 
                (GOProcessor.getWeightMap().get(NameSpace.MF) != mfValue) ||
                (GOProcessor.getWeightMap().get(NameSpace.CC) != ccValue))
        {
            nochange = false;
        }
            
        GOProcessor.getWeightMap().put(NameSpace.BP, bpValue);
        GOProcessor.getWeightMap().put(NameSpace.MF, mfValue);
        GOProcessor.getWeightMap().put(NameSpace.CC, ccValue);
        rePropCluster(!nochange);
    }
    
    public void concentrateNodes(){
        inConcentrationMode = true;
        String toNumHops = numHops.getText();
        int numHopsFromCenter = 0;

        try{
            numHopsFromCenter = Integer.parseInt(toNumHops);
        } catch (NumberFormatException e){
            String toShown = "Number of hops should be integer only.";
            JOptionPane.showMessageDialog(IntBioGraphNaviSysApp.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);
        }

        Set pickedSet = vv.getPickedVertexState().getPicked();
        System.out.println("pickedSet size: "+pickedSet.size());

        if (pickedSet.size() != 0) {
            /* check if the vertex is the set (of set or of BioObject) */
            /* Process vertices to be concentrated */
            Set cSet = new HashSet(), comNodeCSet = new HashSet(), cSetCenter = new HashSet();
            Set nodesInCenterSet = new HashSet();
            Set nodesAroundCenter = new HashSet();
            Set toBeProcessed = new HashSet();
            centerNodeSet = new HashSet(pickedSet);

            for (Object ver : pickedSet) {
//                    System.out.println("\nVertex: "+ver);
                if (ver instanceof Set) {
                    Set vertex = (Set) ver;
//                        System.out.println("\nVertex size: "+vertex.size());
                    nodesInCenterSet.addAll(vertex);
                    cSet.add(vertex);
                    cSetCenter.add(vertex);
                    comNodeCSet.add(flatClustToComNodeClust.get(vertex));
                } else if (ver instanceof BioObject) {
                    BioObject vertex = (BioObject) ver;
                    nodesInCenterSet.add(vertex);
                    cSet.add(vertex);
                    cSetCenter.add(vertex);
                    /* Below code seems to be ok but not 100% sure */
                    comNodeCSet.add(vertex);
                }

            }
            toBeProcessed.addAll(nodesInCenterSet);

            for (int i = 1; i <= numHopsFromCenter; i++) {
                Set neighbors = new HashSet();
                Set tmpSet = new HashSet(toBeProcessed);
                Iterator it = tmpSet.iterator();
                for (; it.hasNext();) {
                    Object object = it.next();
                    BioObject bio = (BioObject) object;
                    for (Object neighbor : originalGraph.getNeighbors(bio)) {
                        if (!nodesInCenterSet.contains(neighbor) && !nodesAroundCenter.contains(neighbor)) {
                            neighbors.add(neighbor);
                        }
                    }
                    toBeProcessed.addAll(neighbors);
                    toBeProcessed.remove(object);
                }
                nodesAroundCenter.addAll(toBeProcessed);
            }

            Set newCSet = new HashSet();
            ArrayList retList = reLouvainCluster(nodesAroundCenter, false);
            Set cSetFromPropClust = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1), null,false,false,true);
            newCSet.addAll(cSetFromPropClust);

            cSet.addAll(newCSet);

            /* if edge size to be relouvain clustered is zero, curComNodeCSetCentered will be null
             * and no need to add to comnodecSet
             */
            if (curComNodeCSetCentered != null) {
                comNodeCSet.addAll(curComNodeCSetCentered);
            }

//            System.out.println("New Set ");
//            for (Object obj : newCSet) {
//                System.out.println("Vertex : " + obj);
//            }

//                System.out.println("curGOP size "+curGOP.clusterScoreMap.size() );
//                System.out.println("Picked Set");
//                for (Object ver : pickedSet) {
//                    curGOPCentered.clusterScoreMap.put(ver, curGOP.clusterScoreMap.get(ver));
//                    System.out.println("Vertex : "+ver);
//                    System.out.println("Vertex val: "+curGOPCentered.clusterScoreMap.get(ver));
//                }
//                System.out.println("Current GO Map");
//                putInNodesGOVectorMapRelatively(curGOPCentered.getNodesGOVectorMapBeforeCluster(cSet));

////        int thresh = 12;
//                if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
//                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, comNodeCSet, cSet, Integer.parseInt(thresholdTextField.getText()));
//                    cSet = transformDataClusterList(semanticClusterList, isTopLevel, doOnAllNodesInCanVas);
//                } else {
//                    putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
//                }
////        dynamicGraph = createGraphFromCSet(cSet);
//
//                if (doOnAllNodesInCanVas) {
//                    curGOP = gp;
//                    System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
//                } else {
//                    curGOPCentered = gp;
//                }

            System.out.println("cSet: " + cSet.size());

            dynamicGraph = createGraph(cSet);
            colorCluster(newCSet, peripheralColor);
            colorCluster(cSetCenter, mainColor);
            layout.setGraph(dynamicGraph);

            Graph tempGraph = SparseMultigraph.getFactory().create();
            for (Object object : cSetCenter) {
                tempGraph.addVertex(object);

            }
            Layout subLayout = new CircleLayout(tempGraph);
            subLayout.setInitializer(vv.getGraphLayout());
            subLayout.setSize(new Dimension(60, 60));

            layout.put(subLayout, new Point(vv.getSize().width / 2, vv.getSize().height / 2));

            vv.setGraphLayout(layout);
            vv.repaint();

        }
    }

    /**
     * Re-run louvain clustering by taking nodes in cSet as input
     * @param cSet
     * @param doOnAllNodesInCanvas
     * @return
     */
    public ArrayList reLouvainCluster(Set cSet, boolean isTopLevel){

        /* Build new input for Louvain Clusterer */
        Set<BioObject> bioObjectToClusteredSet = new HashSet<BioObject>();
        int id = 0;
        nodeMap.clear();
        final Map<BioObject,Integer> idMap = new HashMap<BioObject,Integer>();
        Iterator iter = cSet.iterator();

        /* Add bioObject to the set */
        for (;iter.hasNext();){
            Object obj = iter.next();
            if (obj instanceof Set)
            {
                Set<BioObject> set = (Set<BioObject>)obj;
                for (BioObject bio : set){
                    bioObjectToClusteredSet.add(bio);
                    nodeMap.put(id, bio);
                    idMap.put(bio, id);
                    id++;
                }
            }
//                bioObjectToClusteredSet.addAll((Set)obj);
            else if (obj instanceof BioObject){
                bioObjectToClusteredSet.add((BioObject) obj);
                nodeMap.put(id,(BioObject)obj);
                idMap.put((BioObject)obj,id);
                id++;
            }
        }
        Set edgeSet = new TreeSet(new Comparator() {
            public int compare(Object e1, Object e2) {
                Pair pair1 = originalGraph.getEndpoints(e1);
                Object e1v1 = pair1.getFirst();
                Object e1v2 = pair1.getSecond();
                Pair pair2 = originalGraph.getEndpoints(e2);
                Object e2v1 = pair2.getFirst();
                Object e2v2 = pair2.getSecond();
                if (idMap.get(e1v1) < idMap.get(e2v1)){
                    return -1;
                } else if (idMap.get(e1v1) == idMap.get(e2v1)){
                    if (idMap.get(e1v2) < idMap.get(e2v2)){
                        return -1;
                    } else if (idMap.get(e1v2) == idMap.get(e2v2)) {
                        return 0;
                    } else
                        return 1;
                } else
                    return 1;
            }
        });
        /* Add corresponding edges to the edgeSet*/
        for (BioObject bio : bioObjectToClusteredSet){
            for (Object edge : originalGraph.getIncidentEdges(bio))
            {
                Pair pair = originalGraph.getEndpoints(edge);
                Object firstVertex = pair.getFirst();
                Object secondVertex = pair.getSecond();
                if (!idMap.containsKey(firstVertex))
                    continue;
                if (!idMap.containsKey(secondVertex))
                    continue;
                edgeSet.add(edge);
            }
//            edgeSet.addAll(originalGraph.getIncidentEdges(bio));
        }

        int numEdge = edgeSet.size();
        System.out.println("Edge set size to be new input for Louvain Clustering: "+numEdge);
        System.out.println("BioObject set size to be new input for Louvain Clustering: "+bioObjectToClusteredSet.size());
        
        sArr = new int[numEdge];
        dArr = new int[numEdge];
        if (wArr != null)
            wArr = new double[numEdge];
        int i = 0;

        /* Build new three input array for Louvain Clusterer */
//        StopWatch sw = new StopWatch();
//        sw.start();

        for (Object edge : edgeSet){
            Pair pair = originalGraph.getEndpoints(edge);
            Object firstVertex = pair.getFirst();
            Object secondVertex = pair.getSecond();
//            System.out.println(idMap.get(firstVertex)+":"+idMap.get(secondVertex));
            sArr[i] = idMap.get(firstVertex);  dArr[i] = idMap.get(secondVertex);
            if (isWeightGraph) {
                int weight = ew.getWeight(edge);
                wArr[i] = weight;
            }
            i++;
        }
        if (i == 0)
            sArr = null;

//        sw.stop();
//        System.out.println("Load to String time "+sw);

//            MainLouvain ml = new MainLouvain();
//            int[][] hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
//            System.out.println("After Louvain Clustering");
//            preparePropertyInfoProcessor();
//            processLouvainClusterSet(g, hierarchyComNode, true, true);
//            System.out.println("After processing LC and running property-based clustering");


        /* TO-DO: delete previous codes */
        ArrayList retList = louvainCluster(dynamicGraph, bioObjectToClusteredSet.size(), isTopLevel);

//
//
//        MainLouvain ml = new MainLouvain();
//        try {
            
////            int[][] hierarchyComNode = ml.louvainClusterer(fileToOpen.getPath(),true);
//            int[][] hierarchyComNode = null;
//            if (edgeSet.size() > 0) {
////                int[][] hierarchyComNode = ml.louvainClusterer(toLouvainClusterer, false);
//                hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
//            } else
//            {
//                hierarchyComNode = new int[2][];
//                for (i = 0; i < hierarchyComNode.length; i++){
//                    hierarchyComNode[i] = new int[bioObjectToClusteredSet.size()];
//                    for (int j = 0; j < hierarchyComNode[i].length; j++){
//                        hierarchyComNode[i][j] = j;
//                    }
//                }
//            }
//            cSet = processLouvainClusterSet(dynamicGraph, hierarchyComNode, false, doOnAllNodesInCanvas);
//
//        for (Object edge : edgeSet){
//            Pair pair = originalGraph.getEndpoints(edge);
//            Object firstVertex = pair.getFirst();
//            Object secondVertex = pair.getSecond();
//            if (!nodeMap.containsValue(firstVertex))
//                nodeMap.put(id,(BioObject) firstVertex);
//
//        }
//        } catch (FileNotFoundException ex) {
//            Logger.getLogger(IntBioGraphNaviSysApp.class.getName()).log(Level.SEVERE, null, ex);
//        } catch (IOException ex) {
//            Logger.getLogger(IntBioGraphNaviSysApp.class.getName()).log(Level.SEVERE, null, ex);
//        }
        return retList;
    }

    public void rePropCluster(boolean newAnnot){
        /* if inConcentrationMode is true, the program is concentrating on some node(s). */
        if (inConcentrationMode) {
//        if (curCSetCenteredBPC != null) {
            if (curCSetCenteredBPC.size() >= Integer.parseInt(thresholdTextField.getText())){

                Set cSetFromPropClust = propertyBasedCluster(curCSetCenteredBPC, curComNodeCSetCenteredBPC, curGOPCentered, false, false, newAnnot);



//
//                GOProcessor gp = curGOPCentered;
//                if (newAnnot)
//                    gp.populateGOTerms(curCSetCenteredBPC);
//                System.out.println("curCSetCenteredBVC: GO clusterScoreMap size: " + curGOP.clusterScoreMap.size());
//                int numClust = Integer.parseInt(thresholdTextField.getText());
//                if (!(curCSetCenteredBPC.iterator().next() instanceof BioObject)) {
//                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetCenteredBPC, curCSetCenteredBPC, numClust);
//                } else {
//                    semanticClusterList = gp.preCluster(curCSetBeforePropClust, numClust);
//                }
//                curCSetCentered = transformDataClusterList(semanticClusterList, false, false);

                Set cSet = new HashSet();
//                System.out.println("CenterNodeSet: "+centerNodeSet);
                for (Object picked : centerNodeSet){
                    cSet.add(picked);
                }
                cSet.addAll(cSetFromPropClust);
                dynamicGraph = createGraph(cSet);
                
                colorCluster(centerNodeSet,mainColor);
                colorCluster(cSetFromPropClust, peripheralColor);

                layout.setGraph(dynamicGraph);
                vv.setGraphLayout(layout);
                vv.repaint();

//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
//                StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
////                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
//                LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
////                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
////                                    staticLayout);
//                Animator animator = new Animator(lt);
//                animator.start();
//                layout.setGraph(dynamicGraph);
            } else {
                String toShown = "A number of nodes in the canvas are less than/equal to that specified in the text box. " + curCSetCenteredBPC.size();
                JOptionPane.showMessageDialog(IntBioGraphNaviSysApp.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);

            }
        } else
        if (curCSetBeforePropClust.size() >= Integer.parseInt(thresholdTextField.getText())){// || (newAnnot)) {
//                         GOProcessor gp = new GOProcessor();
//            zoomInButton.setEnabled(true);
//            GOProcessor gp = curGOP;
//            if (newAnnot)
//                gp.populateGOTerms(curCSetBeforePropClust);
//            System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
////                         gp.populateGOTerms(curCSetBeforePropClust);
//            int numClust = 0;
////            if (newAnnot)
////                numClust = curCSet.size();
////            else
//            numClust = Integer.parseInt(thresholdTextField.getText());
//            if (!(curCSetBeforePropClust.iterator().next() instanceof BioObject)) {
//                semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforePropClust, curCSetBeforePropClust, numClust);
//            } else {
//                semanticClusterList = gp.preCluster(curCSetBeforePropClust, numClust);
//            }
////            semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforePropClust, curCSetBeforePropClust, Integer.parseInt(thresholdTextField.getText()));
//            curCSet = transformDataClusterList(semanticClusterList, false,true);

            Set cSet = propertyBasedCluster(curCSetBeforePropClust, curComNodeCSetBeforePropClust, curGOP, false, true, newAnnot);

//            dynamicGraph = createGraphFromCSet(curCSet);
            dynamicGraph = createGraph(curCSet);
            visualizeResults(cSet);

//            currentLevelGraph = dynamicGraph;
//            colorCluster(curCSet, mainColor);
//
////        colorTopLevel(newgraph);
////        dynamicGraph = updateMetaEdges(dynamicGraph);
////        System.out.println("Dynamic Graph:"+dynamicGraph);
//            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
////                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
//            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
////                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
////                                    staticLayout);
//            Animator animator = new Animator(lt);
//            animator.start();
//            layout.setGraph(dynamicGraph);
        }


//
//
//        if (doOnAllNodesInCanVas) {
//            curCSetBeforePropClust = cSet;
//            curComNodeCSetBeforePropClust = comNodeCSet;
//        } else {
//            /* for now we assume that if this method does not run on all nodes, it runs on peripheral nodes
//             * of the node currently being concentrated and curCSetCentered et al. are used instead.
//             */
//            curCSetCentered = curCSetCenteredBPC = cSet;
//            curComNodeCSetCentered = curComNodeCSetCenteredBPC = comNodeCSet;
//        }
//
//        GOProcessor gp = new GOProcessor();
//
////        StopWatch sw = new StopWatch();
////        sw.start();
//        gp.populateGOTerms(cSet);
////        sw.stop();
////        System.out.println("Populate GO Terms Time Used "+sw);
//
////        int thresh = 12;
//        if ((cSet.size() == 1) && (cSet.iterator().next().size() >= Integer.parseInt(thresholdTextField.getText()))) {
//            /* In this case, cSet is composed of only BioObjects, so destroy it to get them */
//            System.out.println("\ncSet size = 1, destroy cSet to get raw BioObjs\n");
//            System.out.println("Start special property-based clustering!");
//            Set newset = new HashSet();
//            newset.addAll(cSet.iterator().next());
//            System.out.println("New cSet which comprises BioObjects: "+newset);
//
//            gp.populateGOTerms(newset);
//            semanticClusterList = gp.preCluster(newset, Integer.parseInt(thresholdTextField.getText()));
//            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);
//
////            System.out.println("cSet after transform "+cSet);
//            /*tentative*/
//            if (doOnAllNodesInCanVas)
//                curCSetBeforePropClust = newset;
//            else
//                curCSetCenteredBPC = newset;
//            System.out.println("End special property-based clustering!");
//
//        } else if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())){
//
//            System.out.println("Start property-based clustering!");
//            semanticClusterList = gp.preCluster(comNodeClustToFlatClust,comNodeCSet,cSet,Integer.parseInt(thresholdTextField.getText()));
//            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);
//            System.out.println("End property-based clustering!");
//
//        } else {
//            /* Do not run property-based clustering */
//            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
//        }
//
//        if (doOnAllNodesInCanVas) {
//            curGOP = gp;
//            System.out.println("GO Processor clusterScoreMap size: "+curGOP.clusterScoreMap.size());
//        } else {
//            /* if do not run on all nodes, assume that it runs on peripheral nodes */
//            curGOPCentered = gp;
//        }
//
//        } else {
//            String toShown = "A number of nodes in the canvas are less than/equal to that specified in the text box. " + curCSetBeforePropClust.size();
//            JOptionPane.showMessageDialog(IntBioGraphNaviSysApp.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);
//
//        }

    }

    /**
     * Already commonly used by doubleclickplugin function
     */
    private boolean zoomInAction(Set vertexToProcessed){
        inConcentrationMode = false;
        int countBioObjSet = 0;
        Set setOfComNodeCSet = new HashSet();

        /* check if the vertex is the set (of set or of BioObject) */
        boolean lastLevel = false;
        ViewHistory viewhist = new ViewHistory(curCSetBeforePropClust, curComNodeCSetBeforePropClust, curGOP, dynamicGraph);
        viewHistoryList.add(viewhist);
        viewhist.setStoredGraph(dynamicGraph); viewhist.setUsualGraph(currentLevelGraph);
        viewhist.setNodeToClusterMap(nodeToClusterMap);

//        System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
        zoomOutButton.setEnabled(true);
        Set tempCSet = new HashSet();
        Set comNodeSet = new HashSet();

        /* Deal with extracting members from vertex selected */
        for (Object ver : vertexToProcessed) {
            Set vertex = (Set) ver;
            System.out.println("\nVertex: " + vertex);
            System.out.println("\nVertex size: " + vertex.size());

            /* consider the case when mixing clusters together later */
            curComNodeCSet = flatClustToComNodeClust.get(vertex);
            System.out.println("curComNodeCSet: " + curComNodeCSet);

            /* considered now if populate two tempCSet */
            /* to be considered later --> ok now */
            while ((curComNodeCSet.size() == 1) && (curComNodeCSet.iterator().next() instanceof Set)) {
                /* for [[A,B]] set, it will terminate immediately and do not run in this loop */
                Set tmpSet = curComNodeCSet.iterator().next();
                if ((tmpSet.iterator().next() instanceof BioObject)) {
                    countBioObjSet++;
                    break;
                }
                curComNodeCSet = tmpSet;
                System.out.println("curComNodeCSet: " + curComNodeCSet);
            }
            setOfComNodeCSet.add(curComNodeCSet);
        }
        /* If not all pickedSet vertex contains BioObject directly,
         * Just treat them as normal set
         * Set of one member containing BioObject is also treated normally.
         * I will not extract a member of such sets anymore
         */
        /* if not all sets contain BioObjects directly, then */
        if (countBioObjSet != vertexToProcessed.size()) {
            for (Object object : setOfComNodeCSet) {
                Set comNodeCSet = (Set) object;
                Iterator it = comNodeCSet.iterator();
                for (; it.hasNext();) {
                    Object obj = it.next();
//                    System.out.println("Obj " + obj);
                    /* TO-DO: may not be used, need to be confirmed */
                    if (obj instanceof BioObject) {
                        tempCSet.add(obj);
                        lastLevel = true;
                    } else {
//                        if (comNodeClustToFlatClust.get(obj) != null) {
////                            System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
//                        }
                        tempCSet.add(comNodeClustToFlatClust.get(obj));
                    }

                }
                comNodeSet.addAll(comNodeCSet);
            }
        } /* Extract BioObjects of each set and mix them together to get one larger set
         */ else {
            for (Object object : setOfComNodeCSet) {
                Set comNodeCSet = (Set) object;
                /* assume that there is only one member (set of bioObj)*/
                lastLevel = true;
                Set setOfBioObj = (Set) comNodeCSet.iterator().next();
                Iterator it = setOfBioObj.iterator();
                for (; it.hasNext();) {
                    Object obj = it.next();
                    System.out.println("Obj " + obj);
                    if (obj instanceof BioObject) {
                        tempCSet.add(obj);

                    } /* TO-DO: may not be used, need to be confirmed */
                    else {
//
//                        if (comNodeClustToFlatClust.get(obj) != null) {
//                            System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
//                        }
                        tempCSet.add(comNodeClustToFlatClust.get(obj));
                    }
                }
                comNodeSet.addAll(setOfBioObj);
            }
        }

        /* Deal with new cluster set, just leave it and build graph or re-louvain cluster it*/
        curCSet = tempCSet;
        curComNodeCSet = comNodeSet;
        curCSetBeforePropClust = curCSet;
        curComNodeCSetBeforePropClust = curComNodeCSet;

        Set<Set> cSet = tempCSet;
        if (cSet.size() < Integer.parseInt(thresholdTextField.getText())){
            GOProcessor gp = new GOProcessor();
            gp.populateGOTerms(cSet);
            curGOP = gp;
            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
            if (lastLevel) {
                zoomInButton.setEnabled(false);
                System.out.println("cSet: "+cSet);
            }
        } else {
            ArrayList retList = reLouvainCluster(curCSetBeforePropClust, false);
            cSet = (Set)retList.get(0);
            cSet = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1), null,false,true,true);
        }

        dynamicGraph = createGraph(cSet);
        visualizeResults(cSet);


//        if (curCSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
////            ArrayList retList = reLouvainCluster(curCSetBeforePropClust, false, true);
////            Set<Set> cSet = propertyBasedCluster((Set)retList.get(0),(Set)retList.get(1), null,true,true,true);
////            /* if do on all nodes in canvas, visualize the result also, or else just do clustering */
////            dynamicGraph = createGraph(cSet);
////            colorCluster(cSet, mainColor);
////            currentLevelGraph = dynamicGraph;
//
//        } else {
////            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
//            if (lastLevel) {
//
////                        medp.setLowestLevel(true);
//                zoomInButton.setEnabled(false);
////                        dynamicGraph = createGraphFromBioNodeSet(curCSet);
//                dynamicGraph = createGraph(curCSet);
//            } else {
//
//                System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
////                        dynamicGraph = createGraphFromCSet(curCSet);
//                dynamicGraph = createGraph(curCSet);
//                colorCluster(curCSet, mainColor);
//            }
//        }



        /* Deal with search function */
        Object[] searchedListArr = new Object[listModel.size()];
        listModel.copyInto(searchedListArr);
//        System.out.println("listModel " + listModel.size());
//            System.out.println("searchedList "+searchedListArr.length);
        Set settemp = new HashSet(Arrays.asList(searchedListArr));
//        System.out.println("settemp " + settemp.size());
        Set currentVertices = new HashSet();
        for (Object obj : dynamicGraph.getVertices()) {
            if (obj instanceof Set) {
                currentVertices.addAll((Set) obj);
            } else if (obj instanceof BioObject) {
                currentVertices.add(obj);
            }
        }

        currentVertices.retainAll(settemp);
//        System.out.println("currentVer " + currentVertices);
        listModel.removeAllElements();

        for (Object obj : currentVertices)
            listModel.addElement(obj);

//        System.out.println("vertexToProcessed: "+vertexToProcessed.size());
        if ((highlightedNode != null) && vertexToProcessed.contains(highlightedNode)){
            focusNodeBySearch(searchedBioObj);
            searchResList.setSelectedValue(searchedBioObj, true);
//            System.out.println("Yeah contain");
        }
        vv.repaint();

        return true;
    }

    /**
     * Listener for double-click on vertices
     * @param <V>
     * @param <E>
     */
    public class DoubleClickZoomInPlugin<V,E> extends AbstractGraphMousePlugin
        implements MouseListener{
        public DoubleClickZoomInPlugin(){
            this(MouseEvent.BUTTON1_DOWN_MASK);
        }
        public DoubleClickZoomInPlugin(int modifier){
            super(modifier);
        }

        /* Deprecated */
//        private boolean isContainedIn(BioObject bioObj,Set hierSet){
//            boolean isContained = false;
//            if (hierSet.contains(bioObj)){
//                    return true;
//            }
//            for (Object obj : hierSet){
//                if (obj instanceof Set){
//
//
//                    isContained |= isContainedIn(bioObj,(Set) obj);
//                }
//            }
//            return isContained;
//        }
        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2 && !e.isConsumed()) {
                e.consume();

                final VisualizationViewer<V,E> vv = (VisualizationViewer<V, E>) e.getSource();
                final Point2D p = e.getPoint();
                GraphElementAccessor<V, E> pickSupport = vv.getPickSupport();
                if (pickSupport != null) {

                    final V vertex = pickSupport.getVertex(vv.getModel().getGraphLayout(), p.getX(), p.getY());

                    if (vertex != null){
                        System.out.println("\nVertex picked: "+vertex);

                        if (vertex instanceof Set){
                            Set toZoomInAction = new HashSet();
                            toZoomInAction.add(vertex);
                            zoomInAction(toZoomInAction);

                        }
                    }
                }

            }
        }

        public void mouseEntered(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(cursor);
        }

        public void mouseExited(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }

        public void mouseMoved(MouseEvent e) {
        }

        public void mousePressed(MouseEvent e) {

        }

        public void mouseReleased(MouseEvent e) {

        }
    }

    /* Decoration and VisualizationViewer related zone */

    /**
     * Initialize visualization viewer of JUNG
     */
    private void initVV() {
        layout = new AggregateLayout<Object, Object>(new CircleLayout<Object, Object>(dynamicGraph));
            ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);

//            System.out.println("size "+((CircleLayout)layout.getDelegate()).getSize());
//            System.out.println("radius "+((CircleLayout)layout.getDelegate()).getRadius());
//            ModSpringLayout1 ml = new ModSpringLayout1<Object,Object>(realGraph);
//            layout = new AggregateLayout<Object, Object>(ml);
//            layout = new AggregateLayout<Object, Object>(new SpringLayout<Object, Object>(realGraph));
//            layout = new AggregateLayout<Object, Object>(new FRLayout<Object, Object>(realGraph));
//            layout.setSize(new Dimension(350,350));

        vv = new VisualizationViewer<Object, Object>(layout);//,new Dimension(700, 600));
        vv.setBackground(Color.white);
//            System.out.println("vv "+vv.getSize());
//        DefaultParallelEdgeIndexFunction dpeif = DefaultParallelEdgeIndexFunction.getInstance();
//        vv.getRenderContext().setParallelEdgeIndexFunction(dpeif);

        vv.getRenderContext().setEdgeLabelTransformer(new EdgeLabeller(ew));

        medp = new EdgeDisplayPredicate();
//            vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line<Object,Object>());
        vv.getRenderContext().setEdgeIncludePredicate(medp);

        vv.setVertexToolTipTransformer(new NumMemberGOTips());
        vv.getRenderContext().setVertexLabelTransformer(new GOStringLabeller());
        vv.getRenderContext().setVertexFontTransformer(new VertexFontTransformer());
        vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
//            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(realGraph));

        vv.getRenderContext().setVertexFillPaintTransformer(MapTransformer.<Object, Paint>getInstance(vertexPaints));
        vv.getRenderContext().setVertexDrawPaintTransformer(new Transformer<Object, Paint>() {

            public Paint transform(Object v) {
                if (vv.getPickedVertexState().isPicked(v)) {
                    return Color.cyan;
                } else {
                    return Color.BLACK;
                }
            }
        });

//        vv.getRenderContext().setEdgeDrawPaintTransformer(MapTransformer.<Object, Paint>getInstance(edgePaints));
        vv.getRenderContext().setEdgeStrokeTransformer(new EdgeWeightStrokeFunction(ew));

        vv.getRenderContext().setEdgeDrawPaintTransformer(
                new PickedEdgePaintFunction<Object, Object>(new PickableEdgePaintTransformer<Object>(vv.getPickedEdgeState(), Color.black, Color.magenta), vv));

        DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
        vv.setGraphMouse(gm);
        gm.setMode(Mode.PICKING);
        gm.add(new DoubleClickZoomInPlugin<Object, Object>());

        vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(dynamicGraph));
        getContentPane().add(new GraphZoomScrollPane(vv));
    }

    private void colorCluster(Set vertices, Color c) {
        for (Object v : vertices) {
            vertexPaints.put(v, c);
        }

    }

    /** Tool tip generating method.
     *  If vertex is a set, generate #nodes inside, along with list of GO terms and score.
     *  If vertex is a bioObject, generate list of GO terms and score.
     */
    public class NumMemberGOTips<V,E> implements Transformer<V,String> {
        
        public String transform(V vertex) {
            String res = "<html>";

            if (vertex instanceof Set){
                res += "Num Nodes Inside: " + ((Set) vertex).size();
            }
            DataVector vec = nodesGOVectorMap.get(vertex);

            if (vec != null) {
                Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                    public int compare(Object o1, Object o2) {
                        Entry<String, Double> e1 = (Entry<String, Double>) o1;
                        Entry<String, Double> e2 = (Entry<String, Double>) o2;
                        if (e1.getValue() > e2.getValue()) {
                            return -1;
                        } else if (e1.getValue() < e2.getValue()) {
                            return 1;
                        } else {
                            return 0;
                        }
                    }
                });

                sortedMap.addAll(vec.getValueMap().entrySet());

                int i = 0;
                for (Entry entry : sortedMap) {

                    GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                    String toPrint = goTerm.getName();

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

                    DecimalFormat myFormatter = new DecimalFormat(".00");
                    String output = myFormatter.format(entry.getValue());

                    res += "<p>";
                    if (goTerm.getNamespace().equals(NameSpace.CC)) {
                        res += "<font color = #ED143F>";
                    } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                        res += "<font color = #338F06>";
                    } else {
                        res += "<font color = #3425B1>";
                    }
                    res += toPrint + " (" + output + ")";
                    res += "</font>";

                    i++;
                    /* list up to 7 terms */
                    if (i == 7) {
                        break;
                    }

                }
            } else {
                if (vertex instanceof BioObject) {
                    BioObject bio = (BioObject) vertex;
                    ArrayList<String> goidList = bio.getGoIdList();
                    int i = 0;
                    for (String s : goidList) {
                        res += "<p>" + s;// + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            }

            res += "</html>";
            return res;
        }
    }
    /** This method specify what to be written on each node
     *  If vertex is a set, write top three high-score GO terms, or else write the name of vertex.
     */
    public class GOStringLabeller extends ToStringLabeller {

        @Override
        public String transform(Object v) {

            String res = "<html><center>";

            if (v instanceof Set) {

                DataVector vec = nodesGOVectorMap.get(v);

                if (vec != null) {

                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {

                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();

                        if (toPrint.length() > 20) {
                            toPrint = toPrint.substring(0, 20);
                            toPrint += "...";
                        }

                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());

                        res += "<p>";
                        if (goTerm.getNamespace().equals(NameSpace.CC))
                            res += "<font color = #ED143F>";
                        else if (goTerm.getNamespace().equals(NameSpace.MF))
                            res += "<font color = #338F06>";
                        else
                            res += "<font color = #3425B1>";
                        res += toPrint + " (" + output + ")";
                        res += "</font>";
                        i++;
                        if (i == 3) {
                            break;
                        }
                    }
                    res += "</center>";
                } else {
                    res += "#Nodes: " + ((Set) v).size();
                }
            } else if (v instanceof BioObject) {
                res += ((BioObject)v).getName();
            }
            res += "</html>";
            return res;
        }

    }

    /**
     * File filter for modified .net pajek file
     */
    private class MNetFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("mnet")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Modified .net Pajek file";
        }
    }

    /**
     * Predicate for displaying edges
     * Whether to display edge or not depends on threshold and type of edge
     * @param <V>
     * @param <E>
     */
    private final class EdgeDisplayPredicate<V, E> implements Predicate<Context<Graph<V, E>, E>> //extends AbstractGraphPredicate<V,E>
    {
        private double thresholdForSE = .1;
        /* to be deleted in the future */
        private boolean isLowestLevel = false;

        public void setLowestLevel(boolean value) {
            isLowestLevel = value;
        }
        
        public double getThresholdForSE() {
            return thresholdForSE;
        }

        public void setThresholdForSE(double thresholdForSE) {
            this.thresholdForSE = thresholdForSE;
        }
        
        public boolean evaluate(Context<Graph<V, E>, E> context) {
//            Graph<V, E> graph = context.graph;
            E e = context.element;
//            if ((e instanceof MetaEdge) || (isLowestLevel)) {
            if (e instanceof MetaEdge) {
                return true;
            }
            if (e instanceof PropertyEdge){
                double val = ((PropertyEdge)e).getInnerProduct();
                if ((val > 0) && (val >= thresholdForSE))
                    return true;
            }
                
            return false;
        }
    }

    private final class EdgeLabeller<E> implements Transformer<E, String> {

        protected EdgeWeightLabeller edge_weight;

        public EdgeLabeller(EdgeWeightLabeller edgeWeight) {
            this.edge_weight = edgeWeight;
        }

        public String transform(E e) {
            double value = 1;
            if (e instanceof MetaEdge) 
            {
                value = ((MetaEdge) e).numEdgeSetBundled;
            } else if (e instanceof PropertyEdge){
                value = ((PropertyEdge)e).getInnerProduct();
                return ""+ String.format("%.3f",value);
            } else {
                value = edge_weight.getWeight(e);
            }
            if (value > 1) {
                return "" + String.format("%d", (int)value);
            } else {
                return "";
            }
        }
    }

    private final class EdgeWeightStrokeFunction<E>
            implements Transformer<E, Stroke> {
        float [] Dashes = {10.0F, 3.0F, 3.0F, 3.0F};
        protected final Stroke basic = new BasicStroke(1);
        protected final Stroke heavy = new BasicStroke(3);
        protected final Stroke heavy2 = new BasicStroke(6);
        
        protected final Stroke sBasic = new BasicStroke (1.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy =  new BasicStroke (3.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy2 = new BasicStroke (6.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);;

        protected final Stroke dotted = RenderContext.DOTTED;

        protected EdgeWeightLabeller edge_weight;
        protected Graph graph;

        public EdgeWeightStrokeFunction(EdgeWeightLabeller edge_weight) {
            this.edge_weight = edge_weight;
        }

        public Stroke transform(E e) {
            double value;
            if (e instanceof MetaEdge) {
                value = ((MetaEdge) e).getNumEdgeSetBundled();
                if (value > 7) {
                    return heavy2;
                } else if (value > 3) {
                    return heavy;
                } else {
                    return basic;
                }
            } else if (e instanceof PropertyEdge) {
                value = ((PropertyEdge) e).getInnerProduct();
                if (value > 0.8) {
                    return sHeavy2;
                } else if (value > 0.3) {
                    return sHeavy;
                } else {
                    return sBasic;
                }
            } else {
                value = edge_weight.getWeight(e);
                if (value > 7) {
                    return heavy;
                } else if (value > 3) {
                    return new BasicStroke(3);
                } else {
                    return basic;
                }
                
            }
            
        }

    }

    public class VertexFontTransformer implements Transformer<Object,Font>{
        
        public Font transform(Object vertex) {
           return new Font("Serif",Font.PLAIN,13);
        }
        
    }

    /**
     * Tell vv how to deal with vertex shape and size
     * @param <V>
     * @param <E>
     */
    private final class VertexShapeSizeAspect<V, E>
            extends AbstractVertexShapeTransformer<V>
            implements Transformer<V, Shape> {

        public Shape transform(V v) {

            if (v instanceof BioObject)
                return factory.getRegularPolygon(v, 3);
            return factory.getRectangle(v);
//            }
        }
        public VertexShapeSizeAspect(Graph<V, E> graphIn) {

            setSizeTransformer(new Transformer<V, Integer>() {

                public Integer transform(V v) {

                    int numMember = 0;

                    if (v instanceof Set) {
                        
                        numMember = ((Set)v).size();
                        int value = (int) (Math.log10(numMember) / Math.log10(4) * 20);
                        if (numMember == 0)
                            return 20;
                        else if (value < 20)
                            return 20;
                        else 
                            return value;

                    } else
                    {
                        return 20;
                    }
                }
            });
            
           

        }


    }

    public class PickedEdgePaintFunction<V, E> implements Transformer<E,Paint>{
        private Transformer<E, Paint> defaultFunc;

        public PickedEdgePaintFunction(Transformer<E, Paint> defaultEdgePaintFunction,
                                               VisualizationViewer<V, E> vv) {
            this.defaultFunc = defaultEdgePaintFunction;
        }

        public Paint transform(E e) {

            if (e instanceof PropertyEdge)
                return new Color(182,182,182);
            else
                return defaultFunc.transform(e);

        }

    }
  
}

class PropertyEdge extends Object{
    String name = "";
    DataVector dv1, dv2;
    double innerProduct = 0;
    public PropertyEdge(String name,DataVector dv1, DataVector dv2){
        this.name = name;
        this.dv1 = dv1;
        this.dv2 = dv2;
        innerProduct = KMeanClusterer.similarity(dv1, dv2);
    }

    public double getInnerProduct() {
        return innerProduct;
    }

    public void setInnerProduct(double innerProduct) {
        this.innerProduct = innerProduct;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
    @Override
    public String toString() {
        return "Inner Product: " + innerProduct;
    }
}

class MetaEdge<E> extends Object {
    String name = "";
    Set<E> edgeSetBundled = new HashSet<E>();
    int numEdgeSetBundled = 0;

    //Intentionally not clone or copy. Just refer to the edgeSet
    public MetaEdge(String s, Set<E> edgeSet) {
        name = s;
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }
    public MetaEdge(String s, E edge) {
        name = s;
        this.addEdge(edge);
    }
    public MetaEdge(String s) {
        name = s;
        
    }

    public void setName(String s) {
        name = s;
    }

    public void setEdgeSetBundled(Set<E> edgeSet) {
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }

    public void addEdge(E edge){
        edgeSetBundled.add(edge);
        numEdgeSetBundled += 1;
    }
    public String getName() {
        return name;
    }

    public Set<E> getEdgeSetBundled() {
        return edgeSetBundled;
    }

    public int getNumEdgeSetBundled() {
        return numEdgeSetBundled;
    }

    @Override
    public String toString() {
        return "Num edge: " + numEdgeSetBundled + " " + edgeSetBundled;
    }
}

