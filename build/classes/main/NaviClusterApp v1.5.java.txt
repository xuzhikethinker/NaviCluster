/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package main;

/**
 *
 * @author Knacky
 */
import edu.uci.ics.jung.algorithms.layout.AggregateLayout;
import edu.uci.ics.jung.algorithms.layout.CircleLayout;
import edu.uci.ics.jung.algorithms.layout.GraphElementAccessor;
import edu.uci.ics.jung.algorithms.layout.Layout;

import edu.uci.ics.jung.algorithms.layout.StaticLayout;


import edu.uci.ics.jung.graph.Graph;


import edu.uci.ics.jung.graph.SparseMultigraph;

import edu.uci.ics.jung.graph.util.Context;
import edu.uci.ics.jung.graph.util.Pair;

import edu.uci.ics.jung.visualization.GraphZoomScrollPane;

import edu.uci.ics.jung.visualization.Layer;
import edu.uci.ics.jung.visualization.RenderContext;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.AbstractGraphMousePlugin;
import edu.uci.ics.jung.visualization.control.AbstractPopupGraphMousePlugin;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;

import edu.uci.ics.jung.visualization.control.ModalGraphMouse.Mode;
import edu.uci.ics.jung.visualization.decorators.AbstractVertexShapeTransformer;
import edu.uci.ics.jung.visualization.decorators.EdgeWeightLabeller;
import edu.uci.ics.jung.visualization.decorators.PickableEdgePaintTransformer;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.renderers.Renderer;
import fromjungsource.MetaPropLengthFunction;
import fromjungsource.NodeShapeFRLayout;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileFilter;
import kmean.DataCluster;
import kmean.DataVector;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.collections15.Transformer;
import org.apache.commons.collections15.functors.ConstantTransformer;
import org.apache.commons.collections15.functors.MapTransformer;
import org.apache.commons.collections15.map.LazyMap;

import util.StopWatch;
import org.geneontology.oboedit.datamodel.OBOSession;

/**
 *
 * @author Thanet Praneenararat (Knack)
 * Department of Computational Biology, Graduate School of Frontier Sciences, University of Tokyo
 */
public class NaviClusterApp extends JFrame {

    private boolean UIWanted;
//    private String stringStream = "";
    private boolean isWeightGraph = false;
    private int[] sArr = null;
    private int[] dArr = null;
    private double[] wArr = null;
    public Color mainColor = new Color(255, 204, 22);
    public Color peripheralColor = new Color(0xF6FEAC);
    public Color bioObjColor = new Color(145, 214, 134);
//    public Color searchedColor = new Color(135,137,211);
//    public Color searchedColor = new Color(0xECA3AE);
    public Color searchedColor = new Color(0xFFCCFF);
    public Color prevProcessedColor = new Color(0xC7FFEF);
//    public Color mainColor = new Color(138,240,87);
//    public Color mainColor = new Color(153,255,102);
    VisualizationViewer<Object, Object> vv;
    Map<Object, Paint> vertexPaints = LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(mainColor));
    Map<Object, Paint> edgePaints = LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.BLACK));
    Map<Integer, BioObject> nodeMap = new HashMap<Integer, BioObject>();

    /* TO-DO I might allow users to adjust threshold for louvain clustering in the future */
//    private double threshold;
    private EdgeDisplayPredicate medp;
    private EdgeWeightLabeller ew;
//    String filename = "src/datasets/allyeast.mnet";
//    String filename = "src/datasets/ito2001.mnet";
//    String filename = "src/datasets/expmore3.mnet";
//    String filename = "src/datasets/refmore3.mnet";
//    String filename = "src/datasets/curmore2.mnet";
    String filename = "src/datasets/bothint.mnet";
//    String filename = "src/datasets/atted-coexp.mnet";
//    String filename = "src/datasets/atted-coexp-3highest.mnet";
    File fileToOpen = null;
    Graph<Object, Object> realGraph, originalGraph;
    Graph dynamicGraph, currentLevelGraph;
    AggregateLayout<Object, Object> layout;
    private boolean firstLoad = true;
    JButton zoomInButton;
    JButton zoomOutButton;
    JScrollPane listScroller = new JScrollPane();
    DefaultListModel listModel = new DefaultListModel();
    JList searchResList = new JList();
    JTextField searchTextField = new JTextField(10);
    JTextField thresholdTextField = new JTextField("12", 4);
    JTextField numHops = new JTextField("2", 5);
    JSlider ccSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 0);
    JSlider bpSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider mfSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 0);
    JSlider goEdgeSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 9);
//    Set<Set<Object>>[] hierCSet = null;
//    Set<Set<Object>>[] comNodehierSet = null;
    Set<Set>[] hierCSet = null;
    Set<Set>[] comNodeHierSet = null;
    public Object highlightedNode = null;
    public BioObject searchedBioObj = null;
    public Color highlightedNodeFormerColor = null;
    private int currentLevel = 0;

    /* now cSetToComNodeCSet is not used anywhere, it is only inputed*/
    Map<Set<Set>, Set<Set>> cSetToComNodeCSet = new HashMap<Set<Set>, Set<Set>>();
    Map<Set, Set> flatClustToComNodeClust = new HashMap<Set, Set>();
    Map<Set, Set> comNodeClustToFlatClust = new HashMap<Set, Set>();
//    Map<Set, DataCluster> nodeToDataCluster = new HashMap<Set, DataCluster>();
    private GOProcessor curGOP = null;
    private GOProcessor curGOPCentered = null;
    private boolean inConcentrationMode = false;
    private ArrayList clickedNodes = null;
    private Set<Set> curCSetCentered = null;
    private Set<Set> curCSetCenteredBPC = null;
    private Set<Set> curComNodeCSetCenteredBPC = null;
    private Set<Set> curComNodeCSetCentered = null;
    private Set centerNodeSet = null;
    private Set<Set> curCSet = null;
    private Set<Set> curCSetBeforePropClust = null;
    private Set<Set> curComNodeCSet = null;
    private Set<Set> curComNodeCSetBeforePropClust = null;
    private Map<Object, Point2D> curVertexLocMap = null;
    private Map<Object, Point2D> curUsualVertexLocMap = null;
//    private ArrayList historyCSetList = new ArrayList<Set<Set<Object>>>();
//    private ArrayList historyComNodeCSetList = new ArrayList<Set<Set<Object>>>();
//    private ArrayList<GOProcessor> historyGOProcessors = new ArrayList<GOProcessor>();
    private ArrayList<ViewHistory> viewHistoryList = new ArrayList<ViewHistory>();
    OBOSession obosession = null;
    /* numOfLouvainClusters is not used for specific purposes yet */
    public int numOfLouvainClusters = 0;
    DataVector centroid = new DataVector();
    DataCluster[] semanticClusterList = new DataCluster[1];
    Map<Object, DataVector> nodesGOVectorMap = new HashMap<Object, DataVector>();
    Map<BioObject, Object> nodeToClusterMap;
    Map<BioObject, Object> usualNodeToClusterMap;
    boolean splited = false;
    private boolean overallLessThanThresh = false;
    int maxMetaEdgeWeight = 0;
    PrintWriter pw = null;

    public static void main(String[] args) {

        final NaviClusterApp test = new NaviClusterApp();

        test.setTitle("NaviCluster v1.5");
        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        test.addWindowListener(new WindowAdapter() {

            public void windowClosing(WindowEvent we) {
                test.pw.close();
            }
        });
        test.start();
        test.pack();
//        test.setLocationByPlatform(true);
        test.setVisible(true);


    }

    public void start() {

        UIWanted = true;

        try {
            pw = new PrintWriter(new File("output-log"));
//            JFileChooser fileChooser = new JFileChooser(new File(filename + ".txt"));
//            fileChooser.setAcceptAllFileFilterUsed(false);
//            fileChooser.addChoosableFileFilter(new TextFileFilter());

//            System.out.println(new File(filename+".txt").getPath());
//            fileChooser.showOpenDialog(NaviClusterApp.this);
//            fileToOpen = fileChooser.getSelectedFile();
            fileToOpen = new File(filename);
            System.out.println(fileToOpen.getAbsolutePath());
            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));

            realGraph = new SparseMultigraph<Object, Object>();
            StopWatch loadingTime = new StopWatch();
            loadingTime.start();

            realGraph = loadModNet(br);
            originalGraph = realGraph;
            dynamicGraph = realGraph;

            loadingTime.stop();
            pw.println("Time used for loading from input file: " + loadingTime);
            System.out.println("Time used for loading from input file: " + loadingTime);

            /* This is top level. */
            ArrayList retList = louvainCluster(realGraph, realGraph.getVertexCount(), true);
            preparePropertyInfoProcessor();
            numOfLouvainClusters = ((Set) retList.get(0)).size();
            Set<Set> cSet = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, true, true, true);
            /* if do on all nodes in canvas, visualize the result also, or else just do clustering */
            loadingTime.start();
            dynamicGraph = createGraph(cSet);
            usualNodeToClusterMap = new HashMap(nodeToClusterMap);
            loadingTime.stop();
            pw.println("Time used for creating graph from cSet: " + loadingTime);
            System.out.println("Time used for creating graph from cSet: " + loadingTime);
            colorCluster(cSet, mainColor);
            currentLevelGraph = dynamicGraph;

//            loadingTime.start();
            initVV();
//            loadingTime.stop();
//            pw.println("Time used for init VV: " + loadingTime);
//            System.out.println("Time used for init VV: " + loadingTime);
            initComponents();

        } catch (IOException e) {
            // TODO Auto-generated catch block
            pw.println("Error in loading graph");
            System.out.println("Error in loading graph");
            e.printStackTrace();
        }
    }

    /**
     * Load input file in modified .net pajek format
     * @param br
     * @return
     * @throws java.io.IOException
     */
    public Graph<Object, Object> loadModNet(BufferedReader br) throws IOException {

        String st;
        StringTokenizer stn;
        int src, dest;
        double weight = 1, numNode = -1;

        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        BioObject bioObj = null;

        int id = -1;
        String stdName = "", name = "", databaseid = "", type = "";
        String goId = "", ref = "", aspect = "";
        StopWatch sw = new StopWatch();

        //check header of vertices zone
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Vertices")) {
                    numNode = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph: file format is not relevant");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }


        sw.start();
        for (int i = 0; i < numNode; i++) {
            st = br.readLine();
//            System.out.println(st);
            stn = new StringTokenizer(st, "\t", true);
            assert (stn.hasMoreTokens());
            id = Integer.parseInt(stn.nextToken());
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            stdName = stn.nextToken();
            if (stdName.equals("\t")) {
                stdName = "";
            } else {
                stn.nextToken();
            }

            assert (stn.hasMoreTokens());
            name = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            databaseid = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            if (databaseid.equals("\t")) {
                bioObj = new BioObject(id, name);
                bioObj.setStandardName(stdName);
            } else {
//                assert (stn.hasMoreTokens());
//                databaseid = stn.nextToken();
//                if (stn.nextToken().equals("\t"));
                assert (stn.hasMoreTokens());
                type = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                goId = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                ref = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                aspect = stn.nextToken();
//            if (stn.nextToken().equals("\t"));

                bioObj = new BioObject(id, databaseid, name);
                bioObj.setStandardName(stdName);
                bioObj.setType(type);

                StringTokenizer stz = new StringTokenizer(goId, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getGoIdList().add(stz.nextToken());
                }

                stz = new StringTokenizer(ref, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getRefList().add(stz.nextToken());
                }

                stz = new StringTokenizer(aspect, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getAspectList().add(stz.nextToken());
                }
            }
            newgraph.addVertex(bioObj);
            nodeMap.put(id, bioObj);
        }
        sw.stop();
        pw.println("load vertices time: " + sw);
        System.out.println("load vertices time: " + sw);
        sw.start();

        int numEdge = -1;

        //check header of edges zone
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Edges")) {
                    numEdge = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        /* the previous version made use of StringBuilder which is faster than normal string
         * but slower than current version
         * The current version makes use of three arrays, sArr, dArr, WArr
         */
//        StringBuilder stb = new StringBuilder(10000);

        sArr = new int[numEdge];
        dArr = new int[numEdge];
        wArr = new double[numEdge];
        boolean isWeight = false;

        ew = new EdgeWeightLabeller<Number>();
        for (int i = 0; i < numEdge; i++) {

            st = br.readLine();
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
//            stb.append(src).append("\t").append(dest).append("\t");
            sArr[i] = src;
            dArr[i] = dest;

//            Number vSrc = null,vDest = null;
//            newgraph.addVertex(src);
//            newgraph.addVertex(dest);
//            System.out.println("src: "+src+" dest: "+dest);
            String e1 = src + ":" + dest;
            if (stn.hasMoreTokens()) {
//                weight = Integer.parseInt(stn.nextToken());
                weight = Double.parseDouble(stn.nextToken());
//                stringStream += weight;
//                stb.append(weight);
                wArr[i] = weight;
                ew.setWeight(e1, (int) weight);
                isWeight = true;
            }
//            stringStream += "\n";
//            stb.append("\n");
//            System.out.println("e1 "+e1);
            newgraph.addEdge(e1, nodeMap.get(src), nodeMap.get(dest));
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));

        }
        sw.stop();
//        stringStream = stb.toString();
        if (!isWeight) {
            wArr = null;
        }
        isWeightGraph = isWeight;
        pw.println("Load edges time: " + sw);
        pw.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
        pw.println("Num nodes double checked: " + numNode + " Num edges double checked: " + numEdge);
        System.out.println("Load edges time: " + sw);
        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
        System.out.println("Num nodes double checked: " + numNode + " Num edges double checked: " + numEdge);
//        System.out.println(newgraph.getEdges());
        return newgraph;
    }

    /* Business logic zones (Core methods) */
    /**
     * Perform Louvain-clustering by taking g as an input
     * It is used at first after loading input file
     * It calls louvainClusterer method of MainLouvain class
     * If we would like to re-run louvain-clustering after loading, we have to use reLouvainCluster method
     * @param g
     * @param clustering
     */
    public ArrayList louvainCluster(Graph g, int numNode, boolean isTopLevel) {
        ArrayList retList = null;
        try {
            StopWatch stopwatch = new StopWatch();
            stopwatch.start();
            MainLouvain ml = new MainLouvain();
            int[][] hierarchyComNode = null;

            if (sArr != null) {
                hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
            } else {
                hierarchyComNode = new int[2][];
                for (int i = 0; i < hierarchyComNode.length; i++) {
                    hierarchyComNode[i] = new int[numNode];
                    for (int j = 0; j < hierarchyComNode[i].length; j++) {
                        hierarchyComNode[i][j] = j;
                    }
                }
            }

            pw.println("After Louvain Clustering");
            System.out.println("After Louvain Clustering");

            retList = processLouvainClusterSet(g, hierarchyComNode, isTopLevel);
            pw.println("After processing LC and running property-based clustering");
            System.out.println("After processing LC and running property-based clustering");
            stopwatch.stop();

            /* we can stop program in hard-code manner by setting UIWanted to false */
            if (!UIWanted) {
                System.exit(0);
            }


        } catch (FileNotFoundException ex) {
            pw.println("File not found! " + ex.getMessage());
            System.out.println("File not found! " + ex.getMessage());
            Logger.getLogger(NaviClusterApp.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            pw.println("IOException! " + ex.getMessage());
            System.out.println("IOException! " + ex.getMessage());
            Logger.getLogger(NaviClusterApp.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            return retList;
        }
    }

    /** Initialize many things that will be used in property-based clustering
     * Currently, it loads GO terms map, namespace weight map
     */
    public void preparePropertyInfoProcessor() throws FileNotFoundException, IOException {
        /* load GO terms map from text file */
//        GOProcessor.loadGOTermsMap();
        GOProcessor.loadOntologyFile();
        /* initialize map for GO namespac */
        Map<NameSpace, Double> map = new HashMap<NameSpace, Double>();
        map.put(NameSpace.BP, (double) bpSlider.getValue());
        map.put(NameSpace.MF, (double) mfSlider.getValue());
        map.put(NameSpace.CC, (double) ccSlider.getValue());
        GOProcessor.setWeightMap(map);
    }

    /**
     * Process raw cluster set information from louvain clustering by correspondingly putting
     * BioObjects into sets.
     * isTopLevel boolean is used to specify if we want to input information of overall structure
     * into hierCSet and comNodehierSet.
     * Then, perform property-based clustering if appropriate.
     * Also, it visualizes the result as a graph of metanodes and metaedges
     * @param g
     * @param hierarchyComNode
     * @param isTopLevel
     * @param doOnAllNodesInCanVas
     * @return
     * @throws java.io.IOException
     */
    private ArrayList processLouvainClusterSet(Graph g, int[][] hierarchyComNode, boolean isTopLevel) throws IOException {
        ArrayList retList = putLouvainResultToSet(hierarchyComNode, isTopLevel);

//        if (isTopLevel) {
//            printStatAboutClusters(g,(Set)retList.get(0));
//        }


        return retList;

    }

    /**
     * Put raw louvain clustering results into the set of set of BioObjects
     * really used in the graph.
     * @param hierarchyComNode
     * @param isTopLevel
     * @return
     */
    private ArrayList putLouvainResultToSet(int[][] hierarchyComNode, boolean isTopLevel) {
        ArrayList<Integer> labelList = new ArrayList();
        ArrayList<Set<Object>> csList = new ArrayList();
        ArrayList<Set<Object>> newCsList = new ArrayList();
        ArrayList<Set<Object>> arrComNode = new ArrayList();
        ArrayList<Set<Object>> newArrComNode = new ArrayList();
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();

        if (isTopLevel) {
            hierCSet = new HashSet[hierarchyComNode.length];
            comNodeHierSet = new HashSet[hierarchyComNode.length];
        }

        pw.println("Start process raw cluster set!");
        System.out.println("Start process raw cluster set!");

        // hierarchyComNode should have length >= 2
        // process level 0-1 of hierarchy array
        for (int j = 0; j < hierarchyComNode[1].length; j++) {
            csList.add(new HashSet<Object>());
            arrComNode.add(new HashSet());
        }
        for (int j = 0; j < hierarchyComNode[0].length; j++) {
            if (!labelList.contains(hierarchyComNode[0][j])) {
                labelList.add(hierarchyComNode[0][j]);
            }
            int index = labelList.indexOf(hierarchyComNode[0][j]);
            Set<Object> cluster = csList.get(index);
            Set clusterOfComNode = arrComNode.get(index);
            cluster.add(nodeMap.get(j));
            clusterOfComNode.add(nodeMap.get(j));
        }

        comNodeCSet = new HashSet<Set>();
        for (int l = 0; l < csList.size(); l++) {
            /* only at this level we can use cluster instead of clusterOfComNode */
            Set<Object> cluster = csList.get(l);
            cSet.add(cluster);
            comNodeCSet.add(cluster);

            flatClustToComNodeClust.put(cluster, cluster);
            comNodeClustToFlatClust.put(cluster, cluster);
//            System.out.println(cluster);
        }

        cSetToComNodeCSet.put(cSet, comNodeCSet);
        flatClustToComNodeClust.put(cSet, comNodeCSet);

        if (isTopLevel) {
            hierCSet[0] = cSet;
            comNodeHierSet[0] = comNodeCSet;
//            System.out.println("\ncomNodehierSet "+0+": "+comNodehierSet[0]+"\n");
//            System.out.println("\nhierCSet "+0+": "+hierCSet[0]+"\n");
        }

        // process level i and i+1
        for (int i = 1; i < hierarchyComNode.length - 1; i++) {
            labelList.clear();
            newCsList.clear();
            newArrComNode.clear();
//            System.out.println("size "+(i)+" "+hierarchyComNode[i].length);
//            System.out.println("size "+(i+1)+" "+hierarchyComNode[i+1].length);
            for (int j = 0; j < hierarchyComNode[i + 1].length; j++) {
                newCsList.add(new HashSet<Object>());
                newArrComNode.add(new HashSet());
            }
//            System.out.println("size of csList "+csList.size());
//            System.out.println("size of new csList "+newCsList.size());
            for (int j = 0; j < hierarchyComNode[i].length; j++) {
                if (!labelList.contains(hierarchyComNode[i][j])) {
                    labelList.add(hierarchyComNode[i][j]);
                }

                int index = labelList.indexOf(hierarchyComNode[i][j]);
                Set<Object> cluster = newCsList.get(index);
                Set clusterOfComNode = newArrComNode.get(index);

                cluster.addAll(csList.get(j));
                clusterOfComNode.add(arrComNode.get(j));
            }

            //clone newCsList to csList safely
            csList.clear();
            for (Set<Object> av : newCsList) {
                Set<Object> list = new HashSet<Object>();
                csList.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }

            //clone newArrComNode to arrComNode safely
            arrComNode.clear();
            for (Set<Object> av : newArrComNode) {
                Set<Object> list = new HashSet<Object>();
                arrComNode.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }

            cSet = new HashSet<Set>();
            comNodeCSet = new HashSet<Set>();

            for (int l = 0; l < csList.size(); l++) {

                Set<Object> cluster = csList.get(l);
                Set clusterOfComNode = arrComNode.get(l);

                cSet.add(cluster);
                comNodeCSet.add(clusterOfComNode);

                flatClustToComNodeClust.put(cluster, clusterOfComNode);
                comNodeClustToFlatClust.put(clusterOfComNode, cluster);

//                System.out.println("ClusterOfComNode: "+clusterOfComNode);
//                System.out.println(cluster);
            }

            cSetToComNodeCSet.put(cSet, comNodeCSet);
            flatClustToComNodeClust.put(cSet, comNodeCSet);

            if (isTopLevel) {
                hierCSet[i] = cSet;
                comNodeHierSet[i] = comNodeCSet;

//                System.out.println("\ncomNodehierSet " + i + ": " + comNodeHierSet[i] + "\n");
//                System.out.println("\nhierCSet " + i + ": " + hierCSet[i] + "\n");
            }

        }
        ArrayList retList = new ArrayList();
        retList.add(cSet);
        retList.add(comNodeCSet);
        return retList;
    }

    /**
     * Print statistics about louvain clusters
     * @param g
     * @param cSet
     */
    private void printStatAboutClusters(Graph g, Set<Set> cSet) {

        int numSingle = 0;
        int numClustSizeMore1 = 0;
        double avgClustSize = 0;
        int biggestClustSize = -1;
        int sumClustSize = 0;

        /* calculate some stats */

        for (Set<Object> set : cSet) {
            int size = set.size();
            if (size == 1) {
                numSingle++;
            } else {
                numClustSizeMore1++;
            }
            if (size > biggestClustSize) {
                biggestClustSize = size;
            }
            sumClustSize += size;
        }

        avgClustSize = (double) sumClustSize / cSet.size();
        double percSingle = (double) numSingle / g.getVertexCount();
        double percBiggest = (double) biggestClustSize / g.getVertexCount();

        pw.println("\n======================");
        pw.println("Statistics of louvain clusters");
        pw.println("======================");
        pw.println("Single node num: " + numSingle + " percent: " + percSingle);
        pw.println("No. cluster size > 1: " + numClustSizeMore1);
        pw.println("Avg. cluster size: " + avgClustSize);
        pw.println("Biggest cluster size: " + biggestClustSize + " percent: " + (percBiggest * 100));
        pw.println("======================\n");
        System.out.println("\n======================");
        System.out.println("Statistics of louvain clusters");
        System.out.println("======================");
        System.out.println("Single node num: " + numSingle + " percent: " + percSingle);
        System.out.println("No. cluster size > 1: " + numClustSizeMore1);
        System.out.println("Avg. cluster size: " + avgClustSize);
        System.out.println("Biggest cluster size: " + biggestClustSize + " percent: " + (percBiggest * 100));
        System.out.println("======================\n");
    }

    /**
     * Do property-based clustering by using the result from cSet and comNodeCSet
     * @param cSet
     * @param comNodeCSet
     * @param isTopLevel
     * @param doOnAllNodesInCanVas
     * @return
     */
    public Set<Set> propertyBasedCluster(Set<Set> cSet, Set<Set> comNodeCSet, GOProcessor gop, boolean isTopLevel, boolean doOnAllNodesInCanVas, boolean populateGOTerm) {

        if (doOnAllNodesInCanVas) {
            curCSetBeforePropClust = cSet;
            curComNodeCSetBeforePropClust = comNodeCSet;
        } else {
            /* for now we assume that if this method does not run on all nodes, it runs on peripheral nodes
             * of the node currently being concentrated and curCSetCentered et al. are used instead.
             */
            curCSetCentered = curCSetCenteredBPC = cSet;
            curComNodeCSetCentered = curComNodeCSetCenteredBPC = comNodeCSet;
        }

//        Set tmpSet = splitClusters(cSet);
//        if (tmpSet != null)
//            cSet = tmpSet;

        GOProcessor gp = null;
        /* if we provides GOProcessor, use it */
        if (gop != null) {
            gp = gop;
            if (populateGOTerm) {
                gp.populateGOTerms(cSet);
            }
        } else {
            gp = new GOProcessor();
//        StopWatch sw = new StopWatch();
//        sw.start();
            gp.populateGOTerms(cSet);
//        sw.stop();
//        System.out.println("Populate GO Terms Time Used "+sw);
        }

//        int thresh = 12;
        if ((cSet.size() == 1) && (cSet.iterator().next().size() >= Integer.parseInt(thresholdTextField.getText()))) {
            /* In this case, cSet is composed of only BioObjects, so destroy it to get them */
            pw.println("\ncSet size = 1, destroy cSet to get raw BioObjs\n");
            pw.println("Start special property-based clustering!");
            System.out.println("\ncSet size = 1, destroy cSet to get raw BioObjs\n");
            System.out.println("Start special property-based clustering!");
            Set newset = new HashSet();
            newset.addAll(cSet.iterator().next());
            pw.println("New cSet which comprises BioObjects: " + newset);
            System.out.println("New cSet which comprises BioObjects: " + newset);

            gp.populateGOTerms(newset);
            semanticClusterList = gp.preCluster(newset, Integer.parseInt(thresholdTextField.getText()));
            cSet = transformDataClusterList(semanticClusterList, isTopLevel, doOnAllNodesInCanVas);

//            System.out.println("cSet after transform "+cSet);
            /*tentative*/
            if (doOnAllNodesInCanVas) {
                curCSetBeforePropClust = newset;
            } else {
                curCSetCenteredBPC = newset;
            }
            pw.println("End special property-based clustering!");
            System.out.println("End special property-based clustering!");

        } else if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
            pw.println("Start property-based clustering!");
            System.out.println("Start property-based clustering!");
            semanticClusterList = gp.preCluster(comNodeClustToFlatClust, comNodeCSet, cSet, Integer.parseInt(thresholdTextField.getText()));
            cSet = transformDataClusterList(semanticClusterList, isTopLevel, doOnAllNodesInCanVas);
            pw.println("End property-based clustering!");
            System.out.println("End property-based clustering!");

        } else {
            /* Do not run property-based clustering
             * split clusters to fill the canvas
             *
             */
            pw.println("Do not run property-based clustering!!");
            System.out.println("Do not run property-based clustering!!");

            Set tmpSet = new HashSet();
            int counter = 0;
            do {
                pw.println("\n===================");
                pw.println("split cluster round " + counter);
                pw.println("===================\n");
                System.out.println("\n===================");
                System.out.println("split cluster round " + counter);
                System.out.println("===================\n");
                splited = false;
                overallLessThanThresh = false;

                tmpSet = splitClusters(cSet);
                if (splited) {
                    cSet = tmpSet;
                    pw.println("clusters splited!");
                    pw.println("cSet: " + cSet);
                    System.out.println("clusters splited!");
                    System.out.println("cSet: " + cSet);
                } else {
                    break;
                }
                if (overallLessThanThresh) {
                    break;
                }
//                if (tmpSet != null) {
//                    if (tmpSet == cSet)
//                        break;
//                    else{
//                        cSet = tmpSet;
//                        System.out.println("clusters splited!");
//                    }
//                }
                counter++;
                if (counter == 10) {
                    break;
                }
            } while (true);

            gp.populateGOTerms(cSet);
            nodesGOVectorMap.putAll(putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet)));

        }

        if (doOnAllNodesInCanVas) {
            curGOP = gp;
            pw.println("GO Processor clusterScoreMap size: " + curGOP.clusterScoreMap.size());
            System.out.println("GO Processor clusterScoreMap size: " + curGOP.clusterScoreMap.size());
        } else {
            /* if do not run on all nodes, assume that it runs on peripheral nodes */
            curGOPCentered = gp;
        }

        return cSet;
    }

    /**
     * splitClusters aims for splitting members of cSet as much as possible in order to
     * fill the canvas.
     * It works in greedy-based fashion, trying to split a member if the split does not produce
     * number of new members which exceeds the threshold.
     * If it cannot split the member, it will continue to the next members.
     *
     * The threshold used to split is that specified in the UI (default = 12)
     * ex.
     * If cSet comprises 3 members, which in turn contain 5,4, and 4 members respectively.
     * After splitClusters, cSet will contain 5 + 4 + 1 = 10 members.
     * The first 5 members are from the first previous member which contains 5 members.
     * The second 4 members are from the second previous member which contains 4 members.
     * The final 1 member is the same final previous member which contains 4 members.
     * This last member cannot be split because the threshold is 12.
     * If it is to split, the overall number will be = 5+4+4= 13 members, exceeding the threshold.
     *
     * Usually, splitCluster is called iteratively to fill the canvas
     * ex.
     * If there are 2 members in cSet, each of which contains 4 members.
     * After splitClusters, there will be 4+4 = 8 members on the canvas.
     * Assume the first member of these 8 members contains 3 members, and the second contains 2 members.
     * In this case, they can be splitted, and the overall number of nodes/clusters on the canvas
     * will be 3+2+3+4 = 12 members.
     *
     * @param cSet
     * @return
     */
    public Set splitClusters(Set<Set> cSet) {
        int numOfAllMembers = 0;
//        if ((cSet != null)) && (cSet.iterator().next() instanceof BioObject)) {
//            return cSet;
//        }
//        Set<Set> comNodeCSet = flatClustToComNodeClust.get(cSet);
//        Set<Set> comNodeCSet = cSetToComNodeCSet.get(cSet);
//        if (comNodeCSet == null)
//            comNodeCSet = flatClustToComNodeClust.get(cSet);
        if (cSet.size() == 0) {
            return null;
        }
        pw.println("split clusters: cSet size " + cSet.size());
        pw.println("split clusters: cSet " + cSet);
        System.out.println("split clusters: cSet size " + cSet.size());
        System.out.println("split clusters: cSet " + cSet);
        Set newCSet = new HashSet();
//        Set arrOfSet[] = comNodeCSet.toArray(new Set[1]);
//        Set arrOfCSet[] = cSet.toArray(new Set[1]);
        Object arrOfCSet[] = cSet.toArray(new Object[1]);
        Set flatset = new HashSet();

        Integer arrOfSize[] = new Integer[arrOfCSet.length];
        ArrayList<Set> listOfSet = new ArrayList<Set>();
        ArrayList<Integer> listSize = new ArrayList<Integer>();

        Map setToSetMap = new HashMap();
        Set bioObjSet = new HashSet();
//        int i = 0;
        for (int i = 0; i < arrOfCSet.length; i++) {
            Set set = null;
            BioObject bioObj = null;
            if (arrOfCSet[i] instanceof Set) {
                set = (Set) arrOfCSet[i];
                pw.println("i: " + i + " set " + set);
                System.out.println("i: " + i + " set " + set);
                numOfAllMembers += set.size();
                flatset.addAll(set);
                Set tmpSet = flatClustToComNodeClust.get(set);
                pw.println("tmp set size " + tmpSet.size());
                pw.println("tmp set " + tmpSet);
                System.out.println("tmp set size " + tmpSet.size());
                System.out.println("tmp set " + tmpSet);
                while ((tmpSet.size() == 1) && (tmpSet.iterator().next() instanceof Set)) {

                    tmpSet = (Set) tmpSet.iterator().next();
//                if ((tmpSet.iterator().next() instanceof BioObject)) {
//                    countBioObjSet++;
//                    break;
//                }
//                set = tmpSet;
                    System.out.println("curComNodeCSet: " + tmpSet);
                }
                pw.println("tmp set size after process " + tmpSet.size());
                System.out.println("tmp set size after process " + tmpSet.size());
//            arrOfSize[i] = flatClustToComNodeClust.get(set).size();
//            arrOfSize[i] = tmpSet.size();
                arrOfSize[i] = set.size();
                listOfSet.add(tmpSet);
//            setToSetMap.put(tmpSet, set);
                setToSetMap.put(set, tmpSet);
            } else if (arrOfCSet[i] instanceof BioObject) {
                bioObj = (BioObject) arrOfCSet[i];
                bioObjSet.add(bioObj);
                pw.println("i: " + i + " BioObj " + bioObj);
                System.out.println("i: " + i + " BioObj " + bioObj);
                numOfAllMembers++;
                flatset.add(bioObj);
                arrOfSize[i] = 1;
//            setToSetMap.put(tmpSet, set);
//                setToSetMap.put(set, tmpSet);
            }

//            arrOfSize[i] = set.size();



//            int localCount = 0;
//            for (Object setOfSet : tmpSet){
//                listSize.add(flatClustToComNodeClust.get(setOfSet).size());
//                listOfSet.add(flatClustToComNodeClust.get(setOfSet));
//                localCount++;
//            }

//            arrOfSize[i] = listSize.get(listSize.size()-1);
//            numOfAllMembers += set.size();
//            newComNodeCSet.addAll(flatClustToComNodeClust.get(set));
//            newComNodeCSet.addAll(flatClustToComNodeClust.get(tmpSet));


        }

//        arrOfSize = listSize.toArray(new Integer[1]);

//        System.out.println("Array of size: "+Arrays.toString(arrOfSize));



        int threshold = Integer.parseInt(thresholdTextField.getText());
        if (numOfAllMembers <= threshold) {
            splited = true;
            overallLessThanThresh = true;
            pw.println("Overall Num less than threshold: flatset = " + flatset);
            System.out.println("Overall Num less than threshold: flatset = " + flatset);
            return flatset;
        }
        pw.println("In splitClusters: number of members of cSet " + cSet.size());
        System.out.println("In splitClusters: number of members of cSet " + cSet.size());
//        System.out.println("In splitClusters: number of members of listOfSet "+listSize.size());
        /* currently, splitClusters is used only when cSet.size() < threshold */
//        if (cSet.size() >= threshold){
//            return null;
//        } else {
        //no. of LCs is fewer than 12 (by default), so do the split.
        Arrays.sort(arrOfSize, new Comparator<Integer>() {

            public int compare(Integer o1, Integer o2) {
                if (o1 < o2) {
                    return 1;
                } else if (o1 == o2) {
                    return 0;
                } else {
                    return -1;
                }
            }
        });
        pw.println("array of size " + Arrays.toString(arrOfSize));
        System.out.println("array of size " + Arrays.toString(arrOfSize));
        Set sortedSet = new TreeSet(new Comparator<Entry<Set, Set>>() {

            public int compare(Entry<Set, Set> o1, Entry<Set, Set> o2) {
                if (o1.getKey().size() <= o2.getKey().size()) {
                    return 1;
//                } else if (o1.getKey().size() == o2.getKey().size()) {
//                    return 0;
                } else {
                    return -1;
                }
//                return 0;
            }
        });


//        Map<Set,Set> tm = new TreeMap( new Comparator<Entry<Set,Set>>(){
//
////            public int compare(Set o1, Set o2) {
////                if (o1.size() <= o2.size()) {
////                    return 1;
//////                } else if (o1.size() == o2.size()) {
//////                    return 0;
////                } else if (o1.size() > o2.size()) {
////                    return -1;
////                }
////                return 0;
////            }
//
//            public int compare(Entry<Set, Set> o1, Entry<Set, Set> o2) {
//                if (o1.getKey().size() < o2.getKey().size()) {
//                     return 1;
//                } else if (o1.getKey().size() == o2.getKey().size()) {
//                    return 0;
//                } else if (o1.getKey().size() > o2.getKey().size()) {
//                    return -1;
//                }
//                return 0;
//            }
//        });
//        tm.putAll(setToSetMap);
        sortedSet.addAll(setToSetMap.entrySet());

//        System.out.println("tm key set size "+tm.size());
        pw.println("setToSetMap size " + setToSetMap.keySet().size());
        pw.println("sorted set size " + sortedSet.size());
        System.out.println("setToSetMap size " + setToSetMap.keySet().size());
        System.out.println("sorted set size " + sortedSet.size());

        for (Object obj : sortedSet) {
            Entry entry = (Entry) obj;
            pw.println("key " + entry.getKey() + " object " + entry.getValue());
            System.out.println("key " + entry.getKey() + " object " + entry.getValue());
        }
//            newComNodeCSet = new HashSet();
        int currentMemSize = cSet.size();
        if (bioObjSet.size() != 0) {
            newCSet.addAll(bioObjSet);
        }

        int j = 0;
//        for (Set extendedSet : tm.keySet()) {
//
//            System.out.println("j "+j);
//            System.out.println("arrOfSize j " + extendedSet.size());
//            System.out.println("currentMemSize " + currentMemSize);
//            if (currentMemSize - 1 + extendedSet.size() <= threshold) {
//                newCSet.addAll(extendedSet);
//                currentMemSize = currentMemSize - 1 + extendedSet.size();
//
//            } else {
//                newCSet.add(tm.get(extendedSet));
//            }
//            j++;
//        }

        for (Object obj : sortedSet) {
            Entry<Set, Set> entry = (Entry) obj;
            pw.println("j " + j);
            System.out.println("j " + j);

            //getValue = comNodeClust
            //getKey = flatClust
            if (arrOfSize[j] <= 1) {
                continue;
            }
            if (currentMemSize - 1 + entry.getValue().size() <= threshold) {
                splited = true;
                for (Object obje : entry.getValue()) {
                    pw.println("obje " + obje);
                    System.out.println("obje " + obje);

                    if (obje instanceof BioObject) {
                        newCSet.add(obje);
                    } else {
                        pw.println("comnodeclust flatclust " + comNodeClustToFlatClust.get(obje));
                        System.out.println("comnodeclust flatclust " + comNodeClustToFlatClust.get(obje));
                        newCSet.add(comNodeClustToFlatClust.get(obje));
                    }

                }
//                newCSet.addAll(entry.getKey());
                currentMemSize = currentMemSize - 1 + entry.getValue().size();
                pw.println("arrOfSize j " + entry.getValue().size());
                pw.println("currentMemSize " + currentMemSize);
                System.out.println("arrOfSize j " + entry.getValue().size());
                System.out.println("currentMemSize " + currentMemSize);

            } else {
                // Assume there is no mixed set of BioObject & set
                Set val = entry.getKey();
                if (val == null) {
                    pw.println("flat clust is null");
                    System.out.println("flat clust is null");
                }
                if ((val.iterator().next() instanceof BioObject)) {
                    pw.println("flat clust: set of bioobject");
                    System.out.println("flat clust: set of bioobject");
                    newCSet.add(val);
                    comNodeClustToFlatClust.put(val, val);
                    flatClustToComNodeClust.put(val, val);
                }
//                else {
//                    System.out.println("entry value: set of set");
//                    Set flatclust = comNodeClustToFlatClust.get(val);
//                    if (flatclust != null) {
//                        newCSet.add(flatclust);
//                    } else{
//                        flatclust = new HashSet();
//                        for (Object object : val){
//                            Set innerset = (Set)object;
//                            flatclust.addAll(innerset);
//                        }
//                    }
//                    comNodeClustToFlatClust.put(val,flatclust);
//                    flatClustToComNodeClust.put(flatclust,val);
//                    newCSet.add(flatclust);
//                }
            }
            j++;
        }

//        for (int j = 0; j < arrOfSize.length; j++) {
//            if (currentMemSize - 1 + arrOfSize[j] <= threshold) {
//                System.out.println("arrOfSize j " + arrOfSize[j]);
//                newCSet.addAll(listOfSet.get(j));
//                currentMemSize = currentMemSize - 1 + arrOfSize[j];
//                System.out.println("currentMemSize " + currentMemSize);
//            } else {
//                newCSet.add(arrOfCSet[j]);
//            }
//        }
//        }
        return newCSet;
    }

    /**
     * GO vector values are subtracted by the local centroid of all members.
     * to bring out the property of each member compared to all of them.
     * 
     * @return map of object to GO vector
     * @param localNodesGOVectorMap
     */
    public Map<Object, DataVector> putInNodesGOVectorMapRelatively(Map<Object, DataVector> localNodesGOVectorMap) {
        int allNumMember = 0;
        Map<Object, DataVector> newNodesGOVectorMap = new HashMap<Object, DataVector>();

        DataCluster dc = new DataCluster();
        dc.addAll(localNodesGOVectorMap.values());
        allNumMember = dc.getMembers().size();
//        for (DataVector dv: dc.getMembers()){
//            allNumMember += ((Set)dv.nodeRef).size();
//        }
//        System.out.println("putInNodesGOVectorMap all num member "+allNumMember);
        DataVector localCentroid = DataCluster.findCentroidFromDCList(new DataCluster[]{dc}, allNumMember);

        for (DataVector dv : dc.getMembers()) {
            DataVector resultVector = DataVector.minusVector(dv, localCentroid);
            newNodesGOVectorMap.put(dv.nodeRef, resultVector);
        }
        return newNodesGOVectorMap;
    }

    /**
     * Transform the result from data cluster list to metanodes really used in the graph.
     * @param dcList
     * @param topLevel
     * @param doOnAllNodesInCanvas
     * @return cSet containing new metanodes
     */
    public Set<Set> transformDataClusterList(DataCluster[] dcList, boolean topLevel, boolean doOnAllNodesInCanvas) {
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();
        Set cluster;
        Set clusterComNode;

        pw.println("Start transform data cluster to metanodes...");
        System.out.println("Start transform data cluster to metanodes...");

        int sumOfAllMembers = 0;
        for (DataCluster dc : dcList) {
            sumOfAllMembers += dc.getMembers().size();
        }

//        System.out.println("sum of all: "+sumOfAllMembers);
//        System.out.println("num of louvain "+numOfLouvainClusters);

        centroid = DataCluster.findCentroidFromDCList(dcList, sumOfAllMembers);

        for (int i = 0; i < dcList.length; i++) {
            DataCluster dc = dcList[i];

            if (dc.getMembers().size() == 0) {
                pw.println("BUG!!!!: Found cluster with zero members !!!!!!");
                System.out.println("BUG!!!!: Found cluster with zero members !!!!!!");
                continue;
            }

            DataVector[] dvList = dc.getMembers().toArray(new DataVector[1]);
            cluster = new HashSet();
            clusterComNode = new HashSet();

            for (DataVector dv : dvList) {
                //nodeRef points to a cluster (set of set) not a real metanode in the graph
                if (dv.nodeRef instanceof Set) {
                    cluster.addAll((Set) dv.nodeRef);
                } else {// nodeRef is BioObject
                    cluster.add(dv.nodeRef);
                }
                clusterComNode.add(dv.comNodeClusterRef);
            }

//            nodeToDataCluster.put(cluster, dc);
            flatClustToComNodeClust.put(cluster, clusterComNode);
            comNodeClustToFlatClust.put(clusterComNode, cluster);
            cSet.add(cluster);
            comNodeCSet.add(clusterComNode);

            DataVector resultVector = DataVector.minusVector(dc.getRepresentative(), centroid);
            nodesGOVectorMap.put(cluster, resultVector);

        }

        /* Input new information of hierCSet if this method is performed at the topLevel */
        if (topLevel) {
            //extend capacity and copy the contents for hierCSet and ComNodeHierSet
            Set<Set>[] tmpHierCSet = new HashSet[hierCSet.length + 1];
            for (int i = 0; i < hierCSet.length; i++) {
                tmpHierCSet[i] = hierCSet[i];
            }
            tmpHierCSet[hierCSet.length - 1] = cSet;
            hierCSet = tmpHierCSet;

            tmpHierCSet = new HashSet[comNodeHierSet.length + 1];
            for (int i = 0; i < comNodeHierSet.length; i++) {
                tmpHierCSet[i] = comNodeHierSet[i];
            }
            tmpHierCSet[comNodeHierSet.length - 1] = comNodeCSet;
            comNodeHierSet = tmpHierCSet;
//            System.out.println("\ncomNodehierSet " + (comNodeHierSet.length-2) + ": " + comNodeHierSet[comNodeHierSet.length-2] + "\n");
//            System.out.println("\nhierCSet " + (hierCSet.length-2) + ": " + hierCSet[hierCSet.length-2] + "\n");
        }

        /* do it on all nodes or else just do it on peripheral nodes of node being concentrated. */
        if (doOnAllNodesInCanvas) {
            curComNodeCSet = comNodeCSet;
            curCSet = cSet;
        } else {
            curComNodeCSetCentered = comNodeCSet;
            curCSetCentered = cSet;
        }

        cSetToComNodeCSet.put(cSet, comNodeCSet);
        flatClustToComNodeClust.put(cSet, comNodeCSet);

//        for (Set set : cSet){
//            System.out.println("cluster with size "+set.size());
//        }

        pw.println("End transform data cluster to metanodes...");
        System.out.println("End transform data cluster to metanodes...");

        return cSet;

    }

    /**
     * Create a graph from cSet
     * @param cSet
     * @return
     */
    public Graph createGraph(Set cSet) {
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        nodeToClusterMap = new HashMap<BioObject, Object>();
        Map<Pair, MetaEdge> newEdgeMap = new HashMap<Pair, MetaEdge>();
        Set newSet = new HashSet(cSet);
        StopWatch sw = new StopWatch();
        sw.start();
        for (Object obj : cSet) {
            if (obj instanceof Set) {
                Set set = (Set) obj;
                Object suspect = set.iterator().next();
                /* Destroy a set of one BioObject and get its content */
                if ((set.size() == 1) && (suspect instanceof BioObject)) {
//                    System.out.println("suspect detected "+suspect);
                    newgraph.addVertex(suspect);
                    newSet.add(suspect);
                    newSet.remove(obj);
                    nodesGOVectorMap.put(suspect, nodesGOVectorMap.get(obj));
                    nodesGOVectorMap.remove(obj);
                    continue;
                }
            }
            newgraph.addVertex(obj);
        }
        sw.stop();
        pw.println("Time to create vertices " + sw);
        System.out.println("Time to create vertices " + sw);

        /* calculate property edge between cluster */
        sw.start();
        Object[] cSetArr = newSet.toArray(new Object[1]);
//        int []numEdgeArr = new int[cSetArr.length*2];
//        Object[] metaedgeArr = new Object[numEdgeArr.length];
        ArrayList<Object> metaedgeArr = new ArrayList();
        ArrayList<Pair> pairArr = new ArrayList();
        int ind = 0;
        for (int i = 0; i < cSetArr.length; i++) {
            for (int j = i + 1; j < cSetArr.length; j++) {
                if (cSetArr[i] instanceof BioObject && cSetArr[j] instanceof BioObject) {
                    Object suspectedEdge = realGraph.findEdge(cSetArr[i], cSetArr[j]);
                    if (suspectedEdge != null) {
                        newgraph.addEdge(suspectedEdge, cSetArr[i], cSetArr[j]);
                    }
                } else {


                    Pair newPair = new Pair(cSetArr[i], cSetArr[j]);
                    Object metaedge = new MetaEdge(cSetArr[i] + ":" + cSetArr[j]);
                    metaedgeArr.add(metaedge);
                    pairArr.add(newPair);
                }
//                numEdgeArr[ind++] = 0;

//                Object edge = newgraph.findEdge(cSetArr[i], cSetArr[j]);

//                if (edge == null){
                Object edge = new PropertyEdge(cSetArr[i] + "<->" + cSetArr[j], nodesGOVectorMap.get(cSetArr[i]), nodesGOVectorMap.get(cSetArr[j]));
                newgraph.addEdge(edge, cSetArr[i], cSetArr[j]);
//                newgraph.addEdge(metaedge, cSetArr[i], cSetArr[j]);

//                }
//                else if (!(edge instanceof PropertyEdge))
//                    System.out.println("What 's edge!!!");

            }
            if (cSetArr[i] instanceof Set) {
                for (Object obj : (Set) cSetArr[i]) {
                    nodeToClusterMap.put((BioObject) obj, cSetArr[i]);
                }
            } else {
                nodeToClusterMap.put((BioObject) cSetArr[i], cSetArr[i]);
            }
        }
        sw.stop();
        pw.println("Time to create property edges " + sw);
        System.out.println("Time to create property edges " + sw);


        /* Create metaedges between clusters */
        sw.start();

//        StopWatch swlocal = new StopWatch();
//        swlocal.start();
        for (Object edge : originalGraph.getEdges()) {

            Pair pair = originalGraph.getEndpoints(edge);
            Object preClusterFirst = nodeToClusterMap.get(pair.getFirst());
            Object preClusterSecond = nodeToClusterMap.get(pair.getSecond());

            if (preClusterFirst == preClusterSecond ||
                    preClusterFirst == null || preClusterSecond == null) {
                continue;
            }
            if (preClusterFirst instanceof BioObject && preClusterSecond instanceof BioObject) {
                continue;
            }

            Pair newPair = new Pair(preClusterFirst, preClusterSecond);

            /* if no such metaedge, create an edge, or else just add new edge into existing metaedge */

            int index = pairArr.indexOf(newPair);
            if (index == -1) {
                newPair = new Pair(preClusterSecond, preClusterFirst);
                index = pairArr.indexOf(newPair);


            }

            ((MetaEdge) metaedgeArr.get(index)).addEdge(edge);

        }
        sw.stop();
        pw.println("Time to create metaedges " + sw);
        System.out.println("Time to create metaedges " + sw);

        /* Add metaedges into graph */
        sw.start();

        // maxMetaEdgeWeight is used in calculation of replusion and attraction forces in
        // FRLayout and other layout algorithms
        for (int k = 0; k < metaedgeArr.size(); k++) {
            int numEdgeBundled = ((MetaEdge) metaedgeArr.get(k)).getNumEdgeSetBundled();
            if (numEdgeBundled > 0) {
                if (numEdgeBundled > maxMetaEdgeWeight) {
                    maxMetaEdgeWeight = numEdgeBundled;
                }
                newgraph.addEdge(metaedgeArr.get(k), pairArr.get(k).getFirst(), pairArr.get(k).getSecond());
            }

        }
        sw.stop();
        pw.println("Time to add metaedges to the graph " + sw);
        System.out.println("Time to add metaedges to the graph " + sw);

        return newgraph;
    }


    /* Initialize components zone */
    /**
     * Initialize components in the GUI.
     */
    private void initComponents() {
        Container content = getContentPane();
        JPanel east = initCompEast();
        JPanel west = initCompWest();
        JPanel p = new JPanel();

        /* For now, components of west and east are swapped. */
        content.add(west, BorderLayout.EAST);
        content.add(east, BorderLayout.WEST);
        pack();
        setVisible(true);
    }

    /**
     * Initialize components of the east part.
     * @return Panel of east part
     */
    public JPanel initCompEast() {
        JPanel east = new JPanel();
        east.setPreferredSize(new Dimension(180, 600));

        JButton openFile = new JButton("Open");
        openFile.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent arg0) {
                inConcentrationMode = false;
                JFileChooser fileChooser = new JFileChooser(fileToOpen);
                File tempFile = fileToOpen;

                fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                fileChooser.setFileFilter(new MNetFileFilter());
//                    fileChooser.setFileHidingEnabled(false);
                fileChooser.showOpenDialog(NaviClusterApp.this);

                fileToOpen = fileChooser.getSelectedFile();

                if (fileToOpen != null) {
                    try {
                        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));

                        StopWatch loadingTime = new StopWatch();
                        loadingTime.start();

                        realGraph = loadModNet(br);
                        originalGraph = realGraph;
                        dynamicGraph = realGraph;
//                        currentLevelGraph = dynamicGraph;

                        loadingTime.stop();
                        pw.println("Time used for loading from input file: " + loadingTime);
                        System.out.println("Time used for loading from input file: " + loadingTime);

//                        louvainCluster(realGraph, realGraph.getVertexCount(),true);

                        ArrayList retList = louvainCluster(realGraph, realGraph.getVertexCount(), true);
                        preparePropertyInfoProcessor();
                        numOfLouvainClusters = ((Set) retList.get(0)).size();
                        Set<Set> cSet = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, true, true, true);
                        /* if do on all nodes in canvas, visualize the result also, or else just do clustering */
                        dynamicGraph = createGraph(cSet);
                        usualNodeToClusterMap = new HashMap(nodeToClusterMap);

                        layout = new AggregateLayout(new CircleLayout<Object, Object>(dynamicGraph));
                        ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
                        vv.setGraphLayout(layout);

                        layout = layoutGraph(layout, dynamicGraph);

//                        visualizeResults(cSet);
                        colorCluster(cSet, mainColor);
                        currentLevelGraph = dynamicGraph;
                        vv.repaint();

                        curVertexLocMap = new HashMap<Object, Point2D>();
                        for (Object ver : layout.getGraph().getVertices()) {
                            curVertexLocMap.put(ver, layout.transform(ver));
                        }
                        curUsualVertexLocMap = new HashMap<Object, Point2D>(curVertexLocMap);
//                        vv.setGraphLayout(layout);
//                        vv.getRenderContext().getParallelEdgeIndexFunction().reset();

                        currentLevel = 0;
                        zoomInButton.setEnabled(true);
                        zoomOutButton.setEnabled(false);

                    } catch (IOException ex) {
                        Logger.getLogger(NaviClusterApp.class.getName()).log(Level.SEVERE, null, ex);
                    }
                } else {
                    fileToOpen = tempFile;
                }
            }
        });


        JButton saveButton = new JButton("Save");
        saveButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                JFileChooser chooser = new JFileChooser(new File("."));
//                    chooser.setAcceptAllFileFilterUsed(false);
                int option = chooser.showSaveDialog(NaviClusterApp.this);

                if (option == JFileChooser.APPROVE_OPTION) {
                    File file = chooser.getSelectedFile();
                    int width = vv.getWidth();
                    int height = vv.getHeight();

                    BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
                    Graphics2D graphics = bi.createGraphics();
                    vv.paint(graphics);
                    graphics.dispose();

                    try {
                        ImageIO.write(bi, "jpeg", file);
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }
            }
        });


        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent arg0) {
                inConcentrationMode = false;
//                    Layout layout = vv.getGraphLayout();
                dynamicGraph = currentLevelGraph;
                curVertexLocMap = new HashMap(curUsualVertexLocMap);
//                    layout.setDelegate(new CircleLayout<Object,Object>(currentLevelGraph));
//                layout.removeAll();
//                layout.setGraph(currentLevelGraph);
//                layout.initialize();
                layout = new AggregateLayout(new StaticLayout(dynamicGraph, new Transformer() {

                    public Object transform(Object ver) {
                        return curUsualVertexLocMap.get(ver);
                    }
                }));

                curCSetCentered = null;
                curCSetCenteredBPC = null;
                curComNodeCSetCentered = null;
                curComNodeCSetCenteredBPC = null;
                centerNodeSet = null;
                highlightedNodeFormerColor = null;
                highlightedNode = null;
                nodeToClusterMap = new HashMap(usualNodeToClusterMap);

                colorCluster(curCSet, mainColor);
                if (clickedNodes != null) {
                    for (Object node : clickedNodes) {
                        vertexPaints.put(node, prevProcessedColor);
                    }
                }

                vv.setGraphLayout(layout);
                vv.repaint();


            }
        });

        zoomOutButton = new JButton("Zoom Out");
        zoomOutButton.setEnabled(false);
        zoomOutButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {

                zoomInButton.setEnabled(true);

                final ViewHistory vh = viewHistoryList.remove(viewHistoryList.size() - 1);
                /* retrieve system information from viewhistory */
                nodeToClusterMap = vh.getNodeToClusterMap();
                usualNodeToClusterMap = vh.getNodeToClusterMap();
                dynamicGraph = vh.getStoredGraph();
                GOProcessor gp = vh.gop;
                curCSetBeforePropClust = vh.cSetBeforeVis;
                curComNodeCSetBeforePropClust = vh.comNodeCSetBeforeVis;
                highlightedNode = vh.getHighlightedNode();
                highlightedNodeFormerColor = vh.getHighlightedNodeFormerColor();


//                System.out.println("cset before vis clust size " + curCSetBeforePropClust.size());

                /* meaning that this is the top level, cannot zoom out anymore */
                if (viewHistoryList.size() == 0) {
                    zoomOutButton.setEnabled(false);
                }

                /* changed 15 Jun 09 */
                curCSet = vh.cSet;
                curComNodeCSet = vh.comNodeCSet;
//                curCSet = curCSetBeforePropClust;
//                curComNodeCSet = curComNodeCSetBeforePropClust;
                curGOP = gp;

                curUsualVertexLocMap = vh.getUsualGraphVerLocMap();
                curVertexLocMap = vh.getVertexLocationMap();

                clickedNodes = new ArrayList(vh.getClickedVertices());
                if (vh.getConcentratedVertices() == null) {
                    centerNodeSet = null;
                } else {
                    centerNodeSet = new HashSet(vh.getConcentratedVertices());
                }
//                    System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
//                    System.out.println("GO Proc: "+curGOP.clusterScoreMap);

//                layout.setGraph(dynamicGraph);
//                layout = (AggregateLayout<Object, Object>) vh.getLayout();
                layout = new AggregateLayout(new StaticLayout(dynamicGraph, new Transformer<Object, Point2D>() {

                    public Point2D transform(Object ver) {
                        return curVertexLocMap.get(ver);
                    }
                }));
//                visualizeResults(curCSet);
//                for (Object vertex : dynamicGraph.getVertices()){
//                    layout.lock(vertex, false);
//                }
                currentLevelGraph = vh.getUsualGraph();


//                ((CircleLayout)layout.getDelegate()).lock(true);
//                for (Object vertex : layout.getGraph().getVertices()){
//                    layout.setLocation(vertex, vh.getVertexLocationMap().get(vertex));
//                    System.out.println("Position "+vh.getVertexLocationMap().get(vertex));
////                    System.out.println("Real Position "+layout.transform(vertex));
//                    layout.lock(vertex, true);
//                }
                for (Object node : clickedNodes) {
                    vertexPaints.put(node, prevProcessedColor);
                }

                /* clear picked state */
                vv.getPickedEdgeState().clear();
                vv.getPickedEdgeState().clear();

                vv.setGraphLayout(layout);
                vv.repaint();



            }
        });


        zoomInButton = new JButton("Zoom In");
        zoomInButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {

                Set pickedSet = vv.getPickedVertexState().getPicked();
                pw.println("pickedSet size: " + pickedSet.size());
                System.out.println("pickedSet size: " + pickedSet.size());
                boolean bad = false;
                if (pickedSet.size() != 0) {
                    for (Object obj : pickedSet) {
                        if (obj instanceof BioObject) {
                            bad = true;
                            break;
                        }
                    }
                    if (!bad) {
                        zoomInAction(pickedSet);
//                        reLouvainCluster(curCSetBeforePropClust, true);
                    }
                }


            }
        });



        JPanel grid = new JPanel(new GridLayout(1, 2));
        grid.add(openFile);
        grid.add(saveButton);
        east.add(grid);

        JPanel grid2 = new JPanel(new GridLayout(1, 1));
        grid2.add(resetButton);
        east.add(grid2);

        JPanel zoomPanel = new JPanel(new GridLayout(2, 1));
        zoomPanel.setBorder(BorderFactory.createTitledBorder("Zooming"));
        zoomPanel.add(zoomInButton);
        zoomPanel.add(zoomOutButton);
        east.add(zoomPanel);

        JPanel p = new JPanel();

        final JPanel eastControls = new JPanel();
        eastControls.setOpaque(true);
        eastControls.setLayout(new BoxLayout(eastControls, BoxLayout.Y_AXIS));
        eastControls.add(Box.createVerticalGlue());

        //eastControls.add(eastSize);
        eastControls.add(Box.createVerticalGlue());
        east.add(eastControls);

        p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Louvain Clustering"));

        JButton reLouvainButton = new JButton("     Run     ");
        reLouvainButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                double ccValue = (double) ccSlider.getValue() / 10;
                double mfValue = (double) mfSlider.getValue() / 10;
                double bpValue = (double) bpSlider.getValue() / 10;

                GOProcessor.getWeightMap().put(NameSpace.BP, bpValue);
                GOProcessor.getWeightMap().put(NameSpace.MF, mfValue);
                GOProcessor.getWeightMap().put(NameSpace.CC, ccValue);
                /* if we want to cluster peripheral clusters, not all clusters */
                if (inConcentrationMode) {
//                if (curCSetCenteredBPC != null) {
                    Set cSet = new HashSet();
                    ArrayList retList = reLouvainCluster(curCSetCenteredBPC, false);
                    Set<Set> cSetFromPropClust = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, false, false, true);
//                    curCSetCentered = (Set<Set>) retList.get(0);

                    for (Object picked : centerNodeSet) {
                        cSet.add(picked);
                    }
//                    cSet.addAll(curCSetCentered);
                    cSet.addAll(cSetFromPropClust);

                    dynamicGraph = createGraph(cSet);

                    colorCluster(centerNodeSet, mainColor);
                    colorCluster(cSetFromPropClust, peripheralColor);

                    layout.setGraph(dynamicGraph);
                    vv.setGraphLayout(layout);

                    curVertexLocMap = new HashMap<Object, Point2D>();
                    for (Object ver : layout.getGraph().getVertices()) {
                        curVertexLocMap.put(ver, layout.transform(ver));
                    }

                } else {
                    /* redo louvainCluster on all nodes */
                    ArrayList retList = null;
                    Set<Set> cSet = null;
                    if (!zoomOutButton.isEnabled()) {
                        retList = reLouvainCluster(curCSetBeforePropClust, true);
                        cSet = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, true, true, true);
                    } else {
                        retList = reLouvainCluster(curCSetBeforePropClust, false);
                        cSet = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, false, true, true);
                    }

                    dynamicGraph = createGraph(cSet);
                    usualNodeToClusterMap = new HashMap(nodeToClusterMap);


                    layout = new AggregateLayout(new CircleLayout<Object, Object>(dynamicGraph));
                    ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
                    vv.setGraphLayout(layout);

                    layout = layoutGraph(layout, dynamicGraph);
//                    visualizeResults(cSet);
                    colorCluster(cSet, mainColor);
                    currentLevelGraph = dynamicGraph;
                    vv.repaint();

//                    curVertexLocMap = new HashMap<Object,Point2D>();
//                    for (Object ver : layout.getGraph().getVertices()) {
//                        curVertexLocMap.put(ver, layout.transform(ver));
//                    }
//
//                    layout = new AggregateLayout(new FRLayout<Object,Object>(dynamicGraph));
//                    layout.setInitializer(new Transformer<Object,Point2D>(){
//
//                        public Point2D transform(Object arg0) {
//                            return curVertexLocMap.get(arg0);
//                        }
//                    });
//                    layout = new AggregateLayout(new CircleLayout<Object,Object>(dynamicGraph));
//                    ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
//                    visualizeResults(cSet);

                    curVertexLocMap = new HashMap<Object, Point2D>();
                    for (Object ver : layout.getGraph().getVertices()) {
                        curVertexLocMap.put(ver, layout.transform(ver));
                    }
                    curUsualVertexLocMap = new HashMap<Object, Point2D>(curVertexLocMap);
                }
            }
        });
        p.add(reLouvainButton);
        east.add(p);

        p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Search For: (Name)"));

        JPanel grids = new JPanel(new GridLayout(2, 1));

        JPanel tmpPanel = new JPanel();
        tmpPanel.add(searchTextField);
        grids.add(tmpPanel);

        searchTextField.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (searchTextField.getText().length() != 0) {
                    searchFor();
                }

            }
        });

        JButton sButton = new JButton("  Run  ");
        sButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (searchTextField.getText().length() != 0) {
                    searchFor();
                }
            }
        });

        tmpPanel = new JPanel();
        tmpPanel.add(sButton);
        grids.add(tmpPanel);

        p.add(grids);
        east.add(p);

        searchResList = new JList(listModel);
        searchResList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        searchResList.setLayoutOrientation(JList.VERTICAL);
        searchResList.setVisibleRowCount(7);

        listScroller = new JScrollPane(searchResList);
        listScroller.setPreferredSize(new Dimension(150, 150));

        final JButton focusSearchButton = new JButton("Focus");
        focusSearchButton.setActionCommand("Focus");
        focusSearchButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                focusNodeBySearch((BioObject) searchResList.getSelectedValue());
            }
        });

        searchResList.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    focusSearchButton.doClick(); //emulate button click
                }
            }
        });

        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));
        listScroller.setAlignmentX(JComponent.CENTER_ALIGNMENT);
        focusSearchButton.setAlignmentX(JComponent.CENTER_ALIGNMENT);

        panel.add(listScroller);
        panel.add(focusSearchButton);

        east.add(panel);

        return east;
    }

    /**
     * Initialize components of the west part.
     * @return Panel of west part
     */
    public JPanel initCompWest() {
        JPanel west = new JPanel();
        west.setPreferredSize(new Dimension(200, 600));

        JPanel p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("GO Namespace Weight"));

        JPanel grid3 = new JPanel(new GridLayout(3, 1));

        ccSlider.setMajorTickSpacing(2);

        ccSlider.setMinorTickSpacing(1);
        ccSlider.setPaintTicks(true);
        TitledBorder title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Cellular Component");
        title.setTitleColor(new Color(0xED143F));
        title.setTitlePosition(TitledBorder.CENTER);
        ccSlider.setBorder(title);


        bpSlider.setMajorTickSpacing(2);
        bpSlider.setMinorTickSpacing(1);
        bpSlider.setPaintTicks(true);
        title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Biological Process");
        title.setTitlePosition(TitledBorder.CENTER);
        title.setTitleColor(new Color(0x3425B1));
        bpSlider.setBorder(title);

        mfSlider.setMajorTickSpacing(2);
        mfSlider.setMinorTickSpacing(1);
        mfSlider.setPaintTicks(true);
        title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Molecular Function");
        title.setTitlePosition(TitledBorder.CENTER);
        title.setTitleColor(new Color(0x338F06));
        mfSlider.setBorder(title);

        grid3.add(ccSlider);
        grid3.add(mfSlider);
        grid3.add(bpSlider);
//            grid3.setPreferredSize(new Dimension(p.getPreferredSize().width-10,grid3.getPreferredSize().height));
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));
        p.add(grid3);

        JPanel grid2 = new JPanel(new GridLayout(2, 1));

        grid3 = new JPanel();

//            p = new JPanel();
//            p.setBorder(BorderFactory.createTitledBorder("Vis Threshold"));
//            grid3 = new JPanel(new GridLayout(2, 1));
        JLabel lab = new JLabel("#Clusters: ");
        lab.setLabelFor(thresholdTextField);
        grid3.add(lab);
        grid3.add(thresholdTextField);
        thresholdTextField.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
//                    rePropCluster(false);
                refineGOAnnot(e);
            }
        });
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));
        grid2.add(grid3);

        JButton GORefineButton = new JButton("Run/Modify");
        GORefineButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                refineGOAnnot(e);
            }
        });
//            p.add(GORefineButton);
        JPanel tmpPanel = new JPanel();
        tmpPanel.add(GORefineButton);
        grid2.add(tmpPanel);

        p.add(grid2);
        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height + grid2.getPreferredSize().height));
        west.add(p);

        p = new JPanel();

        p.setBorder(BorderFactory.createTitledBorder("Property Edge Filter"));
        goEdgeSlider.setMajorTickSpacing(2);
        goEdgeSlider.setMinorTickSpacing(1);
        goEdgeSlider.setPaintTicks(true);
        goEdgeSlider.addChangeListener(new ChangeListener() {

            public void stateChanged(ChangeEvent e) {
                JSlider source = (JSlider) e.getSource();
                if (!source.getValueIsAdjusting()) {
                    double threshold = source.getValue();
//                        System.out.println("threshold "+threshold);
                    if (threshold == source.getMaximum()) {
//                        System.out.println("thresh max: " + threshold);
                        medp.setThresholdForSE(0.0);
                    } else if (threshold == 0.0) {
                        /* inner product will never be more than 1, i.e. show all edges */
                        medp.setThresholdForSE(2.0);
                    } else {
//                        pw.println("thresh " + (source.getMaximum() - threshold));
//                        System.out.println("thresh " + (source.getMaximum() - threshold));
                        medp.setThresholdForSE(0.1 * (source.getMaximum() - threshold));
                    }
                    vv.repaint();
                }
            }
        });

        grid3 = new JPanel(new GridLayout(1, 1));
        grid3.add(goEdgeSlider);
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));
        p.add(grid3);
        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height));
        west.add(p);

        p = new JPanel();
        p.setBorder(BorderFactory.createTitledBorder("Node Concentration"));
        grid3 = new JPanel(new GridLayout(1, 2));
        grid3.add(new JLabel("Num Hops: "));
        grid3.add(numHops);
        numHops.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                concentrateNodes();
            }
        });
        grid3.setPreferredSize(new Dimension(180, grid3.getPreferredSize().height));

        JButton centerButton = new JButton("  Run  ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
        centerButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                concentrateNodes();
            }
        });

        p.add(grid3);
        p.add(centerButton);
        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height + 30));
        west.add(p);

        p = new JPanel();
//        p.setBorder(BorderFactory.createTitledBorder("Concentrate on node(s)"));


        JButton createGraphViewButton = new JButton("Create New Graph View");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
        createGraphViewButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
//                concentrateNodes();
//                createGraphFromSubset();
                CreateGraphFromNodeSetDialog dialog = new CreateGraphFromNodeSetDialog(NaviClusterApp.this, true, dynamicGraph, realGraph);
                dialog.setVisible(true);
                System.out.println("dialog return set size " + dialog.getSelectedNodeSet().size());
                System.out.println("dialog return set  " + dialog.getSelectedNodeSet());
                if (dialog.isAnswerOK()) {
                    Set cSet = new HashSet(dialog.getSelectedNodeSet());
                    GOProcessor gp = new GOProcessor();
                    gp.populateGOTerms(cSet);
//                    curGOP = gp;
                    nodesGOVectorMap.putAll(putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet)));
                    dynamicGraph = createGraph(cSet);
                    usualNodeToClusterMap = new HashMap(nodeToClusterMap);

                    layout = new AggregateLayout(new CircleLayout<Object, Object>(dynamicGraph));
//        ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
                    ((CircleLayout) layout.getDelegate()).setRadius(0.30 * 600);
                    vv.setGraphLayout(layout);

                    layout = layoutGraph(layout, dynamicGraph);

                    colorCluster(cSet, mainColor);
                    currentLevelGraph = dynamicGraph;
                    vv.repaint();
                    curVertexLocMap = new HashMap<Object, Point2D>();
                    for (Object ver : layout.getGraph().getVertices()) {
                        curVertexLocMap.put(ver, layout.transform(ver));
                    }
                    curUsualVertexLocMap = new HashMap<Object, Point2D>(curVertexLocMap);
                }
            }
        });


        p.add(createGraphViewButton);
//        p.setPreferredSize(new Dimension(190, p.getPreferredSize().height + 30));
        p.setPreferredSize(new Dimension(190, 40));
        west.add(p);

        return west;
    }

    public void createGraphFromSubset() {
        final JDialog jd = new JDialog(this);
        javax.swing.JButton jButton1;
        javax.swing.JButton jButton2;
        javax.swing.JButton jButton3;
        javax.swing.JButton jButton4;
        javax.swing.JLabel jLabel1;
        javax.swing.JLabel jLabel2;
        javax.swing.JLabel jLabel3;
        javax.swing.JLabel jLabel4;
        javax.swing.JPanel jPanel1;
        javax.swing.JPanel jPanel2;
        javax.swing.JPanel jPanel3;
        javax.swing.JPanel jPanel4;
        javax.swing.JScrollPane jScrollPane1;
        javax.swing.JScrollPane jScrollPane2;
        javax.swing.JScrollPane jScrollPane3;
        javax.swing.JScrollPane jScrollPane4;
        javax.swing.JSplitPane jSplitPane1;
        javax.swing.JSplitPane jSplitPane2;
        javax.swing.JTextArea jTextArea1;
        javax.swing.JTextArea jTextArea2;
        javax.swing.JTextArea jTextArea3;
        javax.swing.JTextArea jTextArea4;
        javax.swing.JPanel mainPanel;

        mainPanel = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jButton2 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jSplitPane1 = new javax.swing.JSplitPane();
        jSplitPane2 = new javax.swing.JSplitPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jPanel3 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();


        jd.setTitle("Create a New Graph View");
        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
        jd.setModal(true);

        JPanel panel = new JPanel();
        jd.setContentPane(panel);


        mainPanel.setName("mainPanel"); // NOI18N

        jPanel1.setName("jPanel1"); // NOI18N

        jButton2.setText("OK"); // NOI18N
        jButton2.setName("jButton2"); // NOI18N

        jButton4.setText("Cancel"); // NOI18N
        jButton4.setName("jButton4"); // NOI18N

        jLabel1.setText("Create a new graph view from the selected nodes?"); // NOI18N
        jLabel1.setName("jLabel1"); // NOI18N


        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
                jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jPanel1Layout.createSequentialGroup().add(28, 28, 28).add(jLabel1).addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 200, Short.MAX_VALUE).add(jButton2).addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED).add(jButton4).add(47, 47, 47)));
        jPanel1Layout.setVerticalGroup(
                jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup().addContainerGap(24, Short.MAX_VALUE).add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE).add(jLabel1).add(jButton4).add(jButton2)).addContainerGap()));

        jPanel3.setName("jPanel3"); // NOI18N

        jLabel2.setText("Please select nodes from the left and press >> button to move it to the right"); // NOI18N
        jLabel2.setName("jLabel2"); // NOI18N

        jLabel3.setText("If you do not need some nodes on the right pane, select them and then press << button to move them back"); // NOI18N
        jLabel3.setName("jLabel3"); // NOI18N

        jLabel4.setText("When you finish node selection, press the OK button, or else press the cancel button."); // NOI18N
        jLabel4.setName("jLabel4"); // NOI18N

        org.jdesktop.layout.GroupLayout jPanel3Layout = new org.jdesktop.layout.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
                jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jPanel3Layout.createSequentialGroup().addContainerGap().add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jLabel2).add(jLabel4).add(jLabel3)).addContainerGap(57, Short.MAX_VALUE)));
        jPanel3Layout.setVerticalGroup(
                jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jPanel3Layout.createSequentialGroup().addContainerGap().add(jLabel2).addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED).add(jLabel3).addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED).add(jLabel4).addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));

        jPanel4.setName("jPanel4"); // NOI18N

        jSplitPane1.setBorder(null);
        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        jSplitPane1.setResizeWeight(0.7);
        jSplitPane1.setName("jSplitPane1"); // NOI18N

        jSplitPane2.setBorder(null);
        jSplitPane2.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        jSplitPane2.setResizeWeight(0.5);
        jSplitPane2.setName("jSplitPane2"); // NOI18N

        jScrollPane2.setName("jScrollPane2"); // NOI18N

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jTextArea2.setBorder(null);
        jTextArea2.setName("jTextArea2"); // NOI18N
        jScrollPane2.setViewportView(jTextArea2);

        jSplitPane2.setTopComponent(jScrollPane2);

        jScrollPane3.setName("jScrollPane3"); // NOI18N

        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jTextArea3.setBorder(null);
        jTextArea3.setName("jTextArea3"); // NOI18N
        jScrollPane3.setViewportView(jTextArea3);

        jSplitPane2.setRightComponent(jScrollPane3);

        jSplitPane1.setLeftComponent(jSplitPane2);

        jScrollPane4.setName("jScrollPane4"); // NOI18N

        jTextArea4.setColumns(20);
        jTextArea4.setRows(5);
        jTextArea4.setBorder(null);
        jTextArea4.setName("jTextArea4"); // NOI18N
        jScrollPane4.setViewportView(jTextArea4);

        jSplitPane1.setRightComponent(jScrollPane4);

        jScrollPane1.setName("jScrollPane1"); // NOI18N

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setName("jTextArea1"); // NOI18N
        jScrollPane1.setViewportView(jTextArea1);

        jPanel2.setName("jPanel2"); // NOI18N

        jButton1.setText(">>"); // NOI18N
        jButton1.setName("jButton1"); // NOI18N

        jButton3.setText("<<"); // NOI18N
        jButton3.setName("jButton3"); // NOI18N

        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
                jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jPanel2Layout.createSequentialGroup().addContainerGap().add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jButton3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 46, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE).add(jButton1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 46, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)).addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
        jPanel2Layout.setVerticalGroup(
                jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jPanel2Layout.createSequentialGroup().add(141, 141, 141).add(jButton1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 57, Short.MAX_VALUE).add(18, 18, 18).add(jButton3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 57, Short.MAX_VALUE).add(144, 144, 144)));

        org.jdesktop.layout.GroupLayout jPanel4Layout = new org.jdesktop.layout.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
                jPanel4Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(jPanel4Layout.createSequentialGroup().addContainerGap().add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE).addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED).add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE).add(2, 2, 2).add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE).add(8, 8, 8)));
        jPanel4Layout.setVerticalGroup(
                jPanel4Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel4Layout.createSequentialGroup().add(20, 20, 20).add(jPanel4Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING).add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 417, Short.MAX_VALUE).add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 417, Short.MAX_VALUE)).addContainerGap()));

        org.jdesktop.layout.GroupLayout mainPanelLayout = new org.jdesktop.layout.GroupLayout(mainPanel);
        mainPanel.setLayout(mainPanelLayout);
        mainPanelLayout.setHorizontalGroup(
                mainPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(mainPanelLayout.createSequentialGroup().add(mainPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(mainPanelLayout.createSequentialGroup().add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).add(13, 13, 13)).add(jPanel3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE).add(mainPanelLayout.createSequentialGroup().add(9, 9, 9).add(jPanel4, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 759, Short.MAX_VALUE))).add(20, 20, 20)));
        mainPanelLayout.setVerticalGroup(
                mainPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(org.jdesktop.layout.GroupLayout.TRAILING, mainPanelLayout.createSequentialGroup().add(jPanel3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE).addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED).add(jPanel4, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).add(0, 0, 0).add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)));


        jd.setContentPane(mainPanel);

//        jd.setPreferredSize(new Dimension(600, 600));
//        jd.setResizable(false);
        jd.pack();
        jd.setVisible(true);

        jd.setLocationRelativeTo(this);


    }


    /* Action performed when acting with components on the GUI zone*/
    /**
     * Highlight node being searched for.
     * @param nodeToFocus
     */
    public void focusNodeBySearch(BioObject nodeToFocus) {

        if (highlightedNode != null) {
            vertexPaints.put(highlightedNode, highlightedNodeFormerColor);
        }
        searchedBioObj = nodeToFocus;
        highlightedNode = nodeToClusterMap.get(nodeToFocus);
        highlightedNodeFormerColor = (Color) vertexPaints.get(highlightedNode);
        vertexPaints.put(highlightedNode, searchedColor);

        vv.repaint();

    }

    /**
     * Search for BioObject specified in the searchTextField
     * and populate the list shown on GUI
     */
    public void searchFor() {
        Set listRes = new HashSet();
        for (Object obj : dynamicGraph.getVertices()) {
            if (obj instanceof Set) {
                for (Object bioObj : (Set) obj) {
                    BioObject bio = (BioObject) bioObj;
                    if (bio.getName().toUpperCase().contains(searchTextField.getText().toUpperCase())) {
                        listRes.add(bio);
                    } else if (bio.getStandardName().toUpperCase().contains(searchTextField.getText().toUpperCase())) {
                        listRes.add(bio);
                    } else {
                        for (String st : bio.getSynonym()) {
                            if (st.toUpperCase().contains(searchTextField.getText().toUpperCase())) {
                                listRes.add(bio);
                                break;
                            }
                        }
                    }

                }
            } else if (obj instanceof BioObject) {
                BioObject bio = (BioObject) obj;
                if (bio.getName().toUpperCase().contains(searchTextField.getText().toUpperCase())) {
                    listRes.add(bio);
                } else if (bio.getStandardName().toUpperCase().contains(searchTextField.getText().toUpperCase())) {
                    listRes.add(bio);
                } else {
                    for (String st : bio.getSynonym()) {
                        if (st.toUpperCase().contains(searchTextField.getText().toUpperCase())) {
                            listRes.add(bio);
                            break;
                        }
                    }
                }
            }
        }
        listModel.removeAllElements();
        pw.println("Search result: ");
        System.out.println("Search result: ");
        for (Object res : listRes) {
            pw.println(res);
            System.out.println(res);
            listModel.addElement(res);

        }

    }

    /**
     * This method re-run property-based clustering based on the current nodes on the canvas
     * If GO namespace weights are adjusted, the property-based clustering will take new values
     * into consideration too.
     * @param e
     */
    public void refineGOAnnot(ActionEvent e) {
        double ccValue = (double) ccSlider.getValue() / 10;
        double mfValue = (double) mfSlider.getValue() / 10;
        double bpValue = (double) bpSlider.getValue() / 10;
//        System.out.println("cc "+ccValue);
//        System.out.println("mf "+mfValue);
//        System.out.println("bp "+bpValue);
        boolean nochange = true;
        if ((GOProcessor.getWeightMap().get(NameSpace.BP) != bpValue) ||
                (GOProcessor.getWeightMap().get(NameSpace.MF) != mfValue) ||
                (GOProcessor.getWeightMap().get(NameSpace.CC) != ccValue)) {
            nochange = false;
        }

        GOProcessor.getWeightMap().put(NameSpace.BP, bpValue);
        GOProcessor.getWeightMap().put(NameSpace.MF, mfValue);
        GOProcessor.getWeightMap().put(NameSpace.CC, ccValue);
        rePropCluster(!nochange);
    }

    /**
     * Concentrate on selected nodes by gathering nodes connecting with them between the distance
     * specified in number of hops textbox
     */
    public void concentrateNodes() {
        inConcentrationMode = true;
        String toNumHops = numHops.getText();
        int numHopsFromCenter = 0;

        try {
            numHopsFromCenter = Integer.parseInt(toNumHops);
        } catch (NumberFormatException e) {
            String toShown = "Number of hops should be integer only.";
            JOptionPane.showMessageDialog(NaviClusterApp.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);
        }

        Set pickedSet = vv.getPickedVertexState().getPicked();
        pw.println("pickedSet size: " + pickedSet.size());
        System.out.println("pickedSet size: " + pickedSet.size());

        if (pickedSet.size() != 0) {
            /* check if the vertex is the set (of set or of BioObject) */
            /* Process vertices to be concentrated */
            Set cSet = new HashSet(), comNodeCSet = new HashSet(), cSetCenter = new HashSet();
            Set nodesInCenterSet = new HashSet();
            Set nodesAroundCenter = new HashSet();
            Set toBeProcessed = new HashSet();
            centerNodeSet = new HashSet(pickedSet);
            clickedNodes = new ArrayList(pickedSet);

            for (Object ver : pickedSet) {
//                    System.out.println("\nVertex: "+ver);
                if (ver instanceof Set) {
                    Set vertex = (Set) ver;
//                        System.out.println("\nVertex size: "+vertex.size());
                    nodesInCenterSet.addAll(vertex);
                    cSet.add(vertex);
                    cSetCenter.add(vertex);
                    comNodeCSet.add(flatClustToComNodeClust.get(vertex));
                } else if (ver instanceof BioObject) {

                    BioObject vertex = (BioObject) ver;
//                    System.out.println("ver : "+vertex);
                    nodesInCenterSet.add(vertex);
                    cSet.add(vertex);
                    cSetCenter.add(vertex);
                    /* Below code seems to be ok but not 100% sure */
                    comNodeCSet.add(vertex);
                }

            }
            toBeProcessed.addAll(nodesInCenterSet);

            for (int i = 1; i <= numHopsFromCenter; i++) {
                Set neighbors = new HashSet();
                Set tmpSet = new HashSet(toBeProcessed);
//                System.out.println("toBeProcessed: "+toBeProcessed);
                Iterator it = tmpSet.iterator();
                for (; it.hasNext();) {
                    Object object = it.next();
                    BioObject bio = (BioObject) object;
                    System.out.println("Bio: " + bio);
                    for (Object neighbor : originalGraph.getNeighbors(bio)) {
                        System.out.println("neighbor: " + neighbor);
                        if (!nodesInCenterSet.contains(neighbor) && !nodesAroundCenter.contains(neighbor)) {
                            neighbors.add(neighbor);
                        }
                    }
//                    System.out.println("neighbors: "+neighbors);
                    toBeProcessed.addAll(neighbors);
                    toBeProcessed.remove(object);
                }
                nodesAroundCenter.addAll(toBeProcessed);
//                System.out.println("tobeprocessed: "+toBeProcessed);
            }

            Set newCSet = new HashSet();
            ArrayList retList = reLouvainCluster(nodesAroundCenter, false);
            Set cSetFromPropClust = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, false, false, true);
            newCSet.addAll(cSetFromPropClust);

            cSet.addAll(newCSet);

            /* if edge size to be relouvain clustered is zero, curComNodeCSetCentered will be null
             * and no need to add to comnodecSet
             */
            if (curComNodeCSetCentered != null) {
                comNodeCSet.addAll(curComNodeCSetCentered);
            }

//            System.out.println("cSet: " + cSet.size());

            dynamicGraph = createGraph(cSet);
//            layout = new AggregateLayout(new FRLayout<Object,Object>(dynamicGraph));
            layout = new AggregateLayout<Object, Object>(new CircleLayout<Object, Object>(dynamicGraph));
            ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
            colorCluster(newCSet, peripheralColor);
            colorCluster(cSetCenter, mainColor);
            layout.setGraph(dynamicGraph);

            Graph tempGraph = SparseMultigraph.getFactory().create();
            for (Object object : cSetCenter) {
                tempGraph.addVertex(object);

            }
            Layout subLayout = new CircleLayout(tempGraph);
            subLayout.setInitializer(vv.getGraphLayout());
            subLayout.setSize(new Dimension(60, 60));

            layout.put(subLayout, new Point(vv.getSize().width / 2, vv.getSize().height / 2));

            vv.setGraphLayout(layout);

            curVertexLocMap = new HashMap<Object, Point2D>();
            for (Object ver : layout.getGraph().getVertices()) {
                curVertexLocMap.put(ver, layout.transform(ver));
            }

            vv.repaint();

        }
    }

    /**
     * Re-run louvain clustering by taking nodes in cSet as input
     * @param cSet
     * @param doOnAllNodesInCanvas
     * @return
     */
    public ArrayList reLouvainCluster(Set cSet, boolean isTopLevel) {

        /* Build new input for Louvain Clusterer */
        Set<BioObject> bioObjectToClusteredSet = new HashSet<BioObject>();
        int id = 0;
        nodeMap.clear();
        final Map<BioObject, Integer> idMap = new HashMap<BioObject, Integer>();
        Iterator iter = cSet.iterator();

        /* Add bioObject to the set */
        for (; iter.hasNext();) {
            Object obj = iter.next();
            if (obj instanceof Set) {
                Set<BioObject> set = (Set<BioObject>) obj;
                for (BioObject bio : set) {
                    bioObjectToClusteredSet.add(bio);
                    nodeMap.put(id, bio);
                    idMap.put(bio, id);
                    id++;
                }
            } //                bioObjectToClusteredSet.addAll((Set)obj);
            else if (obj instanceof BioObject) {
                bioObjectToClusteredSet.add((BioObject) obj);
                nodeMap.put(id, (BioObject) obj);
                idMap.put((BioObject) obj, id);
//                System.out.println("obj "+obj+" id "+id);
                id++;
            }
        }

        Set edgeSet = new TreeSet(new Comparator() {

            public int compare(Object e1, Object e2) {
                Pair pair1 = originalGraph.getEndpoints(e1);
                Object e1v1 = pair1.getFirst();
                Object e1v2 = pair1.getSecond();
                Pair pair2 = originalGraph.getEndpoints(e2);
                Object e2v1 = pair2.getFirst();
                Object e2v2 = pair2.getSecond();
                if (idMap.get(e1v1) < idMap.get(e2v1)) {
                    return -1;
                } else if (idMap.get(e1v1) == idMap.get(e2v1)) {
                    if (idMap.get(e1v2) < idMap.get(e2v2)) {
                        return -1;
                    } else if (idMap.get(e1v2) == idMap.get(e2v2)) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    return 1;
                }
            }
        });
        Set tmpSortedSet = new TreeSet(new Comparator() {

            public int compare(Object e1, Object e2) {
                Pair pair1 = originalGraph.getEndpoints(e1);
                Object e1v1 = pair1.getFirst();
                Object e1v2 = pair1.getSecond();
                Pair pair2 = originalGraph.getEndpoints(e2);
                Object e2v1 = pair2.getFirst();
                Object e2v2 = pair2.getSecond();
                if (idMap.get(e1v1) < idMap.get(e2v1)) {
                    return -1;
                } else if (idMap.get(e1v1) == idMap.get(e2v1)) {
                    if (idMap.get(e1v2) < idMap.get(e2v2)) {
                        return -1;
                    } else if (idMap.get(e1v2) == idMap.get(e2v2)) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    return 1;
                }
            }
        });
        int pivot = 0;
        /* Add corresponding edges to the edgeSet*/
        for (BioObject bio : bioObjectToClusteredSet) {
            boolean noEdgeAdded = true;
            for (Object edge : originalGraph.getIncidentEdges(bio)) {
                Pair pair = originalGraph.getEndpoints(edge);
                Object firstVertex = pair.getFirst();
                Object secondVertex = pair.getSecond();
                if (!idMap.containsKey(firstVertex)) {
                    continue;
                }
                if (!idMap.containsKey(secondVertex)) {
                    continue;
                }
                edgeSet.add(edge);
                noEdgeAdded = false;
            }
            if (noEdgeAdded) {
                /* swap "bio" to the front of the id list so that it can be recognized
                 * after louvain clustering
                 */
                int tmp = 0;
                BioObject tmpBio = null;
                if (idMap.get(bio) != pivot) {
                    // swap
                    tmp = idMap.get(bio);
                    tmpBio = nodeMap.get(pivot);
                    idMap.put(bio, pivot);
                    nodeMap.put(pivot, bio);
                    idMap.put(tmpBio, tmp);
                    nodeMap.put(tmp, tmpBio);
//                    System.out.println("tmpBio "+tmpBio+ " tmp "+tmp);
//                    System.out.println("bio "+bio+" pivot "+pivot);
                }
                pivot++;

            }
//            edgeSet.addAll(originalGraph.getIncidentEdges(bio));
        }
        tmpSortedSet.addAll(edgeSet);
        edgeSet = tmpSortedSet;

        int numEdge = edgeSet.size();
        pw.println("Edge set size to be new input for Louvain Clustering: " + numEdge);
        pw.println("BioObject set size to be new input for Louvain Clustering: " + bioObjectToClusteredSet.size());
        System.out.println("Edge set size to be new input for Louvain Clustering: " + numEdge);
        System.out.println("BioObject set size to be new input for Louvain Clustering: " + bioObjectToClusteredSet.size());

        sArr = new int[numEdge];
        dArr = new int[numEdge];
        if (wArr != null) {
            wArr = new double[numEdge];
        }
        int i = 0;

        /* Build new three input array for Louvain Clusterer */
//        StopWatch sw = new StopWatch();
//        sw.start();

        for (Object edge : edgeSet) {
            Pair pair = originalGraph.getEndpoints(edge);
            Object firstVertex = pair.getFirst();
            Object secondVertex = pair.getSecond();
            Object tmp = null;
//            if (idMap.get(firstVertex) > idMap.get(secondVertex)){
//                tmp = firstVertex;
//                firstVertex = secondVertex;
//                secondVertex = tmp;
//            }
//            System.out.println(idMap.get(firstVertex)+":"+idMap.get(secondVertex));
            sArr[i] = idMap.get(firstVertex);
            dArr[i] = idMap.get(secondVertex);
            if (isWeightGraph) {
                int weight = ew.getWeight(edge);
                wArr[i] = weight;
            }
            i++;
        }
        if (i == 0) {
            sArr = null;
        }

//        sw.stop();
//        System.out.println("Load to String time "+sw);

        ArrayList retList = louvainCluster(dynamicGraph, bioObjectToClusteredSet.size(), isTopLevel);
        return retList;
    }

    /**
     * Re-run property-based clustering on the current nodes on the canvas
     * GO namespace weights at the time of running this method are considered also.
     * @param newAnnot
     */
    public void rePropCluster(boolean newAnnot) {
        /* if inConcentrationMode is true, the program is concentrating on some node(s). */
        if (inConcentrationMode) {
            if (curCSetCenteredBPC.size() >= Integer.parseInt(thresholdTextField.getText())) {

                Set cSetFromPropClust = propertyBasedCluster(curCSetCenteredBPC, curComNodeCSetCenteredBPC, curGOPCentered, false, false, newAnnot);
                Set cSet = new HashSet();
//                System.out.println("CenterNodeSet: "+centerNodeSet);
                for (Object picked : centerNodeSet) {
                    cSet.add(picked);
                }
                cSet.addAll(cSetFromPropClust);
                dynamicGraph = createGraph(cSet);

                colorCluster(centerNodeSet, mainColor);
                colorCluster(cSetFromPropClust, peripheralColor);

                layout.setGraph(dynamicGraph);
                vv.setGraphLayout(layout);
                curVertexLocMap = new HashMap<Object, Point2D>();
                for (Object ver : layout.getGraph().getVertices()) {
                    curVertexLocMap.put(ver, layout.transform(ver));
                }

                vv.repaint();

            } else {
                String toShown = "A number of nodes in the canvas are less than/equal to that specified in the text box. " + curCSetCenteredBPC.size();
                JOptionPane.showMessageDialog(NaviClusterApp.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);

            }
        } else if (curCSetBeforePropClust.size() >= Integer.parseInt(thresholdTextField.getText())) {
            Set cSet = propertyBasedCluster(curCSetBeforePropClust, curComNodeCSetBeforePropClust, curGOP, false, true, newAnnot);
            dynamicGraph = createGraph(curCSet);
            usualNodeToClusterMap = new HashMap(nodeToClusterMap);

            layout = new AggregateLayout(new CircleLayout<Object, Object>(dynamicGraph));
            ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
            vv.setGraphLayout(layout);

            layout = layoutGraph(layout, dynamicGraph);
//            visualizeResults(cSet);
            colorCluster(cSet, mainColor);
            currentLevelGraph = dynamicGraph;
            vv.repaint();

            curVertexLocMap = new HashMap<Object, Point2D>();
            for (Object ver : layout.getGraph().getVertices()) {
                curVertexLocMap.put(ver, layout.transform(ver));
            }
            curUsualVertexLocMap = new HashMap<Object, Point2D>(curVertexLocMap);
        }

    }

    /**
     * Already commonly used by doubleclickplugin function
     * Assume that vertexToProcessed is not null set
     */
    private boolean zoomInAction(Set vertexToProcessed) {
        inConcentrationMode = false;
        int countBioObjSet = 0;
        Set setOfComNodeCSet = new HashSet();

        /* check if the vertex is the set (of set or of BioObject) */
        boolean lastLevel = false;
//        ViewHistory viewhist = new ViewHistory(curCSetBeforePropClust, curComNodeCSetBeforePropClust, curGOP, dynamicGraph);
        ViewHistory viewhist = new ViewHistory(curCSetBeforePropClust, curComNodeCSetBeforePropClust, curGOP, layout);
        viewhist.setCSet(curCSet);
        viewhist.setComNodeCSet(curComNodeCSet);
        viewHistoryList.add(viewhist);
        viewhist.setClickedVertices(new ArrayList(vertexToProcessed));
        if (centerNodeSet == null) {
            viewhist.setConcentratedVertices(null);
        } else {
            viewhist.setConcentratedVertices(new ArrayList(centerNodeSet));
        }

        viewhist.setVertexLocationMap(curVertexLocMap);
//        System.out.println("--------------"+curVertexLocMap.size());
        viewhist.setUsualGraphVerLocMap(curUsualVertexLocMap);
//        System.out.println("--------------"+curUsualVertexLocMap.size());
//        viewhist.setVertexLocationMap(verLocationMap);

        viewhist.setStoredGraph(dynamicGraph);
        viewhist.setUsualGraph(currentLevelGraph);
        viewhist.setNodeToClusterMap(nodeToClusterMap);
        viewhist.setUsualNodeToClusterMap(usualNodeToClusterMap);

//        System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
        zoomOutButton.setEnabled(true);
        vv.getPickedEdgeState().clear();
        vv.getPickedVertexState().clear();
        Set tempCSet = new HashSet();
        Set comNodeSet = new HashSet();

        /* Deal with extracting members from vertex selected */
        for (Object ver : vertexToProcessed) {
            Set vertex = (Set) ver;
            pw.println("\nVertex: " + vertex);
            pw.println("\nVertex size: " + vertex.size());
            pw.println("Vertex Position " + layout.transform(ver));
            System.out.println("\nVertex: " + vertex);
            System.out.println("\nVertex size: " + vertex.size());
            System.out.println("Vertex Position " + layout.transform(ver));

            /* consider the case when mixing clusters together later */
            curComNodeCSet = flatClustToComNodeClust.get(vertex);
            pw.println("curComNodeCSet: " + curComNodeCSet);
            System.out.println("curComNodeCSet: " + curComNodeCSet);

            /* considered now if populate two tempCSet */

            while ((curComNodeCSet.size() == 1) && (curComNodeCSet.iterator().next() instanceof Set)) {
                /* for [[A,B]] set, it will terminate immediately and do not run in this loop */
                Set tmpSet = curComNodeCSet.iterator().next();
                if ((tmpSet.iterator().next() instanceof BioObject)) {
                    countBioObjSet++;
                    break;
                }
                curComNodeCSet = tmpSet;
                pw.println("curComNodeCSet: " + curComNodeCSet);
                System.out.println("curComNodeCSet: " + curComNodeCSet);
            }
            setOfComNodeCSet.add(curComNodeCSet);
        }
        /* If not all pickedSet vertex contains BioObject directly,
         * Just treat them as normal set
         * Set of one member containing BioObject is also treated normally.
         * I will not extract a member of such sets anymore
         */
        /* if not all sets contain BioObjects directly, then */
        if (countBioObjSet != vertexToProcessed.size()) {
            for (Object object : setOfComNodeCSet) {
                Set comNodeCSet = (Set) object;
                Iterator it = comNodeCSet.iterator();
                for (; it.hasNext();) {
                    Object obj = it.next();
//                    System.out.println("Obj " + obj);
                    /* TO-DO: may not be used, need to be confirmed */
                    if (obj instanceof BioObject) {
                        tempCSet.add(obj);
                        lastLevel = true;
                    } else {
                        tempCSet.add(comNodeClustToFlatClust.get(obj));
                    }

                }
                comNodeSet.addAll(comNodeCSet);
            }
        } /* Extract BioObjects of each set and mix them together to get one larger set
         */ else {
            for (Object object : setOfComNodeCSet) {
                Set comNodeCSet = (Set) object;
                /* assume that there is only one member (set of bioObj)*/
                lastLevel = true;
                Set setOfBioObj = (Set) comNodeCSet.iterator().next();
                Iterator it = setOfBioObj.iterator();
                for (; it.hasNext();) {
                    Object obj = it.next();
                    pw.println("Obj " + obj);
                    System.out.println("Obj " + obj);
                    if (obj instanceof BioObject) {
                        tempCSet.add(obj);

                    } /* TO-DO: may not be used, need to be confirmed */ else {
                        tempCSet.add(comNodeClustToFlatClust.get(obj));
                    }
                }
                comNodeSet.addAll(setOfBioObj);
            }
        }

        /* Deal with new cluster set, just leave it and build graph or re-louvain cluster it*/
        curCSet = tempCSet;
        curComNodeCSet = comNodeSet;
        curCSetBeforePropClust = curCSet;
        curComNodeCSetBeforePropClust = curComNodeCSet;

        Set<Set> cSet = tempCSet;
        if (cSet.size() < Integer.parseInt(thresholdTextField.getText())) {
            pw.println("zoom in: LCs fewer than threshold");
            System.out.println("zoom in: LCs fewer than threshold");
            GOProcessor gp = new GOProcessor();
            Set tmpSet = new HashSet();

            int counter = 0;
            do {
                pw.println("\n===================");
                pw.println("split cluster round " + counter);
                pw.println("===================\n");
                System.out.println("\n===================");
                System.out.println("split cluster round " + counter);
                System.out.println("===================\n");
                splited = false;
                overallLessThanThresh = false;
                tmpSet = splitClusters(cSet);
                if (splited) {
                    cSet = tmpSet;
                    pw.println("clusters splited!");
                    pw.println("cSet: " + cSet);
                    System.out.println("clusters splited!");
                    System.out.println("cSet: " + cSet);

                } else {
                    break;
                }
                if (overallLessThanThresh) {
                    break;
                }

//                if (tmpSet != null) {
//                    if (tmpSet == cSet)
//                        break;
//                    else{
//                        cSet = tmpSet;
//                        System.out.println("clusters splited!");
//                    }
//                }
                counter++;
                if (counter == 10) {
                    break;
                }
            } while (true);

            gp.populateGOTerms(cSet);
            curGOP = gp;
            nodesGOVectorMap.putAll(putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet)));
            if (lastLevel) {
                zoomInButton.setEnabled(false);
                pw.println("cSet: " + cSet);
                System.out.println("cSet: " + cSet);
            }
        } else {// run property based clustering because number of LCs is larger than threshold
            ArrayList retList = reLouvainCluster(curCSetBeforePropClust, false);
            cSet = (Set) retList.get(0);
            cSet = propertyBasedCluster((Set) retList.get(0), (Set) retList.get(1), null, false, true, true);
        }

        dynamicGraph = createGraph(cSet);
        usualNodeToClusterMap = new HashMap(nodeToClusterMap);

        layout = new AggregateLayout(new CircleLayout<Object, Object>(dynamicGraph));
//        ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
        ((CircleLayout) layout.getDelegate()).setRadius(0.30 * 600);
        vv.setGraphLayout(layout);

        layout = layoutGraph(layout, dynamicGraph);

        colorCluster(cSet, mainColor);
        currentLevelGraph = dynamicGraph;
        vv.repaint();
        curVertexLocMap = new HashMap<Object, Point2D>();
        for (Object ver : layout.getGraph().getVertices()) {
            curVertexLocMap.put(ver, layout.transform(ver));
        }
        curUsualVertexLocMap = new HashMap<Object, Point2D>(curVertexLocMap);

        /* Deal with search function */
        Object[] searchedListArr = new Object[listModel.size()];
        listModel.copyInto(searchedListArr);
//            System.out.println("searchedList "+searchedListArr.length);
        Set settemp = new HashSet(Arrays.asList(searchedListArr));
        Set currentVertices = new HashSet();
        for (Object obj : dynamicGraph.getVertices()) {
            if (obj instanceof Set) {
                currentVertices.addAll((Set) obj);
            } else if (obj instanceof BioObject) {
                currentVertices.add(obj);
            }
        }

        currentVertices.retainAll(settemp);
        listModel.removeAllElements();

        for (Object obj : currentVertices) {
            listModel.addElement(obj);
        }

        if ((highlightedNode != null) && vertexToProcessed.contains(highlightedNode)) {
            focusNodeBySearch(searchedBioObj);
            searchResList.setSelectedValue(searchedBioObj, true);
        }

        /* clear picked vertex state */
        Set pickedNodes = new HashSet(vertexToProcessed);
        for (Object v : pickedNodes) {
            vv.getPickedVertexState().pick(v, false);
        }

        vv.repaint();

        return true;
    }

    /**
     * Listener for double-click on vertices
     * @param <V>
     * @param <E>
     */
    public class DoubleClickZoomInPlugin<V, E> extends AbstractGraphMousePlugin
            implements MouseListener {

        public DoubleClickZoomInPlugin() {
            this(MouseEvent.BUTTON1_DOWN_MASK);
        }

        public DoubleClickZoomInPlugin(int modifier) {
            super(modifier);
        }

        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2 && !e.isConsumed()) {
                e.consume();

                final VisualizationViewer<V, E> vv = (VisualizationViewer<V, E>) e.getSource();
                final Point2D p = e.getPoint();
                GraphElementAccessor<V, E> pickSupport = vv.getPickSupport();
                if (pickSupport != null) {

                    final V vertex = pickSupport.getVertex(vv.getModel().getGraphLayout(), p.getX(), p.getY());

                    if (vertex != null) {
                        pw.println("\nVertex picked: " + vertex);
                        System.out.println("\nVertex picked: " + vertex);

                        if (vertex instanceof Set) {
                            Set toZoomInAction = new HashSet();
                            toZoomInAction.add(vertex);
                            zoomInAction(toZoomInAction);
                        }
                    }
                }

            }
        }

        public void mouseEntered(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(cursor);
        }

        public void mouseExited(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }

        public void mouseMoved(MouseEvent e) {
        }

        public void mousePressed(MouseEvent e) {
        }

        public void mouseReleased(MouseEvent e) {
        }
    }

    public AggregateLayout layoutGraph(AggregateLayout lay, Graph graph) {

//        curVertexLocMap = new HashMap<Object, Point2D>();
//        for (Object ver : layout.getGraph().getVertices()) {
//            curVertexLocMap.put(ver, layout.transform(ver));
//            System.out.println(layout.transform(ver));
//        }

//        layout = new AggregateLayout(new FRLayout<Object, Object>(dynamicGraph,new Dimension(550,550)));
//        ((FRLayout) layout.getDelegate()).setRepulsionMultiplier(2);
//        ((FRLayout) layout.getDelegate()).setAttractionMultiplier(4);

//        layout = new AggregateLayout(new FRLayout2<Object, Object>(dynamicGraph,new Dimension(550,550)));
//        ((FRLayout2) layout.getDelegate()).setRepulsionMultiplier(2);
//        ((FRLayout2) layout.getDelegate()).setAttractionMultiplier(4);


        MetaPropLengthFunction<Object> mplf = new MetaPropLengthFunction<Object>();
        mplf.setMaxWeight(maxMetaEdgeWeight);

//        layout = new AggregateLayout(new SpringLayout<Object,Object>(dynamicGraph,mplf));
//        ((SpringLayout) layout.getDelegate()).setSize(new Dimension(500,500));
////        ((SpringLayout) layout.getDelegate()).setRepulsionRange(100);
//        ((SpringLayout) layout.getDelegate()).setForceMultiplier(70000);


//        layout = new AggregateLayout(new SpringLayout2<Object,Object>(dynamicGraph,mplf));
//        ((SpringLayout2) layout.getDelegate()).setSize(new Dimension(550,550));
//        //Repulsion is exerted all the time.
//        ((SpringLayout2) layout.getDelegate()).setRepulsionRange(1000);
//        ((SpringLayout2) layout.getDelegate()).setForceMultiplier(200000);
//        ((SpringLayout2) layout.getDelegate()).setMaxWeight(maxMetaEdgeWeight);

//        layout = new AggregateLayout(new FRLayout3<Object, Object>(dynamicGraph,new Dimension(550,550)));
//        ((FRLayout3) layout.getDelegate()).setRepulsionMultiplier(2);
//        ((FRLayout3) layout.getDelegate()).setAttractionMultiplier(4);

        lay = new AggregateLayout(new NodeShapeFRLayout<Object, Object>(graph, new VertexShapeSizeAspect<Object, Object>(graph), new Dimension(550, 550)));
        ((NodeShapeFRLayout) lay.getDelegate()).setRepulsionMultiplier(1.5);
        // the less the attraction multiplier is, the more the algorithm attracts vertices together.
        ((NodeShapeFRLayout) lay.getDelegate()).setAttractionMultiplier(1);
        ((NodeShapeFRLayout) lay.getDelegate()).setMaxWeight(maxMetaEdgeWeight);

        StopWatch sw = new StopWatch();
        sw.start();
        lay.setInitializer(vv.getGraphLayout());
        lay.initialize();
        while (!lay.done()) {
            lay.step();
        }
        sw.stop();
        pw.println("Time used for multi-step layout: " + sw);
        System.out.println("Time used for multi-step layout: " + sw);
        AggregateLayout layout2 = new AggregateLayout(new StaticLayout<Object, Object>(graph, lay));
        lay = layout2;


//        layout.setInitializer(new Transformer<Object, Point2D>() {
//
//            public Point2D transform(Object arg0) {
////                System.out.println(curVertexLocMap.get(arg0));
//                return curVertexLocMap.get(arg0);
//            }
//        });


        vv.setGraphLayout(lay);
        return lay;
    }
    /* Decoration and VisualizationViewer related zone */

    /**
     * Initialize visualization viewer of JUNG
     */
    private void initVV() {
        layout = new AggregateLayout(new CircleLayout<Object, Object>(dynamicGraph));
//        ((CircleLayout) layout.getDelegate()).setRadius(0.40 * 600);
        ((CircleLayout) layout.getDelegate()).setRadius(0.20 * 600);

        vv = new VisualizationViewer<Object, Object>(layout);//,new Dimension(700, 600));
        vv.setBackground(Color.white);

//        StopWatch sw = new StopWatch();
//        sw.start();
        layout = layoutGraph(layout, dynamicGraph);
//        sw.stop();
//        pw.println("Time used for lay out graph : " + sw);
//        System.out.println("Time used for lay out graph : " + sw);

        vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
        vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW).setToIdentity();

//        layout = new AggregateLayout(new FRLayout<Object,Object>(dynamicGraph));


        curVertexLocMap = new HashMap<Object, Point2D>();
        for (Object ver : layout.getGraph().getVertices()) {
            curVertexLocMap.put(ver, layout.transform(ver));
//            System.out.println("vertex position: "+layout.transform(ver));
        }
        curUsualVertexLocMap = new HashMap<Object, Point2D>(curVertexLocMap);
//            System.out.println("vv "+vv.getSize());
//        DefaultParallelEdgeIndexFunction dpeif = DefaultParallelEdgeIndexFunction.getInstance();
//        vv.getRenderContext().setParallelEdgeIndexFunction(dpeif);

//        vv.scaleToLayout(new CrossoverScalingControl());
        vv.getRenderContext().setEdgeLabelTransformer(new EdgeLabeller(ew));

        medp = new EdgeDisplayPredicate();
//            vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line<Object,Object>());
        vv.getRenderContext().setEdgeIncludePredicate(medp);

        vv.setVertexToolTipTransformer(new NumMemberGOTips());
        vv.getRenderContext().setVertexLabelTransformer(new GOStringLabeller());
        vv.getRenderContext().setVertexFontTransformer(new VertexFontTransformer());
        vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
//            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(realGraph));

        vv.getRenderContext().setVertexFillPaintTransformer(MapTransformer.<Object, Paint>getInstance(vertexPaints));

        vv.getRenderContext().setVertexDrawPaintTransformer(new Transformer<Object, Paint>() {

            public boolean evaluateEdge(Object e) {
//            Graph<V, E> graph = context.graph;
//            if ((e instanceof MetaEdge) || (isLowestLevel)) {
                if (e instanceof MetaEdge) {
                    return true;
                }
                if (e instanceof PropertyEdge) {
                    double val = ((PropertyEdge) e).getInnerProduct();
                    EdgeDisplayPredicate edp = (EdgeDisplayPredicate) vv.getRenderContext().getEdgeIncludePredicate();
                    if ((val > 0) && (val >= edp.getThresholdForSE())) {
                        return true;
                    } else {
                        return false;
                    }

                }

                return true;
            }

            public Paint transform(Object v) {
                if (vv.getPickedVertexState().isPicked(v)) {
//                    return Color.RED;
//                    return new Color(0x003DF5); //Blue
                    return new Color(0xF5003D); //Red
//                    return new Color(0xFF70DB); //Pink
//                    return new Color(0x5CFFFF);
//                    return new Color(0xFF8533);
//                    return new Color(0xFF00FF);
//                    return new Color(0xCCFF33);
//                    return new Color(0xFF33CC);
//                    return new Color(0x33FFCC);
                } else {
                    Color forNeighbor = new Color(0xFF33CC);
                    //There are two types of edges, so getNeighbors alone is not enough.
                    for (Object w : dynamicGraph.getNeighbors(v)) {
                        for (Object e : dynamicGraph.findEdgeSet(v, w)) {
                            if (e instanceof MetaEdge) {
                                if (vv.getPickedVertexState().isPicked(w)) {
                                    return forNeighbor;
                                }
                            } else if (e instanceof PropertyEdge) {
                                if (evaluateEdge(e)) {
                                    if (vv.getPickedVertexState().isPicked(w)) {
                                        return forNeighbor;
                                    }
                                }
                            }
                        }


////                    for (Iterator iter = graph.getNeighbors(v)v.getNeighbors().iterator(); iter.hasNext(); )
////                    {
////                        Vertex w = (Vertex)iter.next();
//                    if (vv.getPickedVertexState().isPicked((V)w)) {
//                        return heavy;
//                    }
                    }
                    return Color.BLACK;
                } 
        }
        });
        vv.getRenderContext().setVertexStrokeTransformer(new VertexWeightStrokeFunction());

//        vv.getRenderContext().setEdgeDrawPaintTransformer(MapTransformer.<Object, Paint>getInstance(edgePaints));
        vv.getRenderContext().setEdgeStrokeTransformer(new EdgeWeightStrokeFunction(ew));

        vv.getRenderContext().setEdgeDrawPaintTransformer(
                new PickedEdgePaintFunction<Object, Object>(new PickableEdgePaintTransformer<Object>(vv.getPickedEdgeState(), Color.black, new Color(0xF5003D)), vv));

        DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
        vv.setGraphMouse(gm);
        gm.setMode(Mode.PICKING);
        gm.add(new DoubleClickZoomInPlugin<Object, Object>());

        gm.add(new PopupGraphMousePlugin());

        vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(dynamicGraph));
        getContentPane().add(new GraphZoomScrollPane(vv));

    }

    private void colorCluster(Set vertices, Color c) {
        for (Object v : vertices) {
            vertexPaints.put(v, c);
        }

    }

    /** Tool tip generating method.
     *  If vertex is a set, generate #nodes inside, along with list of GO terms and score.
     *  If vertex is a bioObject, generate list of GO terms and score.
     */
    public class NumMemberGOTips<V, E> implements Transformer<V, String> {

        public String transform(V vertex) {
            String res = "<html>";

            if (vertex instanceof Set) {
                res += "Num Nodes Inside: " + ((Set) vertex).size();
            }
            DataVector vec = nodesGOVectorMap.get(vertex);

            if (vec != null) {
                Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                    public int compare(Object o1, Object o2) {
                        Entry<String, Double> e1 = (Entry<String, Double>) o1;
                        Entry<String, Double> e2 = (Entry<String, Double>) o2;
                        if (e1.getValue() > e2.getValue()) {
                            return -1;
                        } else if (e1.getValue() < e2.getValue()) {
                            return 1;
                        } else {
                            return 0;
                        }
                    }
                });

                sortedMap.addAll(vec.getValueMap().entrySet());

                int i = 0;
                for (Entry entry : sortedMap) {

                    GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                    String toPrint = goTerm.getName();

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

                    DecimalFormat myFormatter = new DecimalFormat(".00");
                    String output = myFormatter.format(entry.getValue());

                    res += "<p>";
                    if (goTerm.getNamespace().equals(NameSpace.CC)) {
                        res += "<font color = #ED143F>";
                    } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                        res += "<font color = #338F06>";
                    } else {
                        res += "<font color = #3425B1>";
                    }
                    res += toPrint + " (" + output + ")";
                    res += "</font>";

                    i++;
                    /* list up to 7 terms */
                    if (i == 7) {
                        break;
                    }

                }
            } else {
                if (vertex instanceof BioObject) {
                    BioObject bio = (BioObject) vertex;
                    ArrayList<String> goidList = bio.getGoIdList();
                    int i = 0;
                    for (String s : goidList) {
                        res += "<p>" + s;// + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            }

            res += "</html>";
            return res;
        }
    }

    /** This method specify what to be written on each node
     *  If vertex is a set, write top three high-score GO terms, or else write the name of vertex.
     * It also tries to split the word at preferable position, such as split at spaces between words, etc.
     */
    public class GOStringLabeller extends ToStringLabeller {

        public String processLabeller(String st) {
            StringTokenizer stn = new StringTokenizer(st);
            ArrayList<String> arrOfSt = new ArrayList<String>();
//            System.out.println("\nNew words");
            while (stn.hasMoreTokens()) {
                arrOfSt.add(stn.nextToken());
            }
            String res = "";
            int upToNow = 0;
            int i = 0;
//            while (arrOfSt.size() > 0){
//                while (res.length()+arrOfSt.get(i).length()+1 <= 13){
            while (res.length() + arrOfSt.get(i).length() + 1 <= 10) {
                res += arrOfSt.get(i) + " ";
//                    System.out.println("token "+arrOfSt.get(i));
//                    System.out.println("res length "+res.length());
                i++;
                if (i >= arrOfSt.size()) {
                    return res;
                }
            }
//                if (res.length()+arrOfSt.get(i).length() <= 13){
            if (res.length() + arrOfSt.get(i).length() <= 10) {
                res += arrOfSt.get(i) + "<br>";
                upToNow = res.length();
//                    System.out.println("token "+arrOfSt.get(i));
//                    System.out.println("res length "+res.length());
                i++;
                if (i >= arrOfSt.size()) {
                    return res;
                }
            } else {
                if (i > 0) {
                    res += "<br>";
                    upToNow = res.length();
//                        System.out.println("res length "+res.length());
                } // first token
                else {

//                        if (arrOfSt.get(i).length() > 26) {
                    if (arrOfSt.get(i).length() > 17) {
//                            res += arrOfSt.get(i).substring(0,13)+"<br>";
                        res += arrOfSt.get(i).substring(0, 10) + "<br>";
                        upToNow = res.length();
//                            res += arrOfSt.get(i).substring(13,23)+"...";
                        res += arrOfSt.get(i).substring(10, 17) + "...";
                        return res;
                    }
//                        if (arrOfSt.get(i).length() >= 13){
                    if (arrOfSt.get(i).length() >= 10) {
//                            res += arrOfSt.get(i).substring(0,13)+"<br>";
//                            res += arrOfSt.get(i).substring(13)+" ";
                        res += arrOfSt.get(i).substring(0, 10) + "<br>";
                        upToNow = res.length();
                        res += arrOfSt.get(i).substring(10) + " ";
//                            System.out.println("token "+arrOfSt.get(i));
//                            System.out.println("res length "+res.length());
                        i++;
                        if (i >= arrOfSt.size()) {
                            return res;
                        }
                    }
                }

            }

//                if (upToNow > 13+4)
//                    upToNow = 17;
//                if (upToNow > 10+4)
//                    upToNow = 14;
//                System.out.println("upToNow "+upToNow);
//                while (((res.length()+arrOfSt.get(i).length()+1-upToNow)) <= 10){
            while (((res.length() + arrOfSt.get(i).length() + 1 - upToNow)) <= 7) {
                res += arrOfSt.get(i) + " ";
//                    System.out.println("token "+arrOfSt.get(i));
//                    System.out.println("res length "+res.length());
                i++;
                if (i >= arrOfSt.size()) {
                    return res;
                }
            }
            if (res.length() + arrOfSt.get(i).length() - upToNow <= 7) {
                res += arrOfSt.get(i);
//                    System.out.println("token "+arrOfSt.get(i));
//                    System.out.println("res length "+res.length());
                i++;
                if (i >= arrOfSt.size()) {
                    return res;
                }
            }


//                res += arrOfSt.get(i).substring(0,10+1-((res.length()-4)%13))+"...";
//                res += arrOfSt.get(i).substring(0,10-(res.length()-upToNow))+"...";
            if (res.length() - upToNow <= 7) {
                res += arrOfSt.get(i).substring(0, 7 - (res.length() - upToNow)) + "...";
            }
//                System.out.println("token "+arrOfSt.get(i));
//                System.out.println("res length "+res.length());

            return res;

//            }

        }

        @Override
        public String transform(Object v) {

            String res = "<html><center>";

            if (v instanceof Set) {
                res += "<font size=\"+1\" color=#000000>" + ((Set) v).size() + "</font>";

                DataVector vec = nodesGOVectorMap.get(v);

                if (vec != null) {

                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {

                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();
//                        String tmpSt = new String(toPrint);
//
//                        if (toPrint.length() > 26){
//                            toPrint = tmpSt.substring(0, 13);
//                            toPrint += "<br>"+tmpSt.substring(13,23)+"...";
//                        } else if (toPrint.length() > 13) {
//                            toPrint = tmpSt.substring(0, 13);
//                            toPrint += "<br>"+tmpSt.substring(13);
//                        }
                        toPrint = processLabeller(toPrint);

                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());

                        res += "<p>";
                        if (goTerm.getNamespace().equals(NameSpace.CC)) {
                            res += "<font color = #ED143F>";
                        } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                            res += "<font color = #338F06>";
                        } else {
                            res += "<font color = #3425B1>";
                        }
                        res += toPrint + "<br> (" + output + ")";
                        res += "</font>";

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

//                        DecimalFormat myFormatter = new DecimalFormat(".00");
//                        String output = myFormatter.format(entry.getValue());
//
//                        res += "<p>";
//                        if (goTerm.getNamespace().equals(NameSpace.CC))
//                            res += "<font color = #ED143F>";
//                        else if (goTerm.getNamespace().equals(NameSpace.MF))
//                            res += "<font color = #338F06>";
//                        else
//                            res += "<font color = #3425B1>";
//                        res += toPrint + " (" + output + ")";
//                        res += "</font>";
                        i++;
                        if (i == 1) {
                            break;
                        }
                    }
                    res += "</center>";
                } else {
                    res += "#Nodes: " + ((Set) v).size();
                }
            } else if (v instanceof BioObject) {
                if (((BioObject) v).getStandardName().length() != 0) {
                    res += ((BioObject) v).getStandardName();
                } else {
                    res += ((BioObject) v).getName();
                }
            }
            res += "</html>";
            return res;
        }
    }

    /**
     * File filter for modified .net pajek file
     */
    private class MNetFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("mnet")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Modified .net Pajek file";
        }
    }

    /**
     * Predicate for displaying edges
     * Whether to display edge or not depends on threshold and type of edge
     * @param <V>
     * @param <E>
     */
    private final class EdgeDisplayPredicate<V, E> implements Predicate<Context<Graph<V, E>, E>> //extends AbstractGraphPredicate<V,E>
    {

        private double thresholdForSE = .1;
        /* to be deleted in the future */
        private boolean isLowestLevel = false;

        public void setLowestLevel(boolean value) {
            isLowestLevel = value;
        }

        public double getThresholdForSE() {
            return thresholdForSE;
        }

        public void setThresholdForSE(double thresholdForSE) {
            this.thresholdForSE = thresholdForSE;
        }

        public boolean evaluate(Context<Graph<V, E>, E> context) {
//            Graph<V, E> graph = context.graph;
            E e = context.element;
//            if ((e instanceof MetaEdge) || (isLowestLevel)) {
            if (e instanceof MetaEdge) {
                return true;
            }
            if (e instanceof PropertyEdge) {
                double val = ((PropertyEdge) e).getInnerProduct();
                if ((val > 0) && (val >= thresholdForSE)) {
                    return true;
                } else {
                    return false;
                }

            }

            return true;
        }
    }

    /**
     * A method that labels edges.
     * @param <E>
     */
    private final class EdgeLabeller<E> implements Transformer<E, String> {

        protected EdgeWeightLabeller edge_weight;

        public EdgeLabeller(EdgeWeightLabeller edgeWeight) {
            this.edge_weight = edgeWeight;
        }

        public String transform(E e) {
            double value = 1;
            if (e instanceof MetaEdge) {
                value = ((MetaEdge) e).numEdgeSetBundled;
            } else if (e instanceof PropertyEdge) {
                value = ((PropertyEdge) e).getInnerProduct();
                return "" + String.format("%.3f", value);
            } else {
                value = edge_weight.getWeight(e);
            }
            if (value > 1) {
                return "" + String.format("%d", (int) value);
            } else {
                return "";
            }
        }
    }

    /**
     * A method that draw stroke for vertices
     * @param <V>
     */
    private final class VertexWeightStrokeFunction<V> implements Transformer<V, Stroke> {

        protected final Stroke basic = new BasicStroke(1);
        protected final Stroke heavy = new BasicStroke(3);
        protected final Stroke heavyPlus = new BasicStroke(5);

        public boolean evaluateEdge(Object e) {
//            Graph<V, E> graph = context.graph;
//            if ((e instanceof MetaEdge) || (isLowestLevel)) {
            if (e instanceof MetaEdge) {
                return true;
            }
            if (e instanceof PropertyEdge) {
                double val = ((PropertyEdge) e).getInnerProduct();
                EdgeDisplayPredicate edp = (EdgeDisplayPredicate) vv.getRenderContext().getEdgeIncludePredicate();
                if ((val > 0) && (val >= edp.getThresholdForSE())) {
                    return true;
                } else {
                    return false;
                }

            }

            return true;
        }

        public Stroke transform(V v) {
            if (vv.getPickedVertexState().isPicked(v)) {
                return heavyPlus;
            } else {

                //There are two types of edges, so getNeighbors alone is not enough.
                for (Object w : dynamicGraph.getNeighbors(v)) {
                    for (Object e : dynamicGraph.findEdgeSet(v, w)) {
                        if (e instanceof MetaEdge) {
                            if (vv.getPickedVertexState().isPicked(w)) {
                                return heavy;
                            }
                        } else if (e instanceof PropertyEdge) {
                            if (evaluateEdge(e)) {
                                if (vv.getPickedVertexState().isPicked(w)) {
                                    return heavy;
                                }
                            }
                        }
                    }


////                    for (Iterator iter = graph.getNeighbors(v)v.getNeighbors().iterator(); iter.hasNext(); )
////                    {
////                        Vertex w = (Vertex)iter.next();
//                    if (vv.getPickedVertexState().isPicked((V)w)) {
//                        return heavy;
//                    }
                }
            }
            if (clickedNodes != null) {
                if (centerNodeSet != null) {
                    if (clickedNodes.indexOf(v) != -1 || centerNodeSet.contains(v)) {
                        return heavyPlus;
                    }
                }
                if (clickedNodes.indexOf(v) != -1) {
                    return heavy;
                }
            }
            if (centerNodeSet != null && centerNodeSet.contains(v)) {
                return heavyPlus;
            }
            return basic;
        }
    }

    /**
     * A method that draw stroke of edges according to their weights
     * @param <E>
     */
    private final class EdgeWeightStrokeFunction<E> implements Transformer<E, Stroke> {

        float[] Dashes = {10.0F, 3.0F, 3.0F, 3.0F};
        protected final Stroke basic = new BasicStroke(1);
        protected final Stroke heavy = new BasicStroke(3);
        protected final Stroke heavy2 = new BasicStroke(6);
        protected final Stroke sBasic = new BasicStroke(1.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy = new BasicStroke(3.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy2 = new BasicStroke(4.5F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);

        ;
        protected final Stroke dotted = RenderContext.DOTTED;
        protected EdgeWeightLabeller edge_weight;
        protected Graph graph;

        public EdgeWeightStrokeFunction(EdgeWeightLabeller edge_weight) {
            this.edge_weight = edge_weight;
        }

        public Stroke transform(E e) {
            double value;
            if (e instanceof MetaEdge) {
                value = ((MetaEdge) e).getNumEdgeSetBundled();
                if (value > 7) {
                    return heavy2;
                } else if (value > 3) {
                    return heavy;
                } else {
                    return basic;
                }
            } else if (e instanceof PropertyEdge) {
                value = ((PropertyEdge) e).getInnerProduct();
                if (value > 0.8) {
                    return sHeavy2;
                } else if (value > 0.3) {
                    return sHeavy;
                } else {
                    return sBasic;
                }
            } else {
                value = edge_weight.getWeight(e);
                if (value > 7) {
                    return heavy;
                } else if (value > 3) {
                    return new BasicStroke(3);
                } else {
                    return basic;
                }

            }

        }
    }

    /**
     * Font for vertices
     */
    public class VertexFontTransformer implements Transformer<Object, Font> {

        public Font transform(Object vertex) {
            return new Font("Serif", Font.PLAIN, 13);
        }
    }

    /**
     * Tell vv how to deal with vertex shape and size
     * And generate color of vertex according to its number of BioObjs.
     * @param <V>
     * @param <E>
     */
    private final class VertexShapeSizeAspect<V, E>
            extends AbstractVertexShapeTransformer<V>
            implements Transformer<V, Shape> {

        int overallNumber = originalGraph.getVertexCount() / 12;

        public Shape transform(V v) {

            if (v instanceof BioObject) {
//                return factory.getRegularStar(v, 6);
//                return factory.getRoundRectangle(v);
//                return factory.getEllipse(v);
                return factory.getRegularPolygon(v, 6);
//                return factory.getRegularPolygon(v, 3);
            }
            return factory.getRectangle(v);

//            }
        }

        public VertexShapeSizeAspect(Graph<V, E> graphIn) {

            setSizeTransformer(new Transformer<V, Integer>() {

                public Integer transform(V v) {

                    int numMember = 0;

                    if (v instanceof Set) {
                        float[] hsbvals = new float[3];
//                        hsbvals [0.13018598, 0.9137255, 1.0]
                        numMember = ((Set) v).size();
//                        Color.RGBtoHSB(mainColor.getRed(), mainColor.getGreen(), mainColor.getBlue(), hsbvals);
//                        System.out.println("hsbvals "+Arrays.toString(hsbvals));
                        float hue = 0.13018598f, satur = (float) numMember / overallNumber, bright = 1.0f;
                        if (satur > 1) {
                            satur = 1.0f;
                        } else if (satur < 0.20) {
                            satur = 0.20f;
                        }
                        if ((clickedNodes == null || !clickedNodes.contains(v)) && (highlightedNode != v)) {
                            vertexPaints.put(v, new Color(Color.HSBtoRGB(hue, satur, bright)));
                        }

//                        numMember = ((Set)v).size();
//                        int value = (int) (Math.log10(numMember) / Math.log10(4) * 20);
//                        if (numMember == 0)
//                            return 20;
//                        else if (value < 20)
//                            return 20;
//                        else
//                            return value;
                        return 85;


                    } else {
                        return 50;
                    }
                }
            });



        }
    }

    /**
     * Draw edge color when the edge is picked
     * @param <V>
     * @param <E>
     */
    public class PickedEdgePaintFunction<V, E> implements Transformer<E, Paint> {

        private Transformer<E, Paint> defaultFunc;

        public PickedEdgePaintFunction(Transformer<E, Paint> defaultEdgePaintFunction,
                VisualizationViewer<V, E> vv) {
            this.defaultFunc = defaultEdgePaintFunction;
        }

        public Paint transform(E e) {

            if (e instanceof PropertyEdge) {
                return new Color(182, 182, 182);
            } else {
                return defaultFunc.transform(e);
            }

        }
    }

    /**
     * Deal with pop up menu when right-clicking nodes or edges on the canvas
     * Menu that will appear will change according to what are clicked. (nodes or edges or both)
     */
    protected class PopupGraphMousePlugin extends AbstractPopupGraphMousePlugin
            implements MouseListener {

        public PopupGraphMousePlugin() {
            this(MouseEvent.BUTTON3_MASK);
        }

        public PopupGraphMousePlugin(int modifiers) {
            super(modifiers);
        }

        public void openUrl(String url) {
            String os = System.getProperty("os.name");
            Runtime runtime = Runtime.getRuntime();
            try {
// Block for Windows Platform
                if (os.startsWith("Windows")) {
                    String cmd = "rundll32 url.dll,FileProtocolHandler " + url;
                    Process p = runtime.exec(cmd);
                } //Block for Mac OS
                else if (os.startsWith("Mac OS")) {
                    Class fileMgr = Class.forName("com.apple.eio.FileManager");
                    Method openURL = fileMgr.getDeclaredMethod("openURL", new Class[]{String.class});
                    openURL.invoke(null, new Object[]{url});
                } //Block for UNIX Platform
                else {
                    String[] browsers = {"firefox", "opera", "konqueror", "epiphany", "mozilla", "netscape"};
                    String browser = null;
                    for (int count = 0; count < browsers.length && browser == null; count++) {
                        if (runtime.exec(new String[]{"which", browsers[count]}).waitFor() == 0) {
                            browser = browsers[count];
                        }
                    }
                    if (browser == null) {
                        throw new Exception("Could not find web browser");
                    } else {
                        runtime.exec(new String[]{browser, url});
                    }
                }
            } catch (Exception x) {
                System.err.println("Exception occurred while invoking Browser!");
                x.printStackTrace();
            }
        }

        public void showGeneInfo(BioObject ver) throws IOException {
            if (ver.getStandardName().length() != 0) {
                openUrl("http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=search&db=gene&term=" + ver.getStandardName() + "&dispmax=50&dopt=d");
            } else {
                openUrl("http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=search&db=gene&term=" + ver.getName() + "&dispmax=50&dopt=d");
            }

        }

        public void showNodeList(Set<Object> vSet) {
            final JDialog jd = new JDialog(NaviClusterApp.this);
            jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            jd.setLocationRelativeTo(NaviClusterApp.this);

//            JTextArea jta = new JTextArea(15, 50);
//            jta.setEditable(false);

            JEditorPane editorPane = new JEditorPane();
            editorPane.setEditable(false);
            editorPane.setContentType("text/html");


            JPanel panel = new JPanel(new BorderLayout());
            jd.setContentPane(panel);
//            Container pane = jd.getContentPane();
//            panel.add(jta, BorderLayout.CENTER);

            JPanel subPanel = new JPanel();
            subPanel.add(new JLabel("Vertex List(s) with Top Score GO Term"));
            panel.add(subPanel, BorderLayout.NORTH);
//            jta.setPreferredSize(new Dimension(250, 400));

//            JScrollPane jsp = new JScrollPane(jta,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
            JScrollPane jsp = new JScrollPane(editorPane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
//            jsp.setPreferredSize(new Dimension(450, 300));
            jsp.setMinimumSize(new Dimension(450, 300));

            panel.add(jsp, BorderLayout.CENTER);
            StringBuilder stb = new StringBuilder();
            stb.append("<html>");

            int j = 0;
            for (Object ver : vSet) {
                if (ver instanceof BioObject) {
                    BioObject bioObj = (BioObject) ver;
//                    String res = "";
                    if (bioObj.getStandardName().length() != 0) {
                        stb.append("<b>" + (1 + j) + ".</b> <b>" + bioObj.getStandardName() + "</b>");
                    } else {
                        stb.append("<b>" + (1 + j) + ".</b> <b>" + bioObj.getName() + "</b>");
                    }

                    DataVector vec = nodesGOVectorMap.get(ver);

                    if (vec != null) {
                        String res = "";
                        Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                            public int compare(Object o1, Object o2) {
                                Entry<String, Double> e1 = (Entry<String, Double>) o1;
                                Entry<String, Double> e2 = (Entry<String, Double>) o2;
                                if (e1.getValue() > e2.getValue()) {
                                    return -1;
                                } else if (e1.getValue() < e2.getValue()) {
                                    return 1;
                                } else {
                                    return 0;
                                }
                            }
                        });

                        sortedMap.addAll(vec.getValueMap().entrySet());

                        int i = 0;

                        for (Entry entry : sortedMap) {

                            GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                            String toPrint = goTerm.getName();

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

                            DecimalFormat myFormatter = new DecimalFormat(".00");
                            String output = myFormatter.format(entry.getValue());

                            res += " (";
                            if (goTerm.getNamespace().equals(NameSpace.CC)) {
                                res += "<font color = #ED143F>";
                            } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                                res += "<font color = #338F06>";
                            } else {
                                res += "<font color = #3425B1>";
                            }
                            res += "" + toPrint + " (" + output + ")";
                            res += "</font>)";

                            i++;

                            if (i == 1) {
                                break;
                            }

                        }
                        stb.append(res);
                    } else {
                        if (ver instanceof BioObject) {
                            String res = "";
                            BioObject bio = (BioObject) ver;
                            ArrayList<String> goidList = bio.getGoIdList();
                            int i = 0;
                            for (String s : goidList) {
                                res += " (" + s + ") ";// + " with " + String.format("%.3f", entry.getValue());
                                i++;
                                if (i == 1) {
                                    break;
                                }
                            }
                            stb.append(res);
                        }
                    }

                } else if (ver instanceof Set) {
                    Set set = (Set) ver;
                    GOProcessor gp = new GOProcessor();
                    gp.populateGOTerms(set);
                    Map<Object, DataVector> GOVecMap = new HashMap<Object, DataVector>(putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(set)));
//                    String res = "";
                    stb.append("<b>" + (1 + j) + ".</b> Number of nodes inside: <b>" + set.size() + "</b>");
                    for (Object verInSet : set) {
                        if (verInSet instanceof BioObject) {
                            BioObject bioObj = (BioObject) verInSet;
//                    String res = "";
                            if (bioObj.getStandardName().length() != 0) {
                                stb.append("<br>- <b>" + bioObj.getStandardName() + "</b>");
                            } else {
                                stb.append("<br>- <b>" + bioObj.getName() + "</b>");
                            }

                            DataVector vec = GOVecMap.get(verInSet);
//                            DataVector vec = nodesGOVectorMap.get(verInSet);

                            if (vec != null) {
                                String res = "";
                                Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                                    public int compare(Object o1, Object o2) {
                                        Entry<String, Double> e1 = (Entry<String, Double>) o1;
                                        Entry<String, Double> e2 = (Entry<String, Double>) o2;
                                        if (e1.getValue() > e2.getValue()) {
                                            return -1;
                                        } else if (e1.getValue() < e2.getValue()) {
                                            return 1;
                                        } else {
                                            return 0;
                                        }
                                    }
                                });

                                sortedMap.addAll(vec.getValueMap().entrySet());

                                int i = 0;

                                for (Entry entry : sortedMap) {

                                    GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                                    String toPrint = goTerm.getName();

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

                                    DecimalFormat myFormatter = new DecimalFormat(".00");
                                    String output = myFormatter.format(entry.getValue());

                                    res += " (";
                                    if (goTerm.getNamespace().equals(NameSpace.CC)) {
                                        res += "<font color = #ED143F>";
                                    } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                                        res += "<font color = #338F06>";
                                    } else {
                                        res += "<font color = #3425B1>";
                                    }
                                    res += "" + toPrint + " (" + output + ")";
                                    res += "</font>)";

                                    i++;

                                    if (i == 1) {
                                        break;
                                    }

                                }
                                stb.append(res);
                            } else {
                                if (verInSet instanceof BioObject) {
                                    String res = "";
                                    BioObject bio = (BioObject) verInSet;
                                    ArrayList<String> goidList = bio.getGoIdList();
                                    int i = 0;
                                    for (String s : goidList) {
                                        res += " (" + s + ") ";// + " with " + String.format("%.3f", entry.getValue());
                                        i++;
                                        if (i == 1) {
                                            break;
                                        }
                                    }
                                    stb.append(res);
                                }
                            }
                        } else {

//                    String res = "";
                            stb.append("<br>- Unidentified Object: <b>" + verInSet.toString() + "</b>");
                        }
                    }
                }

                stb.append("<p>");
                j++;
            }
            stb.append("</html>");
            editorPane.setText(stb.toString());
            editorPane.setCaretPosition(0);
            editorPane.setPreferredSize(new Dimension(450, 300));

            JButton closeButton = new JButton("Close");
            subPanel = new JPanel();
            subPanel.add(closeButton);
            panel.add(subPanel, BorderLayout.SOUTH);
////            JOptionPane.showConfirmDialog(NaviClusterApp.this, "hey");
////            JOptionPane.showMessageDialog(NaviClusterApp.this, "hey");
            closeButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    jd.setVisible(false);

                }
            });
            jd.setPreferredSize(new Dimension(450, 385));
//            jd.setResizable(false);
            jd.pack();
            jd.setVisible(true);
        }

        public void showGOTermList(Set<Object> vSet) {
            final JDialog jd = new JDialog(NaviClusterApp.this);
            jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            jd.setLocationRelativeTo(NaviClusterApp.this);

//            JTextArea jta = new JTextArea(15, 50);
//            jta.setEditable(false);

            JEditorPane editorPane = new JEditorPane();
            editorPane.setEditable(false);
            editorPane.setContentType("text/html");


            JPanel panel = new JPanel(new BorderLayout());
            jd.setContentPane(panel);
//            Container pane = jd.getContentPane();
//            panel.add(jta, BorderLayout.CENTER);

            JPanel subPanel = new JPanel();
            subPanel.add(new JLabel("GO term list(s)"));
            panel.add(subPanel, BorderLayout.NORTH);
//            jta.setPreferredSize(new Dimension(250, 400));

//            JScrollPane jsp = new JScrollPane(jta,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
            JScrollPane jsp = new JScrollPane(editorPane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
//            jsp.setPreferredSize(new Dimension(450, 300));
            jsp.setMinimumSize(new Dimension(450, 300));

            panel.add(jsp, BorderLayout.CENTER);
            StringBuilder stb = new StringBuilder();
            stb.append("<html>");

            int j = 0;
            for (Object ver : vSet) {
                if (ver instanceof BioObject) {
                    BioObject bioObj = (BioObject) ver;
//                    String res = "";
                    if (bioObj.getStandardName().length() != 0) {
                        stb.append("<b>" + (1 + j) + ".</b> <b>" + bioObj.getStandardName() + "</b>");
                    } else {
                        stb.append("<b>" + (1 + j) + ".</b> <b>" + bioObj.getName() + "</b>");
                    }

                } else if (ver instanceof Set) {
                    Set set = (Set) ver;
//                    String res = "";
                    stb.append("<b>" + (1 + j) + ".</b> Number of nodes inside: <b>" + set.size() + "</b>");
                }


                DataVector vec = nodesGOVectorMap.get(ver);

                if (vec != null) {
                    String res = "";
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
                            }
                        }
                    });

                    sortedMap.addAll(vec.getValueMap().entrySet());

                    int i = 0;

                    for (Entry entry : sortedMap) {

                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());

                        res += "<br>- ";
                        if (goTerm.getNamespace().equals(NameSpace.CC)) {
                            res += "<font color = #ED143F>";
                        } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                            res += "<font color = #338F06>";
                        } else {
                            res += "<font color = #3425B1>";
                        }
                        res += "" + toPrint + " (" + output + ")";
                        res += "</font>";

                        i++;
                        /* list up to 7 terms */
                        if (i == 10) {
                            break;
                        }

                    }
                    stb.append(res);
                } else {
                    if (ver instanceof BioObject) {
                        String res = "";
                        BioObject bio = (BioObject) ver;
                        ArrayList<String> goidList = bio.getGoIdList();
                        int i = 0;
                        for (String s : goidList) {
                            res += "<br>- " + s;// + " with " + String.format("%.3f", entry.getValue());
                            i++;
                            if (i == 5) {
                                break;
                            }
                        }
                        stb.append(res);
                    }
                }


                stb.append("<p>");
                j++;
            }
            stb.append("</html>");
            editorPane.setText(stb.toString());
            editorPane.setCaretPosition(0);
            editorPane.setPreferredSize(new Dimension(450, 300));

            JButton closeButton = new JButton("Close");
            subPanel = new JPanel();
            subPanel.add(closeButton);
            panel.add(subPanel, BorderLayout.SOUTH);

            closeButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    jd.setVisible(false);

                }
            });
            jd.setPreferredSize(new Dimension(450, 385));
//            jd.setResizable(false);
            jd.pack();
            jd.setVisible(true);

        }

        protected void showEdgesDetail(Set<Object> eSet) {
            final JDialog jd = new JDialog(NaviClusterApp.this);
            jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            jd.setLocationRelativeTo(NaviClusterApp.this);

//            JTextArea jta = new JTextArea(15, 50);
//            jta.setEditable(false);

            JEditorPane editorPane = new JEditorPane();
            editorPane.setEditable(false);
            editorPane.setContentType("text/html");


            JPanel panel = new JPanel(new BorderLayout());
            jd.setContentPane(panel);
//            Container pane = jd.getContentPane();
//            panel.add(jta, BorderLayout.CENTER);
            JPanel subPanel = new JPanel();
            subPanel.add(new JLabel("Edge details"));
            panel.add(subPanel, BorderLayout.NORTH);
//            jta.setPreferredSize(new Dimension(250, 400));

//            JScrollPane jsp = new JScrollPane(jta,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
            JScrollPane jsp = new JScrollPane(editorPane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
//            jsp.setPreferredSize(new Dimension(450, 300));
            jsp.setMinimumSize(new Dimension(450, 300));

            panel.add(jsp, BorderLayout.CENTER);
            StringBuilder stb = new StringBuilder();
            stb.append("<html>");

            int j = 0;
            for (Object edge : eSet) {
                Pair pair = vv.getGraphLayout().getGraph().getEndpoints(edge);
                Object firstNode = pair.getFirst();
                Object secondNode = pair.getSecond();
                String fString = "", sString = "";
                if (firstNode instanceof Set) {
                    fString += "Metanode (" + ((Set) firstNode).size() + " nodes)";
                } else if (firstNode instanceof BioObject) {
                    fString += firstNode.toString();
                }
                if (secondNode instanceof Set) {
                    sString += "Metanode (" + ((Set) secondNode).size() + " nodes)";
                } else if (secondNode instanceof BioObject) {
                    sString += secondNode.toString();
                }
                if (edge instanceof MetaEdge) {
                    MetaEdge metaedge = (MetaEdge) edge;
//                    String res = "";

                    stb.append("<b>" + (1 + j) + ".</b> Metaedge: <b>" + fString + "</b> &lt;--> <b>" + sString + "</b>");
                    stb.append("<br>- <b>" + metaedge.getNumEdgeSetBundled() + "</b> edges bundled");
                    for (Object bundEdge : metaedge.getEdgeSetBundled()) {
                        stb.append("<br>&nbsp;&nbsp;&nbsp;- " + realGraph.getEndpoints(bundEdge).getFirst() + " &lt;--> " + realGraph.getEndpoints(bundEdge).getSecond());
                    }

                } else if (edge instanceof PropertyEdge) {
                    PropertyEdge propedge = (PropertyEdge) edge;
                    stb.append("<b>" + (1 + j) + ".</b> Property edge: <b>" + fString + "</b> &lt;--> <b>" + sString + "</b>");
                    stb.append("<br>- Weight = <b>" + String.format("%.5f", propedge.getInnerProduct()) + "</b>");

                    Set toPrintGOSet = new HashSet();
                    toPrintGOSet.add(firstNode);
                    toPrintGOSet.add(secondNode);

                    int k = 0;
                    for (Object forVec : toPrintGOSet) {
                        if (k == 0) {
                            stb.append("<br>&nbsp;&nbsp;&nbsp;- <b>" + fString + "</b>'s GO terms:");
                        } else {
                            stb.append("<br>&nbsp;&nbsp;&nbsp;- <b>" + sString + "</b>'s GO terms:");
                        }
                        k++;
                        DataVector vec = nodesGOVectorMap.get(forVec);

                        if (vec != null) {
                            String res = "";
                            Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                                public int compare(Object o1, Object o2) {
                                    Entry<String, Double> e1 = (Entry<String, Double>) o1;
                                    Entry<String, Double> e2 = (Entry<String, Double>) o2;
                                    if (e1.getValue() > e2.getValue()) {
                                        return -1;
                                    } else if (e1.getValue() < e2.getValue()) {
                                        return 1;
                                    } else {
                                        return 0;
                                    }
                                }
                            });

                            sortedMap.addAll(vec.getValueMap().entrySet());

                            int i = 0;

                            for (Entry entry : sortedMap) {

                                GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                                String toPrint = goTerm.getName();

//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }

                                DecimalFormat myFormatter = new DecimalFormat(".00");
                                String output = myFormatter.format(entry.getValue());

                                res += "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- ";
                                if (goTerm.getNamespace().equals(NameSpace.CC)) {
                                    res += "<font color = #ED143F>";
                                } else if (goTerm.getNamespace().equals(NameSpace.MF)) {
                                    res += "<font color = #338F06>";
                                } else {
                                    res += "<font color = #3425B1>";
                                }
                                res += "" + toPrint + " (" + output + ")";
                                res += "</font>";

                                i++;
                                /* list up to 7 terms */
                                if (i == 10) {
                                    break;
                                }

                            }
                            stb.append(res);
                        } else {
                            if (forVec instanceof BioObject) {
                                String res = "";
                                BioObject bio = (BioObject) forVec;
                                ArrayList<String> goidList = bio.getGoIdList();
                                int i = 0;
                                for (String s : goidList) {
                                    res += "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- " + s;// + " with " + String.format("%.3f", entry.getValue());
                                    i++;
                                    if (i == 5) {
                                        break;
                                    }
                                }
                                stb.append(res);
                            }
                        }
                    }

//                    Set set = (Set) ver;
////                    String res = "";
//                    stb.append((1 + j) + ". Number of nodes inside: <b><font size=+1>" + set.size() + "</font></b>");
                } else if (edge instanceof SGDInteraction) {
                    SGDInteraction sgdint = (SGDInteraction) edge;
                    stb.append("<b>" + (1 + j) + ".</b> Yeast SGD interaction: <b>" + fString + "</b> &lt;--> <b>" + sString + "</b>");
                    stb.append("<br>- Number of evidences = <b>" + sgdint.getNumEvidence() + "</b>");
                } else {
                    stb.append("<b>" + (1 + j) + ".</b> Edge: <b>" + fString + "</b> &lt;--> <b>" + sString + "</b>");
                    stb.append("<br>- Weight = <b>" + ew.getWeight(edge) + "</b>");
                }
                stb.append("<br><i>Other edge(s) between these two entities: </i>");
                Collection edgeCol = vv.getGraphLayout().getGraph().findEdgeSet(firstNode, secondNode);
                boolean have = false;
                for (Object concurEdge : edgeCol) {
                    if (!concurEdge.equals(edge)) {
                        if (concurEdge instanceof MetaEdge) {
                            have = true;
                            stb.append("<br>- Metaedge (<b>" + ((MetaEdge) concurEdge).getNumEdgeSetBundled() + "</b> edges bundled)");
                        } else if (concurEdge instanceof PropertyEdge) {
                            have = true;
                            stb.append("<br>- Property Edge (weight = <b>" + String.format("%.5f", ((PropertyEdge) concurEdge).getInnerProduct()) + "</b>)");
                        } else if (concurEdge instanceof SGDInteraction) {
                            have = true;
                            stb.append("<br>- Number of evidences = <b>" + ((SGDInteraction) concurEdge).getNumEvidence() + "</b>");
                        } else {
                            have = true;
                            stb.append("<br>- Weight = <b>" + ew.getWeight(concurEdge) + "</b>");
                        }
                    }
                }
                if (!have) {
                    stb.append("<b>None</b>");
                }

                stb.append("<p>");
                j++;
            }
            stb.append("</html>");
            editorPane.setText(stb.toString());
            editorPane.setCaretPosition(0);
//            editorPane.setPreferredSize(new Dimension(450,300));

            JButton closeButton = new JButton("Close");
            subPanel = new JPanel();
            subPanel.add(closeButton);
            panel.add(subPanel, BorderLayout.SOUTH);
////            JOptionPane.showConfirmDialog(NaviClusterApp.this, "hey");
////            JOptionPane.showMessageDialog(NaviClusterApp.this, "hey");
            closeButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    jd.setVisible(false);

                }
            });
            jd.setPreferredSize(new Dimension(450, 385));
            jd.pack();
//            jd.setResizable(false);
            jd.setVisible(true);
        }

        @SuppressWarnings("unchecked")
        protected void handlePopup(MouseEvent e) {
            final VisualizationViewer<Object, Object> vv =
                    (VisualizationViewer<Object, Object>) e.getSource();
            Point2D p = e.getPoint();
            
            boolean handledOnSite = false;
            GraphElementAccessor<Object, Object> pickSupport = vv.getPickSupport();
            if (pickSupport != null) {
                final Object v = pickSupport.getVertex(vv.getGraphLayout(), p.getX(), p.getY());
                /* Vertex is picked */
                if (v != null) {
                    handledOnSite = true;
                    JPopupMenu popup = new JPopupMenu();
                    final Set<Object> verSet = new HashSet();
                    verSet.add(v);

                    popup.add(new AbstractAction("Top 10 GO Terms List") {

                        public void actionPerformed(ActionEvent e) {
                            showGOTermList(verSet);

                            vv.repaint();
                        }
                    });
                    if (!(v instanceof BioObject)) {
                        popup.add(new AbstractAction("Vertex List(s) w/ Top Score GO") {

                            public void actionPerformed(ActionEvent e) {
                                showNodeList(verSet);

                                vv.repaint();
                            }
                        });
                    }
                    if (v instanceof BioObject) {
                        popup.add(new AbstractAction("NCBI Gene Information") {

                            public void actionPerformed(ActionEvent e) {
                                try {
                                    showGeneInfo((BioObject) v);
                                } catch (IOException ex) {
                                    Logger.getLogger(NaviClusterApp.class.getName()).log(Level.SEVERE, null, ex);
                                }

                                vv.repaint();
                            }
                        });
                    }
                    popup.show(vv, e.getX(), e.getY());
                } else {
                    /* edge is picked */
                    final Object edge = pickSupport.getEdge(vv.getGraphLayout(), p.getX(), p.getY());
                    if (edge != null) {
                        handledOnSite = true;
                        final Set<Object> edgeSet = new HashSet();
                        edgeSet.add(edge);
                        JPopupMenu popup = new JPopupMenu();
                        popup.add(new AbstractAction("View Edge Detail") {

                            public void actionPerformed(ActionEvent e) {
                                showEdgesDetail(edgeSet);
//                        System.err.println("got " + edge);
                                }
                        });
                        popup.show(vv, e.getX(), e.getY());

                    }
                }
            }
            if (!handledOnSite) {
                final Set<Object> vSet = vv.getPickedVertexState().getPicked();
                final Set<Object> eSet = vv.getPickedEdgeState().getPicked();
                if (vSet.size() != 0 && eSet.size() != 0) {
                } else if (vSet.size() != 0) {
                    /* vertices are picked */
                    JPopupMenu popup = new JPopupMenu();
                    popup.add(new AbstractAction("Top 10 GO Terms List(s)") {

                        public void actionPerformed(ActionEvent e) {
                            showGOTermList(vSet);
                            vv.repaint();
                        }
                    });
                    if (vSet.size() > 1 || (vSet.size() == 1 && !(vSet.iterator().next() instanceof BioObject))) {
                        popup.add(new AbstractAction("Vertex List(s) w/ Top Score GO") {

                            public void actionPerformed(ActionEvent e) {
                                showNodeList(vSet);
                                vv.repaint();
                            }
                        });
                    }
                    if (vSet.size() == 1) {
                        final Object ver = vSet.iterator().next();
                        if (ver instanceof BioObject) {
                            popup.add(new AbstractAction("NCBI Gene Information") {

                                public void actionPerformed(ActionEvent e) {
                                    try {
                                        showGeneInfo((BioObject) ver);
                                    } catch (IOException ex) {
                                        Logger.getLogger(NaviClusterApp.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    vv.repaint();
                                }
                            });
                        }
                    }
                    popup.show(vv, e.getX(), e.getY());
                } else if (eSet.size() != 0) {
                    /* edges are picked */
                    JPopupMenu popup = new JPopupMenu();
                    popup.add(new AbstractAction("View Edge Detail") {

                        public void actionPerformed(ActionEvent e) {
                            showEdgesDetail(eSet);
//                        System.err.println("got " + edge);
                        }
                    });
                    popup.show(vv, e.getX(), e.getY());
                }
            }
//            else {
//
//            }


        }
    }
}




