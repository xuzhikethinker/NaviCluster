/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package main;

/**
 *
 * @author Knacky
 */
import edu.uci.ics.jung.algorithms.layout.AggregateLayout;
import edu.uci.ics.jung.algorithms.layout.CircleLayout;
import edu.uci.ics.jung.algorithms.layout.FRLayout;
import edu.uci.ics.jung.algorithms.layout.GraphElementAccessor;
import edu.uci.ics.jung.algorithms.layout.ISOMLayout;
import edu.uci.ics.jung.algorithms.layout.KKLayout;
import edu.uci.ics.jung.algorithms.layout.Layout;

import edu.uci.ics.jung.algorithms.layout.SpringLayout;
import edu.uci.ics.jung.algorithms.layout.SpringLayout2;
import edu.uci.ics.jung.algorithms.layout.StaticLayout;
import edu.uci.ics.jung.algorithms.layout.util.Relaxer;
import edu.uci.ics.jung.algorithms.layout.util.VisRunner;


import edu.uci.ics.jung.algorithms.util.IterativeContext;
import edu.uci.ics.jung.graph.Graph;


import edu.uci.ics.jung.graph.SparseMultigraph;

import edu.uci.ics.jung.graph.util.Context;
import edu.uci.ics.jung.graph.util.DefaultParallelEdgeIndexFunction;
import edu.uci.ics.jung.graph.util.Pair;

import edu.uci.ics.jung.visualization.GraphZoomScrollPane;

import edu.uci.ics.jung.visualization.RenderContext;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.AbstractGraphMousePlugin;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;

import edu.uci.ics.jung.visualization.decorators.AbstractVertexShapeTransformer;
import edu.uci.ics.jung.visualization.decorators.EdgeWeightLabeller;
import edu.uci.ics.jung.visualization.decorators.PickableEdgePaintTransformer;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.layout.LayoutTransition;
import edu.uci.ics.jung.visualization.renderers.Renderer;
import edu.uci.ics.jung.visualization.subLayout.GraphCollapser;
import edu.uci.ics.jung.visualization.util.Animator;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileFilter;
import kmean.DataCluster;
import kmean.DataVector;
import kmean.KMeanClusterer;
import org.apache.commons.collections15.Factory;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.collections15.Transformer;
import org.apache.commons.collections15.functors.ConstantTransformer;
import org.apache.commons.collections15.functors.MapTransformer;
import org.apache.commons.collections15.map.LazyMap;

import util.StopWatch;
import org.geneontology.oboedit.datamodel.OBOSession;




/**
 *
 * @author Knacky
 */
public class LouvainClustererTest_1 extends JFrame {

    private boolean UIWanted;
    private String stringStream = "";
    private boolean isWeightGraph = false;
    private int[] sArr = null;
    private int[] dArr = null;
    private double[] wArr = null;
//    private static final Object DEMOKEY = "DEMOKEY";
    VisualizationViewer<Object, Object> vv;//	Factory<Graph<Number,Number>> graphFactory;
    Map<Object, Paint> vertexPaints =
            LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.white));
    Map<Object, Paint> edgePaints =
            LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.BLACK));
    Map<Integer, BioObject> nodeMap = new HashMap<Integer, BioObject>();
    public final Color[] similarColors = {
        new Color(216, 134, 134),
        new Color(135, 137, 211),
        new Color(134, 206, 189),
        new Color(206, 176, 134),
        new Color(194, 204, 134),
        new Color(145, 214, 134),
        new Color(133, 178, 209),
        new Color(103, 148, 255),
        new Color(60, 220, 220),
        new Color(30, 250, 100)
    };
    public Color mainColor = new Color(255,204,22);
    public Color peripheralColor = new Color(0xF6FEAC);
    public Color bioObjColor = new Color(145, 214, 134);
//    public Color searchedColor = new Color(135,137,211);
    public Color searchedColor = new Color(0xECA3AE);
//    public Color mainColor = new Color(138,240,87);
//    public Color mainColor = new Color(153,255,102);

    private static Class<? extends Layout>[] getLayoutCombos()
    {
        List<Class<? extends Layout>> layouts = new ArrayList<Class<? extends Layout>>();
        layouts.add(KKLayout.class);
        layouts.add(FRLayout.class);
        layouts.add(CircleLayout.class);
        layouts.add(SpringLayout.class);
        layouts.add(SpringLayout2.class);
        layouts.add(ISOMLayout.class);
        return layouts.toArray(new Class[0]);
    }
    
    public static void main(String[] args) {
//        KleinbergSmallWorldGenerator kg = new KleinbergSmallWorldGenerator(6, 2.5);
//        Graph realGraph;
//        realGraph = (Graph) kg.generateGraph();
//        System.out.println("num node: " + realGraph.numVertices() + " num edge: " + realGraph.numEdges());

//        // Add a restart button so the realGraph can be redrawn to fit the size of the frame
        LouvainClustererTest test = new LouvainClustererTest();
//        test.setName("Interactive Bio Graph Explorer");
        test.setTitle("Interactive Bio Graph Explorer");

        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        test.start();

        test.pack();
//        test.setLocationByPlatform(true);
        test.setVisible(true);


    }
    private double threshold;
    private EdgeDisplayPredicate medp;
    private EdgeWeightLabeller ew;

    public Graph<Object, Object> loadModNet(BufferedReader br) throws IOException {

//        int tNumLinks = 0;
        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1, numNode = -1;


        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        BioObject bioObj = null;
//        if (UIWanted){
//            StringLabeller sl = StringLabeller.getLabeller(newgraph,"node name");
//        EdgeWeightLabeller ew = EdgeWeightLabeller.getLabeller(newgraph,"weight");
        //check header
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Vertices")) {
                    numNode = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        int id = -1;
        String stdName = "", name = "", sgdid = "", type = "";
        String goId = "", ref = "", aspect = "";
        StopWatch sw = new StopWatch();
        sw.start();
        for (int i = 0; i < numNode; i++) {
//        while ((st = br.readLine()) != null){
            st = br.readLine();
//            System.out.println(st);
            stn = new StringTokenizer(st, "\t", true);
            assert (stn.hasMoreTokens());
            id = Integer.parseInt(stn.nextToken());
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            stdName = stn.nextToken();
            if (stdName.equals("\t")) {
                stdName = "";
            } else {
                stn.nextToken();
            }

            assert (stn.hasMoreTokens());
            name = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            sgdid = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            if (sgdid.equals("\t")) {
                bioObj = new BioObject(id, name);
                bioObj.setStandardName(stdName);
            } else {
//                assert (stn.hasMoreTokens());
//                sgdid = stn.nextToken();
//                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                type = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                goId = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                ref = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                aspect = stn.nextToken();
//            if (stn.nextToken().equals("\t"));


                bioObj = new BioObject(id, sgdid, name);
                bioObj.setStandardName(stdName);
                bioObj.setType(type);

                StringTokenizer stz = new StringTokenizer(goId, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getGoIdList().add(stz.nextToken());
                }


//                System.out.println(ref);
                stz = new StringTokenizer(ref, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getRefList().add(stz.nextToken());
                }

                stz = new StringTokenizer(aspect, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getAspectList().add(stz.nextToken());
                }
            }
            newgraph.addVertex(bioObj);
            nodeMap.put(id, bioObj);
        }
        sw.stop();
        System.out.println("load vertices time: "+sw);
        sw.start();
        int numEdge = -1;
        //check header
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Edges")) {
                    numEdge = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        
//        StringBuilder stb = new StringBuilder(10000);
        
        sArr = new int[numEdge];
        dArr = new int[numEdge];
        wArr = new double[numEdge];
        boolean isWeight = false;
        
        ew = new EdgeWeightLabeller<Number>();
        for (int i = 0; i < numEdge; i++) {
//        while ((st = br.readLine()) != null) {
            st = br.readLine();
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());

//            stb.append(src).append("\t").append(dest).append("\t");
            sArr[i] = src; dArr[i] = dest;
//            Number vSrc = null,vDest = null;
//            newgraph.addVertex(src);
//            newgraph.addVertex(dest);

//            System.out.println("src: "+src+" dest: "+dest);
            String e1 = src + ":" + dest;
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
//                stringStream += weight;
//                stb.append(weight);
                wArr[i] = weight;
                ew.setWeight(e1, weight);
                isWeight = true;
            }
//            stringStream += "\n";
//            stb.append("\n");

            newgraph.addEdge(e1, nodeMap.get(src), nodeMap.get(dest));
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));

        }
        sw.stop();
//        stringStream = stb.toString();
        if (!isWeight){
            wArr = null;
        }
        isWeightGraph = isWeight;
        System.out.println("Load edges time: "+sw);
        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
        System.out.println("Num nodes double checked: " + numNode + " Num edges double checked: " + numEdge);
//        }

//        System.out.println(newgraph.getEdges());
        return newgraph;
//        return null;
    }

    public Graph<Object, Object> load(BufferedReader br) throws IOException {

//        int tNumLinks = 0;
        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1;


        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();

//        if (UIWanted){
//            StringLabeller sl = StringLabeller.getLabeller(newgraph,"node name");
//        EdgeWeightLabeller ew = EdgeWeightLabeller.getLabeller(newgraph,"weight");
        ew = new EdgeWeightLabeller<Number>();

        while ((st = br.readLine()) != null) {
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
//            Number vSrc = null,vDest = null;
            newgraph.addVertex(src);
            newgraph.addVertex(dest);

//            System.out.println("src: "+src+" dest: "+dest);
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
            }
            String e1 = src + ":" + dest;
            newgraph.addEdge(e1, src, dest);


            ew.setWeight(e1, weight);

        }

        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
//        }

        return newgraph;

    }
//    String filename = "src/karate";
//    String filename = "/Users/Knacky/NetBeansProjects/BlondelAlgorithm/src/input";
//    String filename = "expmore3.mnet";
//    String filename = "refmore3.mnet";
    String filename = "curmore2.mnet";
//    String filename = "..\\BlondelAlgorithm\\src\\input";
//        String filename = "src/arxiv";
//        String filename = "src/kl265";s
//        String filename = "src/example";       
//        String filename = "src/temp2";
    /*Yeast SGD Data Set*/
//        String filename = "src/all_yeast_intdata.txt";
//          String filename = "src/all_yeast_intdata_noself";
//        String filename = "src/RefMore3intdata";
//        String filename = "src/ExpMore3intdata";
//          String filename = "src/IntMore1intdata";
//          String filename = "src/CurMore1intdata";
//          String filename = "src/CurHighintdata";
//          String filename = "src/CurManintdata";
//        String filename = "src/ItoT_intdata";
    File fileToOpen = null;
    Graph<Object, Object> realGraph, originalGraph;
    Graph dynamicGraph,currentLevelGraph;
    AggregateLayout<Object, Object> layout;
    GraphCollapser collapser;
    JButton collapseButton;
    JButton expandButton;
    JButton zoomInButton;
    JButton zoomOutButton;
//    @Override
    public void start() {
        threshold = 0.000001;

//        UIWanted = false;
        UIWanted = true;
//        File f = new File("src/input.txt");
//        File f = new File("src/ItoT_intdata.net");
//        File f = new File(filename+".net");
//        File f = new File("src/example.net");
//        System.out.println(f.getAbsolutePath());

//        System.out.println(f.getAbsolutePath());

        Factory<Object> vertexFactory = new Factory<Object>() {

            int n = 0;

            public Number create() {
                return n++;
            }
        };
        Factory<Object> edgeFactory = new Factory<Object>() {

            int n = 0;

            public String create() {
                return "" + (n++);
            }
        };


        try {
//            JFileChooser fileChooser = new JFileChooser(new File(filename + ".txt"));
//            fileChooser.setAcceptAllFileFilterUsed(false);
//            fileChooser.addChoosableFileFilter(new TextFileFilter());

//            System.out.println(new File(filename+".txt").getPath());
//            fileChooser.showOpenDialog(LouvainClustererTest.this);
//            fileToOpen = fileChooser.getSelectedFile();
            fileToOpen = new File(filename);
            if (fileToOpen == null) {
                fileToOpen = new File(filename + ".txt");

            }
            System.out.println(fileToOpen.getName());
//            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
//            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filename+".txt"))));
            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));


//            PajekNetReader<Graph<Object, Object>, Object, Object> pnr =
//                    new PajekNetReader<Graph<Object, Object>, Object, Object>(vertexFactory, edgeFactory);

            realGraph = new SparseMultigraph<Object, Object>();

            StopWatch loadingTime = new StopWatch();
            loadingTime.start();

//            Graph realGraph = pnr.load(br);
//            pnr.load(br, realGraph);
//            realGraph = load(br);
            realGraph = loadModNet(br);
            originalGraph = realGraph;
            dynamicGraph = realGraph;
            currentLevelGraph = dynamicGraph;
            loadingTime.stop();
            System.out.println("Loading Time: " + loadingTime);
            collapser = new GraphCollapser(realGraph);
//            System.out.println("After loading");

//            System.exit(0);
//            realGraph = DirectionTransformer.toUndirected((Graph)realGraph);
//            realGraph = new SparseGraph();

//            int numnode = 305;//1462
//            int numedge = 6942;
            int numnode = 928;//2708
            int numedge = 7120;
//            int numnode = 2928;//2708
//            int numedge = 10000;
//            int numedgeperstep = 6;
            int numedgeperstep = 4;
//            int numedgeperstep = 4;

            /*Generate Graph using models*/
//            BarabasiAlbertGenerator ba = new BarabasiAlbertGenerator(numnode, numedgeperstep);
//            KleinbergSmallWorldGenerator kg = new KleinbergSmallWorldGenerator(10, 2.5);
//            realGraph.getEdgeConstraints().add(Graph.UNDIRECTED_EDGE);
//            realGraph = DirectionTransformer.toUndirected((Graph)kg.generateGraph());
//            StopWatch baGenTime= new StopWatch();
//            baGenTime.start();
//            realGraph = (Graph)ba.generateGraph();
//            ba.evolveGraph((int)numedge/numedgeperstep);
//            baGenTime.stop();
//            System.out.println("BA Gen Time: "+baGenTime);
//            PajekNetWriter pnw = new PajekNetWriter();
//            pnw.save(realGraph, "ba2708_7120_step4.out");
//           
//            System.exit(0);
            
//            final SubLayoutDecorator layout = new SubLayoutDecorator(new FRLayout(realGraph));
//            layout = new AggregateLayout<Object, Object>(new FRLayout<Object, Object>(realGraph));
//            layout = new AggregateLayout<Object, String>(new SpringLayout<Object, String>(realGraph));
            layout = new AggregateLayout<Object, Object>(new CircleLayout<Object, Object>(realGraph));
//            ModSpringLayout1 ml = new ModSpringLayout1<Object,Object>(realGraph);
//            layout = new AggregateLayout<Object, Object>(ml);
//            layout = new AggregateLayout<Object, Object>(new SpringLayout<Object, Object>(realGraph));
//            layout = new AggregateLayout<Object, Object>(new FRLayout<Object, Object>(realGraph));
            
//            layout.setSize(new Dimension(350,350));
            ((CircleLayout)layout.getDelegate()).setRadius(0.40*600);
            
            
            
            System.out.println(layout.getClass());
//            System.out.println("After layout");

            vv = new VisualizationViewer<Object, Object>(layout);//,new Dimension(700, 600));
            System.out.println(vv.getModel().getGraphLayout().getClass());
//            System.out.println("size "+((CircleLayout)layout.getDelegate()).getSize());
//            System.out.println("radius "+((CircleLayout)layout.getDelegate()).getRadius());
            vv.setBackground(Color.white);
            clusterAndRecolor(layout, similarColors, true);
            
//            ((ModSpringLayout1)layout.getDelegate()).setLengthFunction(new LengthFunctionBySize(30,dynamicGraph));
            
//            System.out.println("vv "+vv.getSize());
            DefaultParallelEdgeIndexFunction dpeif = DefaultParallelEdgeIndexFunction.getInstance();
            vv.getRenderContext().setParallelEdgeIndexFunction(dpeif);
            medp = new EdgeDisplayPredicate();
//            vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line<Object,Object>());
            vv.getRenderContext().setEdgeLabelTransformer(new EdgeLabeller(ew));
            vv.getRenderContext().setEdgeIncludePredicate(medp);
            //Tell the renderer to use our own customized color rendering
            
            vv.setVertexToolTipTransformer(new NumMemberGOTips());
            vv.getRenderContext().setVertexLabelTransformer(new GOStringLabeller()); 
            vv.getRenderContext().setVertexFontTransformer(new VertexFontTransformer());
            vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
//            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(realGraph));

            vv.getRenderContext().setVertexFillPaintTransformer(MapTransformer.<Object, Paint>getInstance(vertexPaints));
            vv.getRenderContext().setVertexDrawPaintTransformer(new Transformer<Object, Paint>() {

                public Paint transform(Object v) {
                    if (vv.getPickedVertexState().isPicked(v)) {
                        return Color.cyan;
                    } else {
                        return Color.BLACK;
                    }
                }
            });

            vv.getRenderContext().setEdgeDrawPaintTransformer(MapTransformer.<Object, Paint>getInstance(edgePaints));

            vv.getRenderContext().setEdgeStrokeTransformer(new EdgeWeightStrokeFunction(ew));
            vv.getRenderContext().setEdgeDrawPaintTransformer( 
                    new PickedEdgePaintFunction<Object,Object>( new PickableEdgePaintTransformer<Object>( vv.getPickedEdgeState(),Color.black,Color.cyan), vv));

            JButton openFile = new JButton("Open");
            openFile.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
//                    File ff = new File("../NetBeansProjects/BlondelAlgorithm/src");
//                    System.out.println(ff.getPath());
                    JFileChooser fileChooser = new JFileChooser(fileToOpen);
                    File tempFile = fileToOpen;
//                    fileChooser.addChoosableFileFilter(new TextFileFilter());
                    fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                    fileChooser.setFileFilter(new MNetFileFilter());
//                    fileChooser.setFileHidingEnabled(false);
                    fileChooser.showOpenDialog(LouvainClustererTest.this);
                    fileToOpen = fileChooser.getSelectedFile();
                    if (fileToOpen != null) {
                        try {
                            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));
                            StopWatch loadingTime  = new StopWatch();
                            loadingTime.start();
//                            realGraph = load(br);
                            realGraph = loadModNet(br);
                            loadingTime.stop();
                            System.out.println("Loading Time: " + loadingTime);
                            originalGraph = realGraph;
//                            layout.setGraph(realGraph);
                            dynamicGraph = realGraph;
                            currentLevelGraph = dynamicGraph;
                            
                            vv.setGraphLayout(layout);
                            clusterAndRecolor(layout, similarColors, true);
                            vv.getRenderContext().getParallelEdgeIndexFunction().reset();

                            layout.initialize();
                            Relaxer relaxer = vv.getModel().getRelaxer();
                            if (relaxer != null) {
                                relaxer.stop();
                                relaxer.prerelax();
                                relaxer.relax();
                            }
                            currentLevel = 0;
                            zoomInButton.setEnabled(true);
                            zoomOutButton.setEnabled(false);


                        } catch (IOException ex) {
                            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    } else {
                        fileToOpen = tempFile;
                    }
                }
            });


            JButton saveButton = new JButton("Save");
            saveButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    JFileChooser chooser = new JFileChooser(new File("/Users/Knacky/Desktop"));
//                    chooser.setAcceptAllFileFilterUsed(false);
                    int option = chooser.showSaveDialog(LouvainClustererTest.this);

                    if (option == JFileChooser.APPROVE_OPTION) {
                        File file = chooser.getSelectedFile();
                        int width = vv.getWidth();
                        int height = vv.getHeight();

                        BufferedImage bi = new BufferedImage(width, height,
                                BufferedImage.TYPE_INT_RGB);
                        Graphics2D graphics = bi.createGraphics();
                        vv.paint(graphics);
                        graphics.dispose();

                        try {
                            ImageIO.write(bi, "jpeg", file);
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                    }
                }
            });

            //add restart button
            JButton scramble = new JButton("Reset");
            scramble.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
                    
//                    Layout layout = vv.getGraphLayout();
                    dynamicGraph = currentLevelGraph;
                    
//                    layout.setDelegate(new CircleLayout<Object,Object>(currentLevelGraph));
                    layout.removeAll();
                    layout.setGraph(currentLevelGraph);
                    layout.initialize();
                    
                    curCSetCentered = null; curCSetCenteredBVC = null;
                    curComNodeCSetCentered = null; curComNodeCSetCenteredBVC = null;
                    
                    colorCluster(curCSet, mainColor);
                    
                    
                    vv.repaint();
                    vv.setGraphLayout(layout);
//                    Relaxer relaxer = vv.getModel().getRelaxer();
//                    if (relaxer != null) {
//                        relaxer.stop();
//                        relaxer.prerelax();
//                        relaxer.relax();
//                    }
                }
            });;;

            DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
            vv.setGraphMouse(gm);
            
            gm.add(new DoubleClickZoomInPlugin<Object,Object>());

            final JPanel eastControls = new JPanel();
            eastControls.setOpaque(true);
            eastControls.setLayout(new BoxLayout(eastControls, BoxLayout.Y_AXIS));
            eastControls.add(Box.createVerticalGlue());

            //eastControls.add(eastSize);
            eastControls.add(Box.createVerticalGlue());

            zoomOutButton = new JButton("Zoom Out");
            zoomOutButton.setEnabled(false);
            zoomOutButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
//                    boolean isBioObjectSet = false;
                    zoomInButton.setEnabled(true);
//                    medp.setLowestLevel(false);
//                    System.out.println("viewHistoryList GOP size "+historyGOProcessors.size());
                    ViewHistory vh = viewHistoryList.remove(viewHistoryList.size()-1);
                    nodeToClusterMap = vh.getNodeToClusterMap();
                    dynamicGraph = vh.getStoredGraph();
                    GOProcessor gp = vh.gop;
//                    GOProcessor gp = historyGOProcessors.remove(historyGOProcessors.size() - 1);
                    
//                    System.out.println("viewHistoryList cSet "+historyCSetList.size());
                    curCSetBeforeVisClust = vh.cSetBeforeVis;
//                    curCSetBeforeVisClust = (Set<Set>) historyCSetList.remove(historyCSetList.size() - 1);
                    curComNodeCSetBeforeVisClust = vh.comNodeCSetBeforeVis;
//                    curComNodeCSetBeforeVisClust = (Set<Set>) historyComNodeCSetList.remove(historyComNodeCSetList.size() - 1);
                    
                    System.out.println("cset before size " +curCSetBeforeVisClust.size());
//                    System.out.println("cset before " +curCSetBeforeVisClust);
//                    System.out.println("com node cset before " +curComNodeCSetBeforeVisClust);
                    
                    if (viewHistoryList.size() == 0)
//                    if (historyCSetList.size() == 0)
                        zoomOutButton.setEnabled(false);
                    curCSet = curCSetBeforeVisClust;
                    curComNodeCSet = curComNodeCSetBeforeVisClust;
                    curGOP = gp;
//                    System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
//                    System.out.println("GO Proc: "+curGOP.clusterScoreMap);
                    
//                    if (curCSetBeforeVisClust.size() > 0){
//                        if (curCSetBeforeVisClust.iterator().next() instanceof BioObject){
//                            isBioObjectSet = true;
//                        }
//                    }
//                    if (curCSetBeforeVisClust.size() >= Integer.parseInt(thresholdTextField.getText())) {
//                        if (!isBioObjectSet){
//                            semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforeVisClust, curCSetBeforeVisClust, Integer.parseInt(thresholdTextField.getText()));
//                        } else
//                            semanticClusterList = gp.preCluster(curCSet, Integer.parseInt(thresholdTextField.getText()));
//                        curCSet = transformDataClusterList(semanticClusterList, false,true);
//                    } else {
//                        putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSetBeforeVisClust));
//                    }
////        dynamicGraph = createGraphFromCSet(cSet);
//        
//                    if (curCSet.size() > 0){
//                        if (curCSet.iterator().next() instanceof BioObject){
//                            isBioObjectSet = true;
//                        }
//                        else{
//                            isBioObjectSet = false;
//                        }
//                    }
//                    dynamicGraph = createGraph(curCSet);
////                    if (!isBioObjectSet)
////                        dynamicGraph = createGraphFromCSet(curCSet);
////                    else
////                        dynamicGraph = createGraphFromBioNodeSet(curCSet);
//                    colorCluster(curCSet, mainColor);
                    
                    vv.repaint();

                    layout.initialize();
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
                    layout.setGraph(dynamicGraph);
                    currentLevelGraph = vh.getUsualGraph();
//                    currentLevelGraph = dynamicGraph;
                    
                }
            });
                        
            
            zoomInButton = new JButton("Zoom In");
            zoomInButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    Set pickedSet = vv.getPickedVertexState().getPicked();
                    System.out.println("pickedSet size: " + pickedSet.size());
                    boolean bad = false;
                    if (pickedSet.size() != 0) {
                        for (Object obj : pickedSet) {
                            if (obj instanceof BioObject) {
                                bad = true;
                                break;
                            }
                        }
                    }
                    if (!bad){
                        zoomInAction(pickedSet);
//                        reLouvainCluster(curCSetBeforeVisClust, true);
                    }

                }
            });
            
            JPanel zoomPanel = new JPanel(new GridLayout(2, 1));
            zoomPanel.setBorder(BorderFactory.createTitledBorder("Zooming"));
            zoomPanel.add(zoomInButton);
            zoomPanel.add(zoomOutButton);
            
            Class[] combos = getLayoutCombos();
            final JComboBox jcb = new JComboBox(combos);
            // use a renderer to shorten the layout name presentation
            jcb.setRenderer(new DefaultListCellRenderer() {

                @Override
                public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                    String valueString = value.toString();
                    valueString = valueString.substring(valueString.lastIndexOf('.') + 1);
                    return super.getListCellRendererComponent(list, valueString, index, isSelected,
                            cellHasFocus);
                }
            });
            
            
            
//            clusterAndRecolor(layout, similarColors, true);
            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(dynamicGraph));
            jcb.addActionListener(new LayoutChooser(jcb, vv));
//            jcb.setSelectedItem(CircleLayout.class);

            Container content = getContentPane();
            content.add(new GraphZoomScrollPane(vv));
            JPanel east = new JPanel();
            JPanel west = new JPanel();
            west.setPreferredSize(new Dimension(180,600));
            east.setPreferredSize(new Dimension(180,600));
            JPanel grid = new JPanel(new GridLayout(1, 1));
            JPanel grid2 = new JPanel(new GridLayout(1, 2));
            grid.add(scramble);

            grid2.add(openFile);
            grid2.add(saveButton);
           
            JPanel p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Mouse Mode"));
            p.add(gm.getModeComboBox());
            
            
            east.add(grid2);
            east.add(grid);
            east.add(p);

            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Layout"));
            p.add(jcb);
//            east.add(p);
            east.add(zoomPanel);

            east.add(eastControls);
            
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Louvain Clusterer"));
                        
            JButton reLouvainButton = new JButton("     Run     ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
            reLouvainButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    if (curCSetCenteredBVC != null) {
                        Set cSet = new HashSet();
                        curCSetCentered = reLouvainCluster(curCSetCenteredBVC, false);
//                System.out.println("CenterNodeSet: "+centerNodeSet);
                        for (Object picked : centerNodeSet) {
                            cSet.add(picked);
                        }
                        cSet.addAll(curCSetCentered);
//                        System.out.println("CenterNodeSet: "+centerNodeSet);
                        dynamicGraph = createGraph(cSet);
                        
                        colorCluster(centerNodeSet,mainColor);
                        colorCluster(curCSetCentered,peripheralColor);
                        
                        StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                        LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                        Animator animator = new Animator(lt);
                        animator.start();
                        layout.setGraph(dynamicGraph);
                    } else
                        reLouvainCluster(curCSetBeforeVisClust,true);
                }
            });
            p.add(reLouvainButton);
            east.add(p);
         
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Search For: (Name)"));
            p.add(searchTextField);
            
            JPanel grids = new JPanel(new GridLayout(2, 1));
            
            
            grids.add(searchTextField);
            JPanel tmpPanel = new JPanel();
            tmpPanel.add(searchTextField);
            grids.add(tmpPanel);
            
            searchTextField.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    if (searchTextField.getText().length() != 0)
                        searchFor();
//                    reVisCluster(false);
//                    refineGOAnnot(e);
                }
            });
//            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            
            JButton sButton = new JButton("  Run  ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
            sButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    if (searchTextField.getText().length() != 0)
                        searchFor();
//                   centerNodes();
                }
            });
            tmpPanel = new JPanel();
            tmpPanel.add(sButton);
            grids.add(tmpPanel);
            
            p.add(grids);
            east.add(p);
            
        
//            String[] sss = new String[]{"s","a","g","12345",""};
            searchResList = new JList(listModel); 
            searchResList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
            searchResList.setLayoutOrientation(JList.VERTICAL);
            searchResList.setVisibleRowCount(7);
            

            listScroller = new JScrollPane(searchResList);
            listScroller.setPreferredSize(new Dimension(150, 150));
            
//            east.add(listScroller);
            
            final JButton focusSearchButton = new JButton("Focus");
            focusSearchButton.setActionCommand("Focus");
            focusSearchButton.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e) {
                   focusNodeBySearch((BioObject)searchResList.getSelectedValue());
                }
            });
//            getRootPane().setDefaultButton(focusSearchButton);
            
            searchResList.addMouseListener(new MouseAdapter() {

                public void mouseClicked(MouseEvent e) {
                    if (e.getClickCount() == 2) {
                        focusSearchButton.doClick(); //emulate button click
                    }
                }
            });
            
            
            JPanel panel = new JPanel();
            
            panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));
//            panel.setBorder(BorderFactory.createEmptyBorder(20, 20, 10, 20));
//            intro.setAlignmentX(JComponent.CENTER_ALIGNMENT);
            listScroller.setAlignmentX(JComponent.CENTER_ALIGNMENT);
            focusSearchButton.setAlignmentX(JComponent.CENTER_ALIGNMENT);

            //Add the labels to the content pane.
//            panel.add(intro);
//            panel.add(Box.createVerticalStrut(5)); //extra space
            panel.add(listScroller);

            //Add a vertical spacer that also guarantees us a minimum width:
//            panel.add(Box.createRigidArea(new Dimension(150, 10)));

            //Add the button.
            panel.add(focusSearchButton);
            
            east.add(panel);

            
            p = new JPanel();
            
//            p.setBorder(BorderFactory.createTitledBorder("GO Namespace Weight"));
            p.setBorder(BorderFactory.createTitledBorder("Semantic Clustering"));
            JPanel grid3 = new JPanel(new GridLayout(3, 1));
            
            ccSlider.setMajorTickSpacing(2);
//            ccSlider.setPreferredSize(new Dimension(p.getPreferredSize().width-50,ccSlider.getPreferredSize().height));
            ccSlider.setMinorTickSpacing(1);
            ccSlider.setPaintTicks(true);
//            Hashtable labelTable = new Hashtable();
//            ccSlider.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
            
            TitledBorder title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Cellular Component");
            title.setTitleColor(new Color(0xED143F));
            title.setTitlePosition(TitledBorder.CENTER);
            ccSlider.setBorder(title);

//            labelTable.put( new Integer( ccSlider.getMaximum()/2 ), new JLabel("Cellular Component") );
//            ccSlider.setLabelTable(labelTable);
//            ccSlider.setPaintLabels(true);
//            ccSlider.setPaintTrack(true);
            
            bpSlider.setMajorTickSpacing(2);
            bpSlider.setMinorTickSpacing(1);
            bpSlider.setPaintTicks(true);
//            bpSlider.setPaintLabels(true);
//            labelTable = new Hashtable();
//            labelTable.put( new Integer( bpSlider.getMaximum()/2 ), new JLabel("Biological Process") );
//            bpSlider.setLabelTable(labelTable);
            title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Biological Process");
            title.setTitlePosition(TitledBorder.CENTER);
            title.setTitleColor(new Color(0x3425B1));
            bpSlider.setBorder(title);
            
            mfSlider.setMajorTickSpacing(2);
            mfSlider.setMinorTickSpacing(1);
            mfSlider.setPaintTicks(true);
//            mfSlider.setPaintLabels(true);
//            labelTable = new Hashtable();
//            labelTable.put( new Integer( mfSlider.getMaximum()/2 ), new JLabel("Molecular Function") );
//            mfSlider.setLabelTable(labelTable);
            title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Molecular Function");
            title.setTitlePosition(TitledBorder.CENTER);
            title.setTitleColor(new Color(0x338F06));
            mfSlider.setBorder(title);
            
            grid3.add(ccSlider);
            grid3.add(mfSlider);
            grid3.add(bpSlider);
//            grid3.setPreferredSize(new Dimension(p.getPreferredSize().width-10,grid3.getPreferredSize().height));
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            p.add(grid3);
            
            grid2 = new JPanel(new GridLayout(2,1));
            
            grid3 = new JPanel();
           
//            p = new JPanel();
//            p.setBorder(BorderFactory.createTitledBorder("Vis Threshold"));
//            grid3 = new JPanel(new GridLayout(2, 1));
            JLabel lab = new JLabel("#Clusters: ");
            lab.setLabelFor(thresholdTextField);
            grid3.add(lab);
            grid3.add(thresholdTextField);
            thresholdTextField.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
//                    reVisCluster(false);
                    refineGOAnnot(e);
                }
            });
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            grid2.add(grid3);
//            JButton visThreshPerform = new JButton("Cluster");
//            visThreshPerform.addActionListener(new ActionListener() {
//
//                public void actionPerformed(ActionEvent e) {
//                   reVisCluster(false);
//                }
//            });
//            grid3.add(visThreshPerform);
//            east.add(p);
            
            JButton GORefineButton = new JButton("Run/Modify");
            GORefineButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    refineGOAnnot(e);
                }
            });
//            p.add(GORefineButton);
            tmpPanel = new JPanel();
            tmpPanel.add(GORefineButton);
            grid2.add(tmpPanel);
            p.add(grid2);
            
            p.setPreferredSize(new Dimension(170,p.getPreferredSize().height+grid2.getPreferredSize().height));
            
            west.add(p);
            
            p = new JPanel();
            
            p.setBorder(BorderFactory.createTitledBorder("GO Edge Filter"));
            goEdgeSlider.setMajorTickSpacing(2);
            goEdgeSlider.setMinorTickSpacing(1);
            goEdgeSlider.setPaintTicks(true);
            goEdgeSlider.addChangeListener(new ChangeListener() {

                public void stateChanged(ChangeEvent e) {
                    JSlider source = (JSlider) e.getSource();
                    if (!source.getValueIsAdjusting()) 
                    {
                        double threshold = source.getValue();
//                        System.out.println("threshold "+threshold);
                        if (threshold == source.getMaximum()){
                            System.out.println("thresh max: "+threshold);
                            medp.setThresholdForSE(0.0);
                        } else if (threshold == 0.0){
                            /* inner product will never be more than 1 */
                            medp.setThresholdForSE(2.0);
                        } else {
                            System.out.println("thresh "+(source.getMaximum()-threshold));
                            medp.setThresholdForSE(0.1*(source.getMaximum()-threshold));
                        }
                        vv.repaint();
                    }
                }

            });
            grid3 = new JPanel(new GridLayout(1, 1));
            grid3.add(goEdgeSlider);
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            p.add(grid3);
            p.setPreferredSize(new Dimension(170,p.getPreferredSize().height));
            west.add(p);
            
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Center Node(s)"));
            
            grid3 = new JPanel(new GridLayout(1,2));
            grid3.add(new JLabel("Num Hops: "));
            
            grid3.add(numHops);
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            
            JButton centerButton = new JButton("  Run  ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
            centerButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                   centerNodes();
                }
            });
            
            p.add(grid3);
            p.add(centerButton);
            p.setPreferredSize(new Dimension(170,p.getPreferredSize().height+30));
            west.add(p);
            
            
//            east.add(p);
            content.add(east, BorderLayout.EAST);
            content.add(west,BorderLayout.WEST);
            pack();
            setVisible(true);

        } catch (IOException e) {
            // TODO Auto-generated catch block
            System.out.println("Error in loading graph");
            e.printStackTrace();
        }
    }
    
    
    public void focusNodeBySearch(BioObject nodeToFocus){
//        System.out.println("Yeah!!");
        if (highlightedNode != null)
        {
            vertexPaints.put(highlightedNode,highlightedNodeFormerColor);
        }
        searchedBioObj = nodeToFocus;
        highlightedNode =  nodeToClusterMap.get(nodeToFocus);
        highlightedNodeFormerColor = (Color) vertexPaints.get(highlightedNode);
        vertexPaints.put(highlightedNode, searchedColor);
        
//        System.out.println(nodeToClusterMap.get(searchResList.getSelectedValue()));
        vv.repaint();
           
    }
    
    public void searchFor(){
        Set listRes = new HashSet();
        for (Object obj : dynamicGraph.getVertices())
        {
            if (obj instanceof Set){
                for (Object bioObj : (Set)obj){
                    BioObject bio = (BioObject)bioObj;
                    if (bio.getName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else if (bio.getStandardName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else {
                        for (String st: bio.getSynonym())
                        {
                            if (st.contains(searchTextField.getText())){
                                listRes.add(bio);
                                break;
                            }
                        }
                    }
                        
                }
            }
            else if (obj instanceof BioObject) {
                BioObject bio = (BioObject)obj;
                if (bio.getName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else if (bio.getStandardName().contains(searchTextField.getText())){
                        listRes.add(bio);
                    } else {
                        for (String st: bio.getSynonym())
                        {
                            if (st.contains(searchTextField.getText())){
                                listRes.add(bio);
                                break;
                            }
                        }
                    }
            }
        }
        listModel.removeAllElements();
        System.out.println("Search result: ");
        for (Object res : listRes){
            System.out.println(res);
            listModel.addElement(res);
//            System.out.println(nodeToClusterMap.get(res));
        }
//        searchResList = new JList(listRes.toArray());
        
//        searchResList.setListData(listRes.toArray());
        
//        System.out.println(listRes.toArray()[1]);
//        System.out.println(searchResList.getSelectionModel());
//        searchResList.validate();
//        listScroller = new JScrollPane(searchResList);
//        listScroller.repaint();
//        listScroller.validate();
//        this.validate();
    }
    
    public void refineGOAnnot(ActionEvent e){
        double ccValue = (double)ccSlider.getValue()/10;
        double mfValue = (double)mfSlider.getValue()/10;
        double bpValue = (double)bpSlider.getValue()/10;
//        System.out.println("cc "+ccValue);
//        System.out.println("mf "+mfValue);
//        System.out.println("bp "+bpValue);
        boolean nochange = true;
        if ((GOProcessor.getWeightMap().get(NameSpace.BP) != bpValue) || 
                (GOProcessor.getWeightMap().get(NameSpace.MF) != mfValue) ||
                (GOProcessor.getWeightMap().get(NameSpace.CC) != ccValue))
        {
            nochange = false;
        }
            
        GOProcessor.getWeightMap().put(NameSpace.BP, bpValue);
        GOProcessor.getWeightMap().put(NameSpace.MF, mfValue);
        GOProcessor.getWeightMap().put(NameSpace.CC, ccValue);
        reVisCluster(!nochange);
    }
    
    public void centerNodes(){
        String toNumHops = numHops.getText();
        int numHopsFromCenter = 0;
        try{
            numHopsFromCenter = Integer.parseInt(toNumHops);
        } catch (NumberFormatException e){
            String toShown = "Number of hops should be integer only.";
            JOptionPane.showMessageDialog(LouvainClustererTest.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);
        }
        Set pickedSet = vv.getPickedVertexState().getPicked();
        System.out.println("pickedSet size: "+pickedSet.size());

        if (pickedSet.size() != 0){
            /* check if the vertex is the set (of set or of BioObject) */
//            if (pickedSet.iterator().next() instanceof Set) {
//                currentLevelGraph = dynamicGraph;
                
//                historyCSetList.add(curCSetBeforeVisClust); historyComNodeCSetList.add(curComNodeCSetBeforeVisClust);
//                historyGOProcessors.add(curGOP);
//                System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
//                zoomOutButton.setEnabled(true);
                Set cSet = new HashSet(), comNodeCSet = new HashSet(),cSetCenter = new HashSet();
                Set nodesInCenterSet = new HashSet();
                Set nodesAroundCenter = new HashSet();
                Set toBeProcessed = new HashSet();
                
                for (Object ver : pickedSet) {
                    System.out.println("\nVertex: "+ver);
//                    Set vertex = (Set) ver;
                    if (ver instanceof Set){
                        Set vertex = (Set)ver;
                        System.out.println("\nVertex size: "+vertex.size());
                        nodesInCenterSet.addAll(vertex);
                        cSet.add(vertex); cSetCenter.add(vertex);
                        comNodeCSet.add(flatClustToComNodeClust.get(vertex));
                    }                        
                    else if (ver instanceof BioObject) {
                        BioObject vertex = (BioObject)ver;
                        nodesInCenterSet.add(vertex);
                        cSet.add(vertex); cSetCenter.add(vertex);
                        /* need to be checked later */
                        comNodeCSet.add(vertex);
                    }
                        
                }
                centerNodeSet = new HashSet(pickedSet);
                    
                toBeProcessed.addAll(nodesInCenterSet);
//                System.out.println("nodes in center "+nodesInCenterSet);
//                System.out.println("toBeProcessed "+toBeProcessed);
                for (int i = 1; i <= numHopsFromCenter; i++){
//                    System.out.println("");
//                    System.out.println("nodesaround "+nodesAroundCenter);
                    Set neighbors = new HashSet();
                    Set tmpSet = new HashSet(toBeProcessed);
                    Iterator it = tmpSet.iterator();
                    for (;it.hasNext();){
                        Object object = it.next();
                        BioObject bio = (BioObject)object;
//                        System.out.println("Bio: "+bio);
//                        if (!nodesAroundCenter.contains(bio)){
//                            if (i > 1){
//                                if (nodesInCenterSet.contains(bio))
//                                {
//                                    toBeProcessed.remove(object);
//                                    continue;
//                                }
//                            }
                            for (Object neighbor : originalGraph.getNeighbors(bio)){
//                                System.out.println("neighbor "+neighbor);
                                if (!nodesInCenterSet.contains(neighbor) && !nodesAroundCenter.contains(neighbor)){
                                    neighbors.add(neighbor);
//                                    System.out.println("added!!");
                                }
                            }
                            
                            toBeProcessed.addAll(neighbors);
//                        }
                        toBeProcessed.remove(object);
//                        System.out.println("To be processed "+toBeProcessed);
                    }
                    
                    nodesAroundCenter.addAll(toBeProcessed);
//                    System.out.println("toBeProcessed "+toBeProcessed);
//                    System.out.println("toBeProcessed size "+toBeProcessed.size());
                }
//                System.out.println("nodes around center "+nodesAroundCenter);
//                System.out.println("nodes around center size "+nodesAroundCenter.size());
                Set newCSet = new HashSet();
                newCSet.addAll(reLouvainCluster(nodesAroundCenter, false));
                cSet.addAll(newCSet);
                /* if edge size to be relouvain clustered is zero, curComNodeCSetCentered will be null
                 * and no need to add to comnodecSet
                 */
                if (curComNodeCSetCentered != null)
                    comNodeCSet.addAll(curComNodeCSetCentered);
//                curCSetCentered = cSet;
//                curComNodeCSetCentered = comNodeCSet;
                System.out.println("New Set ");
                for (Object obj : newCSet){
                    System.out.println("Vertex : "+obj);
                }
                
//                System.out.println("curGOP size "+curGOP.clusterScoreMap.size() );
//                System.out.println("Picked Set");
//                for (Object ver : pickedSet) {
//                    curGOPCentered.clusterScoreMap.put(ver, curGOP.clusterScoreMap.get(ver));
//                    System.out.println("Vertex : "+ver);
//                    System.out.println("Vertex val: "+curGOPCentered.clusterScoreMap.get(ver));
//                }
//                System.out.println("Current GO Map");
//                putInNodesGOVectorMapRelatively(curGOPCentered.getNodesGOVectorMapBeforeCluster(cSet));
                
////        int thresh = 12;
//                if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
//                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, comNodeCSet, cSet, Integer.parseInt(thresholdTextField.getText()));
//                    cSet = transformDataClusterList(semanticClusterList, isTopLevel, doOnAllNodesInCanVas);
//                } else {
//                    putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
//                }
////        dynamicGraph = createGraphFromCSet(cSet);
//
//                if (doOnAllNodesInCanVas) {
//                    curGOP = gp;
//                    System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
//                } else {
//                    curGOPCentered = gp;
//                }

                System.out.println("cSet: " + cSet.size());
                
//                dynamicGraph = createGraphFromCSet(cSet);
                dynamicGraph = createGraph(cSet);
//        colorTopLevel(dynamicGraph);
                colorCluster(newCSet, peripheralColor);
                colorCluster(cSetCenter,mainColor);
//        layout.setSize(new Dimension(100,100));
//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
                layout.setGraph(dynamicGraph);
                Graph tempGraph = SparseMultigraph.getFactory().create();
                for (Object object : cSetCenter){
                    tempGraph.addVertex(object);
                
                }
                Layout subLayout = new CircleLayout(tempGraph);
                subLayout.setInitializer(vv.getGraphLayout());
                subLayout.setSize(new Dimension(60,60));
                
//                System.out.println("Center "+vv.getSize().width/2);
                layout.put(subLayout,new Point(vv.getSize().width/2, vv.getSize().height/2));
                
                StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                Animator animator = new Animator(lt);
                animator.start();
                
                
//                currentLevelGraph = dynamicGraph;
//        layout.setGraph(newgraph);
                vv.repaint();
                
//            }
        }
    }
    
    public Set reLouvainCluster(Set cSet, boolean doOnAllNodesInCanvas){
        Set<BioObject> bioObjectToClusteredSet = new HashSet<BioObject>();
        int id = 0;
        nodeMap.clear();
        final Map<BioObject,Integer> idMap = new HashMap<BioObject,Integer>();
        Iterator iter = cSet.iterator();
        
        for (;iter.hasNext();){
            Object obj = iter.next();
            if (obj instanceof Set)
            {
                Set<BioObject> set = (Set<BioObject>)obj;
                for (BioObject bio : set){
                    bioObjectToClusteredSet.add(bio);
                    nodeMap.put(id, bio);
                    idMap.put(bio, id);
                    id++;
                }
            }
//                bioObjectToClusteredSet.addAll((Set)obj);
            else if (obj instanceof BioObject){
                bioObjectToClusteredSet.add((BioObject) obj);
                nodeMap.put(id,(BioObject)obj);
                idMap.put((BioObject)obj,id);
                id++;
            }
        }
        Set edgeSet = new TreeSet(new Comparator() {

            public int compare(Object e1, Object e2) {
                Pair pair1 = originalGraph.getEndpoints(e1);
                Object e1v1 = pair1.getFirst();
                Object e1v2 = pair1.getSecond();
                Pair pair2 = originalGraph.getEndpoints(e2);
                Object e2v1 = pair2.getFirst();
                Object e2v2 = pair2.getSecond();
                if (idMap.get(e1v1) < idMap.get(e2v1)){
                    return -1;
                } else if (idMap.get(e1v1) == idMap.get(e2v1)){
                    if (idMap.get(e1v2) < idMap.get(e2v2)){
                        return -1;
                    } else if (idMap.get(e1v2) == idMap.get(e2v2)) {
                        return 0;
                    } else
                        return 1;
                } else
                    return 1;
            }
        });
        for (BioObject bio : bioObjectToClusteredSet){
            for (Object edge : originalGraph.getIncidentEdges(bio))
            {
                Pair pair = originalGraph.getEndpoints(edge);
                Object firstVertex = pair.getFirst();
                Object secondVertex = pair.getSecond();
                if (!idMap.containsKey(firstVertex))
                    continue;
                if (!idMap.containsKey(secondVertex))
                    continue;
                edgeSet.add(edge);
            }
//            edgeSet.addAll(originalGraph.getIncidentEdges(bio));
        }
        int numEdge = edgeSet.size();
        System.out.println("Edge set size "+numEdge);
        System.out.println("Bio set "+bioObjectToClusteredSet.size());
        
        sArr = new int[numEdge];
        dArr = new int[numEdge];
        if (wArr != null)
            wArr = new double[numEdge];
        StopWatch sw = new StopWatch();
        sw.start();
//        String toLouvainClusterer = "";
//        StringBuilder stb = new StringBuilder(10000);
        int i = 0;
        for (Object edge : edgeSet){
            Pair pair = originalGraph.getEndpoints(edge);
            Object firstVertex = pair.getFirst();
            Object secondVertex = pair.getSecond();
//            System.out.println(idMap.get(firstVertex)+":"+idMap.get(secondVertex));
//            toLouvainClusterer += idMap.get(firstVertex)+"\t"+idMap.get(secondVertex)+"\t";
//            stb.append(idMap.get(firstVertex)).append("\t").append(idMap.get(secondVertex)).append("\t");
            sArr[i] = idMap.get(firstVertex); dArr[i] = idMap.get(secondVertex);
            if (isWeightGraph) {
                int weight = ew.getWeight(edge);
//            int weight = 1;

//                if (weight > 0) {
                    wArr[i] = weight;
//                    stb.append(weight);
//                toLouvainClusterer += weight;
//                }
            }
//            stb.append("\n");
//            toLouvainClusterer += "\n";
            i++;
        }
//        System.out.println("toLouvain "+toLouvainClusterer);
//        toLouvainClusterer = stb.toString();
        sw.stop();
        System.out.println("Load to String time "+sw);
        MainLouvain ml = new MainLouvain();
        try {
            
//            int[][] hierarchyComNode = ml.louvainClusterer(fileToOpen.getPath(),true);
            int[][] hierarchyComNode = null;
            if (edgeSet.size() > 0) {
//                int[][] hierarchyComNode = ml.louvainClusterer(toLouvainClusterer, false);
                hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);    
            } else
            {
                hierarchyComNode = new int[2][];
                for (i = 0; i < hierarchyComNode.length; i++){
                    hierarchyComNode[i] = new int[bioObjectToClusteredSet.size()];
                    for (int j = 0; j < hierarchyComNode[i].length; j++){
                        hierarchyComNode[i][j] = j;
                    }
                }
            }
            cSet = processClusterSet(dynamicGraph, hierarchyComNode, false, doOnAllNodesInCanvas);
            
//        for (Object edge : edgeSet){
//            Pair pair = originalGraph.getEndpoints(edge);
//            Object firstVertex = pair.getFirst();
//            Object secondVertex = pair.getSecond();
//            if (!nodeMap.containsValue(firstVertex))
//                nodeMap.put(id,(BioObject) firstVertex);
//
//        }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        return cSet;
//        for (Object edge : edgeSet){
//            Pair pair = originalGraph.getEndpoints(edge);
//            Object firstVertex = pair.getFirst();
//            Object secondVertex = pair.getSecond();
//            if (!nodeMap.containsValue(firstVertex))
//                nodeMap.put(id,(BioObject) firstVertex);
//            
//        }
        
    }
    public void reVisCluster(boolean newAnnot){
        
//                    System.out.println("curCSet "+curCSet);
//                    System.out.println("Cur com node cSet "+curComNodeCSet);
//                    System.out.println("curCSet before "+curCSetBeforeVisClust);
//                    System.out.println("Cur com node cSet before "+curComNodeCSetBeforeVisClust);
        if (curCSetCenteredBVC != null) {
            if (curCSetCenteredBVC.size() >= Integer.parseInt(thresholdTextField.getText())){
                GOProcessor gp = curGOPCentered;
                if (newAnnot)
                    gp.populateGOTerms(curCSetCenteredBVC);
                System.out.println("curCSetCenteredBVC: GO clusterScoreMap size: " + curGOP.clusterScoreMap.size());
                int numClust = Integer.parseInt(thresholdTextField.getText());
                if (!(curCSetCenteredBVC.iterator().next() instanceof BioObject)) {
                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetCenteredBVC, curCSetCenteredBVC, numClust);
                } else {
                    semanticClusterList = gp.preCluster(curCSetBeforeVisClust, numClust);
                }
                curCSetCentered = transformDataClusterList(semanticClusterList, false, false);
//            dynamicGraph = createGraphFromCSet(curCSet);
                Set cSet = new HashSet();
//                System.out.println("CenterNodeSet: "+centerNodeSet);
                for (Object picked : centerNodeSet){
                    cSet.add(picked);
                }
                cSet.addAll(curCSetCentered);
                dynamicGraph = createGraph(cSet);
                
                colorCluster(centerNodeSet,mainColor);
                colorCluster(curCSetCentered, peripheralColor);

//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
                StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                Animator animator = new Animator(lt);
                animator.start();
                layout.setGraph(dynamicGraph);
            } else {
                String toShown = "A number of nodes in the canvas are less than/equal to that specified in the text box. " + curCSetCenteredBVC.size();
                JOptionPane.showMessageDialog(LouvainClustererTest.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);

            }
        } else
        if (curCSetBeforeVisClust.size() >= Integer.parseInt(thresholdTextField.getText())){// || (newAnnot)) {
//                         GOProcessor gp = new GOProcessor();
//            zoomInButton.setEnabled(true);
            GOProcessor gp = curGOP;
            if (newAnnot)
                gp.populateGOTerms(curCSetBeforeVisClust);
            System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
//                         gp.populateGOTerms(curCSetBeforeVisClust);
            int numClust = 0;
//            if (newAnnot)
//                numClust = curCSet.size();
//            else
            numClust = Integer.parseInt(thresholdTextField.getText());    
            if (!(curCSetBeforeVisClust.iterator().next() instanceof BioObject)) {
                semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforeVisClust, curCSetBeforeVisClust, numClust);
            } else {
                semanticClusterList = gp.preCluster(curCSetBeforeVisClust, numClust);
            }
//            semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforeVisClust, curCSetBeforeVisClust, Integer.parseInt(thresholdTextField.getText()));
            curCSet = transformDataClusterList(semanticClusterList, false,true);
//            dynamicGraph = createGraphFromCSet(curCSet);
            dynamicGraph = createGraph(curCSet);
            currentLevelGraph = dynamicGraph;
            colorCluster(curCSet, mainColor);

//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
            Animator animator = new Animator(lt);
            animator.start();
            layout.setGraph(dynamicGraph);
        } else {
            String toShown = "A number of nodes in the canvas are less than/equal to that specified in the text box. " + curCSetBeforeVisClust.size();
            JOptionPane.showMessageDialog(LouvainClustererTest.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);

        }

    }
    
    JScrollPane listScroller = new JScrollPane();
    DefaultListModel listModel = new DefaultListModel();
    JList searchResList = new JList();
    JTextField searchTextField = new JTextField(10);
    JTextField thresholdTextField = new JTextField("12",4);
    JTextField numHops = new JTextField("2",5);
    JSlider ccSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);            
    JSlider bpSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider mfSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider goEdgeSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 9);
    JComboBox displayHieBox = new JComboBox();
//    Set<Set<Object>>[] hierCSet = null;
//    Set<Set<Object>>[] comNodehierSet = null;
    Set<Set>[] hierCSet = null;
    Set<Set>[] comNodehierSet = null;
//    BlondelClusterer clusterer;
    /* old clusterSet used in the JUNG demo */
    Set<Set> clusterSet;

//    public BioObject[][] changeToBioObject(int[][] hierarchyComNode){
//
//        return null;
//    }
    public void clusterAndRecolor(AggregateLayout<Object, Object> layout,
                                  Color[] colors, boolean clustering) throws FileNotFoundException, IOException {
        //Now cluster the vertices by removing the top 50 edges with highest betweenness
        //		if (numEdgesToRemove == 0) {
        //			colorCluster( g.getVertices(), colors[0] );
        //		} else {
//        int numClustersWanted = 5;
        Graph<Object, Object> g = layout.getGraph();

        if (clustering == true) {
//            System.out.println("num node: " + g.getVertexCount() + " num edge: " + g.getEdgeCount());
//            clusterer = new BlondelClusterer(threshold);

//        EdgeBetweennessClusterer clusterer =
//                new EdgeBetweennessClusterer(numEdgesToRemove);
            StopWatch stopwatch = new StopWatch();
            stopwatch.start();
//            clusterSet = clusterer.extract(g);
//            clusterer.extractHierarchy(g);
            MainLouvain ml = new MainLouvain();

//            int[][] hierarchyComNode = ml.louvainClusterer(fileToOpen.getPath(),true);
//            int[][] hierarchyComNode = ml.louvainClusterer(stringStream, false);
            int[][] hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
//            BioObject[][] hierBioObjComNode = changeToBioObject(hierarchyComNode);
            System.out.println("After Clustering");
            
            GOProcessor.loadGOTermsMap();
            Map<NameSpace,Double> map = new HashMap<NameSpace, Double>();
            map.put(NameSpace.BP, 1.0);
            map.put(NameSpace.MF, 1.0);
            map.put(NameSpace.CC, 1.0);
            GOProcessor.setWeightMap(map);
            clusterSet = processClusterSet(g, hierarchyComNode,true,true);
            System.out.println("Process After Clustering");
            stopwatch.stop();
//            displayHieBox = new JComboBox();
            displayHieBox.removeAllItems();
//            System.out.println(displayHieBox.getItemListeners().length);
//            for (ItemListener il : displayHieBox.getItemListeners()){
//                System.out.println(il);
//            }
            for (int i = hierarchyComNode.length - 1 - 1; i >= 0; i--) {
                displayHieBox.addItem("level " + (hierarchyComNode.length - 1 - 1 - i) + " (" + hierarchyComNode[i + 1].length + " clusters)");
            }
            displayHieBox.validate();
//            System.out.println(stopwatch);


            if (!UIWanted) {
                System.exit(0);
//        System.out.println("remove num edges: " + clusterer.getNumEdgesRemoved() + " Number of Clusters produced: " + numClustersWanted + " " + clusterSet.size());
            }
        }
//        Iterator s = ((Vertex)(clusterSet.getCluster(0).toArray()[0])).getUserDatumKeyIterator();
        //s.next(); //s.next();
//        System.out.println(s.next());
//        List edges = clusterer.getEdgesRemoved();

        recolor(layout, colors);
//        List edges = new ArrayList();
//
//        int i = 0;
//        //Set the colors of each node so that each cluster's vertices have the same color
//        for (Iterator cIt = clusterSet.iterator(); cIt.hasNext();) {
//
//            Set vertices = (Set) cIt.next();
//            Color c = colors[i % colors.length];
//
//            colorCluster(vertices, c);
//            if (groupClusters == true) {
//                groupCluster(layout, vertices);
//            }
//            i++;
//        }
//        for (Iterator it = g.getEdges().iterator(); it.hasNext();) {
//            Edge e = (Edge) it.next();
//            if (edges.contains(e)) {
//                e.setUserDatum(DEMOKEY, Color.LIGHT_GRAY, UserData.SHARED);
//            } else {
//                e.setUserDatum(DEMOKEY, Color.BLACK, UserData.SHARED);
//            }
//        }

    }

    private void recolor(AggregateLayout<Object, Object> layout, Color[] colors) {
//        List edges = new ArrayList();
        Graph<Object, Object> g = layout.getGraph();
        layout.removeAll();
        int i = 0;
//        clusterSet = hierCSet[hierCSet.length - 1 - currentLevel];
//        System.out.println("clusterSet: "+clusterSet);
        //Set the colors of each node so that each cluster's vertices have the same color
        for (Iterator<Set> cIt = clusterSet.iterator(); cIt.hasNext();) {

            Set<Object> vertices = (Set) cIt.next();
//            Color c = colors[i % colors.length];

//            colorCluster(vertices, c);
            colorCluster(vertices, bioObjColor);
//            if (groupClusters == true) {
//                groupCluster(layout, vertices);
//            }
            i++;
        }
        for (Object e : g.getEdges()) {
//        for (String e : g.getEdges()) {

//            if (edges.contains(e)) {
//                edgePaints.put(e, Color.lightGray);
//            } else {
            if (e instanceof String) {
                edgePaints.put(e, Color.LIGHT_GRAY);
//            }
            }
        }

    }

    private void colorCluster(Set vertices, Color c) {
        for (Object v : vertices) {
            vertexPaints.put(v, c);
        }

    }
    public Object highlightedNode = null;
    public BioObject searchedBioObj = null;
    public Color highlightedNodeFormerColor = null;
    private int currentLevel = 0;
    Map<Set<Set>,Set<Set>> cSetToComNodeCSet = new HashMap<Set<Set>,Set<Set>>();
    Map<Set, Set> flatClustToComNodeClust = new HashMap<Set, Set>();
    Map<Set, Set> comNodeClustToFlatClust = new HashMap<Set, Set>();
//    Map<Set, DataCluster> nodeToDataCluster = new HashMap<Set, DataCluster>();

    private Set<Set> processClusterSet(Graph g, int[][] hierarchyComNode,boolean isTopLevel, boolean doOnAllNodesInCanVas) throws IOException {
        ArrayList<Integer> labelList = new ArrayList();
        ArrayList<Set<Object>> csList = new ArrayList();

        ArrayList<Set<Object>> newCsList = new ArrayList();

        ArrayList<Set<Object>> arrComNode = new ArrayList();
        
        ArrayList<Set<Object>> newArrComNode = new ArrayList();

//        Set<Set<Number>> cSet = new VertexClusterSet(g);
//        Set<Set<Object>> cSet = new HashSet<Set<Object>>();
//        Set<Set<Object>> comNodeCSet = new HashSet<Set<Object>>();
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();
        if (isTopLevel) {
            hierCSet = new HashSet[hierarchyComNode.length];
            comNodehierSet = new HashSet[hierarchyComNode.length];
        }
//        int i = 0;

        System.out.println("Start process cluster set!");
        // hierarchyComNode should have length >= 2
        for (int j = 0; j < hierarchyComNode[1].length; j++) {
//            csList.add(new ArrayList<Object>());
            csList.add(new HashSet<Object>());
//            arrComNode.add(new ArrayList());
            arrComNode.add(new HashSet());
        }
        for (int j = 0; j < hierarchyComNode[0].length; j++) {
            if (!labelList.contains(hierarchyComNode[0][j])) {
                labelList.add(hierarchyComNode[0][j]);
            }
//                StringLabeller sl = StringLabeller.getLabeller(g, "node name");
            int index = labelList.indexOf(hierarchyComNode[0][j]);
//            ArrayList<Object> cluster = csList.get(labelList.indexOf(hierarchyComNode[0][j]));
//            ArrayList<Object> cluster = csList.get(index);
            Set<Object> cluster = csList.get(index);
//            ArrayList clusterOfComNode = arrComNode.get(index);
            Set clusterOfComNode = arrComNode.get(index);
//            cluster.add(j);
//            clusterOfComNode.add(j);
            cluster.add(nodeMap.get(j));
            clusterOfComNode.add(nodeMap.get(j));
            
//                System.out.println(i);

//                cluster.add(sl.getVertex(Integer.toString(j)));

        }
//        System.out.println("Vertices: " + g.getVertices());
//        System.out.println("Edges: " + g.getEdges());
//        Set<Object> tToCSet = new HashSet<Object>();
        comNodeCSet = new HashSet<Set>();
//            System.out.println("arrcomnode: "+arrComNode);
//        System.out.println("csList "+csList.size());
        for (int l = 0; l < csList.size(); l++) {
//        for (ArrayList<Object> cluster : csList) {
            /* only at this level we can use cluster instead of clusterOfComNode */
            Set<Object> cluster = csList.get(l);
//            ArrayList clusterOfComNode = arrComNode.get(l);
            
//            Set<Object> toCSet = new HashSet();
//            Set toComNodeCSet = new HashSet();
            
            
//            toCSet.addAll(cluster);
////            toComNodeCSet.addAll(clusterOfComNode);
//            toComNodeCSet.addAll(cluster);
//            cSet.add(toCSet);
//            comNodeCSet.add(toComNodeCSet);
//            flatClustToComNodeClust.put(toCSet, toComNodeCSet);
//            comNodeClustToFlatClust.put(toComNodeCSet, toCSet);
            cSet.add(cluster);
            comNodeCSet.add(cluster);
            flatClustToComNodeClust.put(cluster, cluster);
            comNodeClustToFlatClust.put(cluster, cluster);
            
//            System.out.println("\ntoCSet: " + cluster+" toComNodeCSet "+cluster);
//            tToCSet = toCSet;
//            dynamicGraph = collapseNodeSet(dynamicGraph, toCSet);

//            cSet.addCluster(toCSet);
//            System.out.println(cluster);
        }
//        System.out.println("Dynamic Graph Vertices: "+dynamicGraph.getVertices());
//        hierCSet[0] = new VertexClusterSet(g);
//        System.out.println(tToCSet);
//        System.out.println("Graph ver: "+layout.getGraph().getVertices());
//        System.out.println(layout.getGraph().getVertices());
//        Graph vx = null;
//        for (Object v: layout.getGraph().getVertices()){
//            System.out.println(v);
//            vx = (Graph) v;
////            System.out.println(((Graph)v). == collapser.getClusterGraph(realGraph, tToCSet));
//        }
//        System.out.println(collapser.getClusterGraph(realGraph, tToCSet));
//        System.out.println(layout.getGraph().containsVertex(collapser.getClusterGraph(realGraph, tToCSet)));
//        System.out.println(layout.getGraph().containsVertex(vx));
        cSetToComNodeCSet.put(cSet, comNodeCSet);
        if (isTopLevel) {
            hierCSet[0] = cSet;
            comNodehierSet[0] = comNodeCSet;
            System.out.println("\ncomNodehierSet "+0+": "+comNodehierSet[0]+"\n");
            System.out.println("\nhierCSet "+0+": "+hierCSet[0]+"\n");
        }
        
//        comNodehierSet[0].addAll(cSet);
//        Set toBeCollpased = new HashSet();

        for (int i = 1; i < hierarchyComNode.length - 1; i++) {
            labelList.clear();
            newCsList.clear();
            newArrComNode.clear();
//            System.out.println("size "+(i)+" "+hierarchyComNode[i].length);
//            System.out.println("size "+(i+1)+" "+hierarchyComNode[i+1].length);
            for (int j = 0; j < hierarchyComNode[i + 1].length; j++) {
                newCsList.add(new HashSet<Object>());
//                arrComNode.add(new HashSet());
                newArrComNode.add(new HashSet());
            }
//            System.out.println("size csList "+csList.size());
//            System.out.println("size new csList "+newCsList.size());
            for (int j = 0; j < hierarchyComNode[i].length; j++) {
                if (!labelList.contains(hierarchyComNode[i][j])) {
                    labelList.add(hierarchyComNode[i][j]);
                }

//                StringLabeller sl = StringLabeller.getLabeller(g,"node name");
                int index = labelList.indexOf(hierarchyComNode[i][j]);
                Set<Object> cluster = newCsList.get(index);
//                Set clusterOfComNode = arrComNode.get(index);
                Set clusterOfComNode = newArrComNode.get(index);
//                System.out.println(i);
                cluster.addAll(csList.get(j));
//                clusterOfComNode.add(csList.get(j));
                clusterOfComNode.add(arrComNode.get(j));
            }

            //clone newCsList to csList safely
            csList.clear();
            for (Set<Object> av : newCsList) {
                Set<Object> list = new HashSet<Object>();
                csList.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }
            
            //clone newArrComNode to arrComNode safely
            arrComNode.clear();
            for (Set<Object> av : newArrComNode) {
                Set<Object> list = new HashSet<Object>();
                arrComNode.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }
//            csList = newCsList.clone();

//            System.out.println("");
            cSet = new HashSet<Set>();//new VertexClusterSet(g);
            comNodeCSet = new HashSet<Set>();
//            System.out.println("arrcomnode: "+arrComNode);
            for (int l = 0; l < csList.size(); l++) {
//            for (ArrayList<Object> cluster : csList) {
                Set<Object> cluster = csList.get(l);
                Set clusterOfComNode = arrComNode.get(l);
//                Set<Object> toCSet = new HashSet();
//                Set toComNodeCSet = new HashSet();
//                toCSet.addAll(cluster);
//                toComNodeCSet.addAll(clusterOfComNode);
//                cSet.add(toCSet);
//                comNodeCSet.add(toComNodeCSet);
                cSet.add(cluster);
                comNodeCSet.add(clusterOfComNode);
//                flatClustToComNodeClust.put(toCSet, toComNodeCSet);
//                comNodeClustToFlatClust.put(toComNodeCSet, toCSet);
                flatClustToComNodeClust.put(cluster, clusterOfComNode);
                comNodeClustToFlatClust.put(clusterOfComNode, cluster);
//                if (i==3)
//                    System.out.println("\ntoCSet: " + cluster+" toComNodeCSet "+clusterOfComNode);
//                System.out.println("ClusterOfComNode: "+clusterOfComNode);
//                dynamicGraph = preCollapse(dynamicGraph, clusterOfComNode);
//                collapseNodeSet(layout, toCSet);
//                cSet.addCluster(toCSet);
//                System.out.println(cluster);
            }
            cSetToComNodeCSet.put(cSet, comNodeCSet);
            
            if (isTopLevel) {
                hierCSet[i] = cSet;
                comNodehierSet[i] = comNodeCSet;

                System.out.println("\ncomNodehierSet " + i + ": " + comNodehierSet[i] + "\n");
                System.out.println("\nhierCSet " + i + ": " + hierCSet[i] + "\n");
            }
            
        }
        

//        colorTopLevel(dynamicGraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
//        layout.setGraph(dynamicGraph);
//        System.out.println("\nDynamic Graph: ");
//        for (Object v : dynamicGraph.getVertices()) {
//            if (v instanceof Graph) {
//                System.out.println("Vertex: " + ((Graph) v).getVertices());
//            } else {
//                System.out.println("Vertex: " + v);
//            }
//        }
//        System.out.println(hierCSet[0]);
        if (isTopLevel) {
            int numSingle = 0;
            int numClustSizeMore1 = 0;
            double avgClustSize = 0;
            int biggestClustSize = -1;
            int sumClustSize = 0;

            /* calculate some stats */
//        for (int ind = 0; ind < cSet.size(); ind++){
            for (Set<Object> set : cSet) {
//            Set<Number> = cSet.
//            Set set = cSet.getCluster(ind);
                int size = set.size();
                if (size == 1) {
                    numSingle++;
                } else {
                    numClustSizeMore1++;
                }
                if (size > biggestClustSize) {
                    biggestClustSize = size;
                }
                sumClustSize += size;
            }

            avgClustSize = (double) sumClustSize / cSet.size();
            double percSingle = (double) numSingle / g.getVertexCount();
            double percBiggest = (double) biggestClustSize / g.getVertexCount();
            System.out.println("Single node num: " + numSingle + " percent: " + percSingle);
            System.out.println("No. cluster size > 1: " + numClustSizeMore1);
            System.out.println("Avg. cluster size: " + avgClustSize);
            System.out.println("Biggest cluster size: " + biggestClustSize + " percent: " + (percBiggest * 100));
//        try {
//            obosession = GOProcessor.getSession("gene_ontology.1_2.obo");
//        } catch (OBOParseException ex) {
//            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//        }
        }
        numOfLouvainClusters = cSet.size();

//        GOTermScoreMap = GOProcessor.populateGOTerms(cSet);
        if (doOnAllNodesInCanVas) {
            curCSetBeforeVisClust = cSet;
            curComNodeCSetBeforeVisClust = comNodeCSet;
        } else {
            curCSetCentered = curCSetCenteredBVC = cSet;
            curComNodeCSetCentered = curComNodeCSetCenteredBVC = comNodeCSet;
        }
        GOProcessor gp = new GOProcessor();
        StopWatch sw = new StopWatch();
        sw.start();
        gp.populateGOTerms(cSet);
        sw.stop();
        System.out.println("Populate GO Terms Time Used "+sw);
//        int thresh = 12;
        if ((cSet.size() == 1) && (cSet.iterator().next().size() >= Integer.parseInt(thresholdTextField.getText()))) {
            System.out.println("\n\n\n\n\n\ncSet size = 1, destroy cSet to get raw BioObjs\n\n\n\n\n");
            Set newset = new HashSet();
            newset.addAll(cSet.iterator().next());
            System.out.println("New Set: "+newset);
            gp.populateGOTerms(newset);
            semanticClusterList = gp.preCluster(newset, Integer.parseInt(thresholdTextField.getText()));
            
            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);
            System.out.println("cSet after transform "+cSet);
            System.out.println("End special semantic clustering!");
            /*tentative*/
            if (doOnAllNodesInCanVas)
                curCSetBeforeVisClust = newset;
            else 
                curCSetCenteredBVC = newset;
        } else if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())){
            System.out.println("Start Semantic Clustering!");
            semanticClusterList = gp.preCluster(comNodeClustToFlatClust,comNodeCSet,cSet,Integer.parseInt(thresholdTextField.getText()));
            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);
            System.out.println("End Semantic Clustering!");
        } else {
            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
        }
//        dynamicGraph = createGraphFromCSet(cSet);
        
        if (doOnAllNodesInCanVas) {
            curGOP = gp;
            System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
        } else {
            curGOPCentered = gp;
        }
        
        System.out.println("cSet: "+cSet.size());
//        Graph newgraph = createGraphFromCSet(cSet);
        if (doOnAllNodesInCanVas) {
//            dynamicGraph = createGraphFromCSet(cSet);
            dynamicGraph = createGraph(cSet);
//        colorTopLevel(dynamicGraph);
            colorCluster(cSet, mainColor);
//        layout.setSize(new Dimension(100,100));
//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
            Animator animator = new Animator(lt);
            animator.start();

            layout.setGraph(dynamicGraph);
            currentLevelGraph = dynamicGraph;
//        layout.setGraph(newgraph);
            vv.repaint();
        }
        
//        GOProcessor.createClusterCommonGOSet(cSet);
        return cSet;
//        return hierCSet[0];
    }
    
    private GOProcessor curGOP = null;
    private GOProcessor curGOPCentered = null;
    private Set<Set> curCSetCentered = null;
    private Set<Set> curCSetCenteredBVC = null;
    private Set<Set> curComNodeCSetCenteredBVC = null;
    private Set<Set> curComNodeCSetCentered = null;
    private Set centerNodeSet = null;
    private Set<Set> curCSet = null;
    private Set<Set> curCSetBeforeVisClust = null;
    private Set<Set> curComNodeCSet = null;
    private Set<Set> curComNodeCSetBeforeVisClust = null;
//    private ArrayList historyCSetList = new ArrayList<Set<Set<Object>>>();
//    private ArrayList historyComNodeCSetList = new ArrayList<Set<Set<Object>>>();
//    private ArrayList<GOProcessor> historyGOProcessors = new ArrayList<GOProcessor>();
    private ArrayList<ViewHistory> viewHistoryList = new ArrayList<ViewHistory>();
    
    public Graph createGraph(Set cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        nodeToClusterMap = new HashMap<BioObject, Object>();
        Map<Pair,MetaEdge> newEdgeMap = new HashMap<Pair,MetaEdge>();
        Set newSet = new HashSet(cSet);
        for (Object obj : cSet){
            if (obj instanceof Set){
                Set set = (Set)obj;
                Object suspect = set.iterator().next();
                if ((set.size() == 1) && (suspect instanceof BioObject)){
//                    System.out.println("suspect detected "+suspect);
                    newgraph.addVertex(suspect);
                    newSet.add(suspect);
                    newSet.remove(obj);
                    nodesGOVectorMap.put(suspect, nodesGOVectorMap.get(obj));
                    nodesGOVectorMap.remove(obj);
                    continue;
                } 
            }
            newgraph.addVertex(obj);
          
            
        }
        Object[] cSetArr = newSet.toArray(new Object[1]);
        for (int i = 0; i < cSetArr.length; i++){
//        for (Set cluster : cSet){
//            if (!newgraph.containsVertex(cSetArr[i]))
//                newgraph.addVertex(cSetArr[i]);
            /* calculate semantic edge between cluster */
//            for (Set cluster2 : cSet){
            for (int j = i+1; j < cSetArr.length; j++){
//                if (cluster == cluster2){
//                    continue;
//                }
                Object edge = newgraph.findEdge(cSetArr[i], cSetArr[j]);
                if (edge == null){           
                    edge = new SemanticEdge(cSetArr[i]+"<->"+cSetArr[j], nodesGOVectorMap.get(cSetArr[i]), nodesGOVectorMap.get(cSetArr[j]));
//                    if (!newgraph.containsVertex(cluster2)){
//                        newgraph.addVertex(cluster2);
//                    }
                    newgraph.addEdge(edge, cSetArr[i],cSetArr[j]);
//                    System.out.println("Edge : "+edge);
                } 
                else if (!(edge instanceof SemanticEdge))
                    System.out.println("What 's edge!!!");
//                Pair newPair = new Pair(cSetArr[i],cSetArr[j]); 
//                MetaEdge tmpEdge = new MetaEdge(cSetArr[i]+":"+cSetArr[j]);
//                newEdgeMap.put(newPair, tmpEdge);
            }
            if (cSetArr[i] instanceof Set) {
                for (Object obj : (Set) cSetArr[i]) {
                    nodeToClusterMap.put((BioObject) obj, cSetArr[i]);
                }
            } else {
                nodeToClusterMap.put((BioObject) cSetArr[i], cSetArr[i]);
            }
        }
        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
//            BioObject firstVer = (BioObject)pair.getFirst();
//            BioObject secondVer = (BioObject)pair.getSecond();
            Object preClusterFirst = nodeToClusterMap.get(pair.getFirst());
            Object preClusterSecond = nodeToClusterMap.get(pair.getSecond());
//            Set clusterFirst = nodeToClusterMap.get(pair.getFirst());
//            Set clusterSecond = nodeToClusterMap.get(pair.getSecond());
            
            if (preClusterFirst == null || preClusterSecond == null)
                continue;
            if (preClusterFirst == preClusterSecond)
                continue;
            
            Pair newPair = new Pair(preClusterFirst,preClusterSecond);
            Object tmpEdge = newEdgeMap.get(newPair);
            if (tmpEdge == null)
            {
                newPair = new Pair(preClusterSecond,preClusterFirst);
                tmpEdge = newEdgeMap.get(newPair);
                if (tmpEdge == null){
                    newEdgeMap.put(newPair, new MetaEdge(preClusterFirst+":"+preClusterSecond, edge));
                }
            } else {
                ((MetaEdge)tmpEdge).addEdge(edge);
            }
           
        }
        for (Pair key : newEdgeMap.keySet()){
//            System.out.println(newEdgeMap.get(key) instanceof MetaEdge);
//            System.out.println(newgraph.findEdgeSet(key.getFirst(), key.getSecond()));
//            if (!newgraph.containsEdge(newEdgeMap.get(key)))
            if (newEdgeMap.get(key).getNumEdgeSetBundled() > 0)
                newgraph.addEdge(newEdgeMap.get(key),key.getFirst(),key.getSecond());
        }
        
        return newgraph;
    }
    
    public Graph createGraphFromCSet(Set<Set> cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        Map<BioObject,Set<Object>> nodeToClusterMap = new HashMap<BioObject, Set<Object>>();
        StopWatch sw = new StopWatch();
        Map<Pair,MetaEdge> newEdgeMap = new HashMap<Pair,MetaEdge>();
        
        Set[] cSetArr = cSet.toArray(new Set[1]);
        for (Set cluster : cSet){
            newgraph.addVertex(cluster);
        }
        for (int i = 0; i < cSetArr.length; i++){
//        for (Set cluster : cSet){
//            if (!newgraph.containsVertex(cSetArr[i]))
//                newgraph.addVertex(cSetArr[i]);
            /* calculate semantic edge between cluster */
//            for (Set cluster2 : cSet){
            for (int j = i+1; j < cSetArr.length; j++){
//                if (cluster == cluster2){
//                    continue;
//                }
                Object edge = newgraph.findEdge(cSetArr[i], cSetArr[j]);
                if (edge == null){           
                    edge = new SemanticEdge(cSetArr[i]+"<->"+cSetArr[j], nodesGOVectorMap.get(cSetArr[i]), nodesGOVectorMap.get(cSetArr[j]));
//                    if (!newgraph.containsVertex(cluster2)){
//                        newgraph.addVertex(cluster2);
//                    }
                    newgraph.addEdge(edge, cSetArr[i],cSetArr[j]);
//                    System.out.println("Edge : "+edge);
                } else if (!(edge instanceof SemanticEdge))
                    System.out.println("What 's edge!!!");
//                Pair newPair = new Pair(cSetArr[i],cSetArr[j]); 
//                MetaEdge tmpEdge = new MetaEdge(cSetArr[i]+":"+cSetArr[j]);
//                newEdgeMap.put(newPair, tmpEdge);
            }
            for (Object obj : cSetArr[i]){
                nodeToClusterMap.put((BioObject) obj,cSetArr[i]);
            }
        }
                
        sw.start();
//        Set newEdgeSet = new HashSet();
        
        
        /* Cluster-centered implementation edge creation, slow because of O(v^2) */
//        Set[] cSetArr = cSet.toArray(new Set[1]);
//        for (int i = 0; i < cSetArr.length; i++){
//            for (int j = i+1; j < cSetArr.length; j++){
//                Pair newPair = new Pair(cSetArr[i],cSetArr[j]); 
//                MetaEdge tmpEdge = new MetaEdge(cSetArr[i]+":"+cSetArr[j]);
//                newEdgeMap.put(newPair, tmpEdge);
//                
//                for (Object obj : cSetArr[i]){
////                    BioObject bioObj1 = (BioObject)obj;
//                    for (Object obj2 : cSetArr[j]){
//                       
////                        BioObject bioObj2 = (BioObject)obj;
//                        Collection edgeSet = originalGraph.findEdgeSet(obj, obj2);
//                        
//                        if (edgeSet.size() > 0){
//                            Object edge = edgeSet.iterator().next();
//                            tmpEdge.addEdge(edge);
//                        } else {
//                            continue;
//                        }
//                    }
//                }
//                if (tmpEdge.getNumEdgeSetBundled() == 0)
//                {
//                    newEdgeMap.remove(newPair);
//                }
//            }
//        }

        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
//            BioObject firstVer = (BioObject)pair.getFirst();
//            BioObject secondVer = (BioObject)pair.getSecond();
            Set clusterFirst = nodeToClusterMap.get(pair.getFirst());
            Set clusterSecond = nodeToClusterMap.get(pair.getSecond());
            
            if (clusterFirst == null || clusterSecond == null)
                continue;
            if (clusterFirst == clusterSecond)
                continue;
            
            Pair newPair = new Pair(clusterFirst,clusterSecond);
            Object tmpEdge = newEdgeMap.get(newPair);
            if (tmpEdge == null)
            {
                newPair = new Pair(clusterSecond,clusterFirst);
                tmpEdge = newEdgeMap.get(newPair);
                if (tmpEdge == null){
                    newEdgeMap.put(newPair, new MetaEdge(clusterFirst+":"+clusterSecond, edge));
                }
            } else {
                ((MetaEdge)tmpEdge).addEdge(edge);
            }
            
            
            
//            Collection edgeSet = newgraph.findEdgeSet(clusterFirst,clusterSecond);
//            
//            if ((edgeSet.size() == 0) || ((edgeSet.size() == 1) && (edgeSet.iterator().next() instanceof SemanticEdge))){
//                HashSet set = new HashSet(); set.add(edge);
//                MetaEdge metaedge = new MetaEdge(clusterFirst+":"+clusterSecond, set);
//                newgraph.addEdge(metaedge, clusterFirst, clusterSecond);
//            } else {
//                Iterator it = edgeSet.iterator();
//                Object alreadyEdge = it.next();
//                if (alreadyEdge instanceof SemanticEdge)
//                    alreadyEdge = it.next();
//                MetaEdge metaedge = (MetaEdge) alreadyEdge;
//                metaedge.addEdge(edge);
//            }
        
           
//            if (alreadyEdge == null){
//                HashSet set = new HashSet(); set.add(edge);
//                MetaEdge metaedge = new MetaEdge(nodeToClusterMap.get(firstVer)+":"+nodeToClusterMap.get(secondVer), set);
//                newgraph.addEdge(metaedge, nodeToClusterMap.get(firstVer),nodeToClusterMap.get(secondVer));
//            } else if (!(alreadyEdge instanceof SemanticEdge)){
//                MetaEdge metaedge = (MetaEdge) alreadyEdge;
//                metaedge.addEdge(edge);
//            }
        }
        for (Pair key : newEdgeMap.keySet()){
//            System.out.println(newEdgeMap.get(key) instanceof MetaEdge);
//            System.out.println(newgraph.findEdgeSet(key.getFirst(), key.getSecond()));
//            if (!newgraph.containsEdge(newEdgeMap.get(key)))
            if (newEdgeMap.get(key).getNumEdgeSetBundled() > 0)
                newgraph.addEdge(newEdgeMap.get(key),key.getFirst(),key.getSecond());
        }
        sw.stop();
        System.out.println("Time for edge set: "+sw);
//        for (Set<Object> cluster : cSet){
//            for (Object obj : cluster){
//                BioObject bio = (BioObject) obj;
//                originalGraph.getNeighbors(bio);
//            }
//        }
        
        
        return newgraph;
    }
    public Graph createGraphFromBioNodeSet(Set cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        Map<BioObject,BioObject> nodeToClusterMap = new HashMap<BioObject, BioObject>();
        for (Object obj : cSet){
            newgraph.addVertex(obj);
            
//            for (Object obj : cluster){
            nodeToClusterMap.put((BioObject) obj,(BioObject) obj);
//            }
        }
        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
            BioObject firstVer = (BioObject)pair.getFirst();
            BioObject secondVer = (BioObject)pair.getSecond();
            if (nodeToClusterMap.get(firstVer) == null || nodeToClusterMap.get(secondVer) == null)
                continue;
            if (nodeToClusterMap.get(firstVer) == nodeToClusterMap.get(secondVer))
                continue;
            
            newgraph.addEdge(edge, pair);
            
        }
//        for (Set<Object> cluster : cSet){
//            for (Object obj : cluster){
//                BioObject bio = (BioObject) obj;
//                originalGraph.getNeighbors(bio);
//            }
//        }
        
        
        return newgraph;
    }
    OBOSession obosession = null;
    public int numOfLouvainClusters = 0;
    DataVector centroid = new DataVector();
    
    
//    public void findCentroid(){
//        System.out.println("Num of Louvain Clusters: "+numOfLouvainClusters);
//        Map<String,Double> valMap = new TreeMap<String,Double>();
//        for (DataCluster dc : semanticClusterList){
//                        
//            for (DataVector member : dc.getMembers()){
////                System.out.println("member: "+member);
////                for (int j = 0; j < member.dimValueList.length; j++) {
//                for (String key : member.getValueMap().keySet()) {
////                    int index = nameArrList.indexOf(member.dimNameList[j]);
////                    int index = nameArrList.indexOf(key);
////                    if (index == -1){
//                    if (!valMap.containsKey(key)){
////                        nameArrList.add(member.dimNameList[j]);
////                        zigmaList.add((double)member.dimValueList[j]/clusterList[i].members.size());
//                        valMap.put(key, (double)member.getValueMap().get(key)/numOfLouvainClusters);
//                    } else {
//                        valMap.put(key, valMap.get(key)+(double)member.getValueMap().get(key)/numOfLouvainClusters);
////                        zigmaList.set(index,zigmaList.get(index)+(double)member.dimValueList[j]/clusterList[i].members.size());
//                    }
////                    zigmaList[j] += (double)member.dimValueList[j]/clusterList[i].members.size();
//                }
//                
//            }
//            
//        }
//        centroid = new MeanVector(valMap);
//    }
//    Set<Graph> debugSet = new HashSet<Graph>();
    /** 
     * put obtained nodesGoVectorMap into the global one.
     * GO Vector to be put will be subtracted from the local centroid of the data set
     * @param localNodesGOVectorMap
     */
    public void putInNodesGOVectorMapRelatively(Map<Object,DataVector> localNodesGOVectorMap){
        int allNumMember = 0;
       
        DataCluster dc = new DataCluster();
        dc.addAll(localNodesGOVectorMap.values());
        allNumMember = dc.getMembers().size();
//        for (DataVector dv: dc.getMembers()){
//            allNumMember += ((Set)dv.nodeRef).size();
//        }
        System.out.println("putInNodesGOVectorMap all num member "+allNumMember);
        DataVector localCentroid = DataCluster.findCentroidFromDCList(new DataCluster[]{dc},allNumMember);
        
        for (DataVector dv: dc.getMembers()){
            DataVector resultVector = DataVector.minusVector(dv, localCentroid);
            nodesGOVectorMap.put(dv.nodeRef, resultVector);
        }

    }
    public Set<Set> transformDataClusterList(DataCluster[] dcList,boolean topLevel,boolean doOnAllNodesInCanvas){
        
//        Set<Set<Number>> cSet = new VertexClusterSet(g);
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();
        Set cluster = new HashSet();
        Set clusterComNode = new HashSet();
//        Set<Graph> tmpSet = new HashSet<Graph>();
        int sumOfAllMembers = 0;
        for (DataCluster dc : dcList){
                sumOfAllMembers += dc.getMembers().size();
        }
        
//        System.out.println("sum of all: "+sumOfAllMembers);
//        System.out.println("num of louvain "+numOfLouvainClusters);
//        centroid = DataCluster.findCentroidFromDCList(dcList,numOfLouvainClusters);
        centroid = DataCluster.findCentroidFromDCList(dcList,sumOfAllMembers);
//        findCentroid();
        for (int i = 0; i < dcList.length; i++){
            DataCluster dc = dcList[i];
            if (dc.getMembers().size() == 0){
                System.out.println("Found zero member cluster!!!!!!");
                continue;
            }
            DataVector[] dvList = dc.getMembers().toArray(new DataVector[1]);
            cluster = new HashSet();
            clusterComNode = new HashSet();
            for (DataVector dv :dvList) {
//                System.out.println(dv);

                //nodeRef points to a cluster (set of set) not a real metanode in the graph
                if (dv.nodeRef instanceof Set){
                    cluster.addAll((Set)dv.nodeRef);
                } else // nodeRef is BioObject
                {
                    cluster.add(dv.nodeRef);
                }
                clusterComNode.add(dv.comNodeClusterRef);


            }
//            nodeToDataCluster.put(cluster, dc);
            flatClustToComNodeClust.put(cluster, clusterComNode);
            comNodeClustToFlatClust.put(clusterComNode,cluster);
            cSet.add(cluster);
            comNodeCSet.add(clusterComNode);
            
            /* for graph collapser previously used */
//            ArrayList toPreCollapse = new ArrayList(clusterComNode.size());
//            toPreCollapse.addAll(clusterComNode);
//            dynamicGraph = preCollapse(dynamicGraph, toPreCollapse);
//            ArrayList listComNodeInGraph = new ArrayList();
//            Set toCollapseNode = new HashSet();
//            for (Object v : toPreCollapse) {
////            System.out.println("V: "+ v);
//                Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
////            System.out.println("comNodeInGraph: "+comNodeInGraph);
////                listComNodeInGraph.add(comNodeInGraph);
//                toCollapseNode.add(comNodeInGraph);
//            }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
//            toCollapseNode.addAll(listComNodeInGraph);
//            Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
//            tmpSet.add(clusterGraph);
            DataVector resultVector = DataVector.minusVector(dc.getRepresentative(), centroid);
            nodesGOVectorMap.put(cluster, resultVector);
//            nodesGOVectorMap.put(clusterGraph, resultVector);
//            debugSet.add(clusterGraph);
//        System.out.println(clusterGraph);
//            dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);
        }
        
        if (topLevel){
            //extend capacity and copy the contents for hierCSet and ComNodeHierSet
            Set<Set>[] tmpHierCSet = new HashSet[hierCSet.length + 1];
            for (int i = 0; i < hierCSet.length; i++) {
                tmpHierCSet[i] = hierCSet[i];
            }
            tmpHierCSet[hierCSet.length - 1] = cSet;
            hierCSet = tmpHierCSet;

            tmpHierCSet = new HashSet[comNodehierSet.length + 1];
            for (int i = 0; i < comNodehierSet.length; i++) {
                tmpHierCSet[i] = comNodehierSet[i];
            }
            tmpHierCSet[comNodehierSet.length - 1] = comNodeCSet;
            comNodehierSet = tmpHierCSet;
            System.out.println("\ncomNodehierSet " + (comNodehierSet.length-2) + ": " + comNodehierSet[comNodehierSet.length-2] + "\n");
            System.out.println("\nhierCSet " + (hierCSet.length-2) + ": " + hierCSet[hierCSet.length-2] + "\n");
        }
        if (doOnAllNodesInCanvas) {
            curComNodeCSet = comNodeCSet;
            curCSet = cSet;
        } else {
            curComNodeCSetCentered = comNodeCSet;
            curCSetCentered = cSet;
        }
        
        
        cSetToComNodeCSet.put(cSet, comNodeCSet);
        
//        System.out.println("comNodeHierSet.length-1 "+(comNodehierSet.length-1));
        for (Set set : cSet){
            System.out.println("cluster with size "+set.size());
        }
//        for (Graph set : tmpSet){
//            System.out.println("cluster with size "+set.getVertexCount());
//        }
//        processGOLabel();
        
        return cSet;
        
    }
    
    DataCluster[] semanticClusterList = new DataCluster[1];
    Map <Object,DataVector> nodesGOVectorMap = new HashMap<Object, DataVector>();
    Map<BioObject,Object> nodeToClusterMap;
//    private Map<Object, Map<GOTerm, Double>> GOTermScoreMap = new HashMap<Object, Map<GOTerm, Double>>();
//    private void createClusterCommonGOSet(Set<Set<Object>> cSet){
//        System.out.println("\nCalculate GO Stat\n");
//        for(Set<Object> cluster : cSet){
//            Set commonGOId = new HashSet();
//            int i = 0;
//            String name = "";
//            for (Object node : cluster)
//            {
//                BioObject bioNode = (BioObject)node;
//                if (i == 0){
//                    commonGOId.addAll(bioNode.getGoIdList());
//                    name = bioNode.toString();
//                }
//                else
//                    commonGOId.retainAll(bioNode.getGoIdList());
//                i++;
//            }
//            System.out.println("Num Common GO Id for cluster of "+name+" with size "+cluster.size()+": "+commonGOId.size()+" List: "+commonGOId);
//        }
//    }
    
    public class NumMemberGOTips<V,E>
    	implements Transformer<V,String> {
        
        public String transform(V vertex) {
            String res = "<html>";
            
            if (vertex instanceof Set){
                res += "Num Nodes Inside: "+((Set)vertex).size();
                DataVector vec = nodesGOVectorMap.get(vertex);
                
                if (vec != null){
                
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
                        
                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();
                        
//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }
//                                if (i > 1)
//                                    res += "";
                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());
                        
                        res += "<p>";
                        if (goTerm.getNamespace().equals(NameSpace.CC))
                            res += "<font color = #ED143F>";
                        else if (goTerm.getNamespace().equals(NameSpace.MF)) 
                            res += "<font color = #338F06>";
                        else 
                            res += "<font color = #3425B1>";
                        res += toPrint + " (" + output + ")";
                        res += "</font>";
                        i++;
                        if (i == 7) {
                            break;
                        }
                        
//                        res += "<p>" + entry.getKey() + " with " + String.format("%.3f", entry.getValue());
//                        i++;
//                        if (i == 5) {
//                            break;
//                        }
                    }
                }
            } else if (vertex instanceof BioObject){
                
                DataVector vec = nodesGOVectorMap.get(vertex);
                if (vec != null) {
                    
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
//                                IdentifiedObject obj = obosession.getObject((String)entry.getKey());
//                                res += "<p>" + entry.getKey() + " with " + entry.getValue();
//                                String toPrint = obj.getName();
                        
                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();
                        
//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }
//                                if (i > 1)
//                                    res += "";
                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());
                        
                        res += "<p>";
                        if (goTerm.getNamespace().equals(NameSpace.CC))
                            res += "<font color = #ED143F>";
                        else if (goTerm.getNamespace().equals(NameSpace.MF)) 
                            res += "<font color = #338F06>";
                        else 
                            res += "<font color = #3425B1>";
                        res += toPrint + " (" + output + ")";
                        res += "</font>";
                        i++;
                        if (i == 7) {
                            break;
                        }
                        
                        
//                        String toPrint = GOProcessor.goTermsMap.get((String) entry.getKey()).getName();
//                        if (toPrint.length() > 20) {
//                            toPrint = toPrint.substring(0, 20);
//                            toPrint += "...";
//                        }
////                                if (i > 1)
////                                    res += "";
//                        DecimalFormat myFormatter = new DecimalFormat(".00");
//                        String output = myFormatter.format(entry.getValue());
//
//                        res += "<p>" + toPrint + " (" + output + ")";
//                        i++;
//                        if (i == 5) {
//                            break;
//                        }
                    }
//                    res += "</center>";
                } else {

                    BioObject bio = (BioObject) vertex;
                    ArrayList<String> goidList = bio.getGoIdList();
                    int i = 0;
                    for (String s : goidList) {
                        res += "<p>" + s;// + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            }
            res += "</html>";
            return res;
        }
    }
    private class TextFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("txt")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Just text file";
        }
    }
    private class MNetFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("mnet")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Modified .net Pajek file";
        }
    }

//    private static int numMemberInClusteredGraph(Object v){
//        int numMember = 0;
//        Graph g = (Graph) v;
//        for (Object ver : g.getVertices()){
//           if (ver instanceof Graph) 
//               numMember += numMemberInClusteredGraph(ver);
//           else
//               numMember += 1;
//        }
//        
//        return numMember;
//    }
    private final class EdgeDisplayPredicate<V, E>
            implements Predicate<Context<Graph<V, E>, E>> //extends AbstractGraphPredicate<V,E>
    {
        private double thresholdForSE = .1;

        private boolean isLowestLevel = false;

        public void setLowestLevel(boolean value) {
            isLowestLevel = value;
        }
        
        public double getThresholdForSE() {
            return thresholdForSE;
        }

        public void setThresholdForSE(double thresholdForSE) {
            this.thresholdForSE = thresholdForSE;
        }
        
        public boolean evaluate(Context<Graph<V, E>, E> context) {
//            Graph<V, E> graph = context.graph;
            E e = context.element;
//            if ((e instanceof MetaEdge) || (isLowestLevel)) {
            if (e instanceof MetaEdge) {
                return true;
            }
            if (e instanceof SemanticEdge){
                double val = ((SemanticEdge)e).getInnerProduct();
                if ((val > 0) && (val >= thresholdForSE))
                    return true;
            }
                
            return false;
//            if (realGraph.getEdgeType(e) == EdgeType.DIRECTED && show_d) {
//                return true;
//            }
//            if (realGraph.getEdgeType(e) == EdgeType.UNDIRECTED && show_u) {
//                return true;
//            }
//            return false;
        }
    }

    private final class EdgeLabeller<E> implements Transformer<E, String> {

        protected EdgeWeightLabeller edge_weight;

        public EdgeLabeller(EdgeWeightLabeller edgeWeight) {
            this.edge_weight = edgeWeight;
        }

        public String transform(E e) {
            double value = 1;
            if (e instanceof MetaEdge) //                return (((MetaEdge)e).edgeSetBundled).toString();
            {
                value = ((MetaEdge) e).numEdgeSetBundled;
            } else if (e instanceof SemanticEdge){
                value = ((SemanticEdge)e).getInnerProduct();
                return ""+ String.format("%.3f",value);
            } else {
                value = edge_weight.getWeight(e);
//                return Integer.toString(edge_weight.getWeight(e));
            }
            if (value > 1) {
                return "" + String.format("%d", (int)value);
            } else {
                return "";
            }
        }
    }

    private final class EdgeWeightStrokeFunction<E>
            implements Transformer<E, Stroke> {
        float [] Dashes = {10.0F, 3.0F, 3.0F, 3.0F};
        protected final Stroke basic = new BasicStroke(1);
        protected final Stroke heavy = new BasicStroke(3);
        protected final Stroke heavy2 = new BasicStroke(6);
        
        protected final Stroke sBasic = new BasicStroke (1.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy =  new BasicStroke (3.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy2 = new BasicStroke (6.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);;
        
//        protected static final Stroke heavy = new BasicStroke();
        protected final Stroke dotted = RenderContext.DOTTED;//        protected boolean weighted = false;
//        protected Map<E,Number> edge_weight;
        protected EdgeWeightLabeller edge_weight;
        protected Graph graph;

//        public EdgeWeightStrokeFunction(Map<E,Number> edge_weight)
        public EdgeWeightStrokeFunction(EdgeWeightLabeller edge_weight) {
            this.edge_weight = edge_weight;
//            this.graph = graph;   
        }

//        public void setWeighted(boolean weighted)
//        {
//            this.weighted = weighted;
//        }
        public Stroke transform(E e) {
//            if (weighted)
//            {
//             double value = edge_weight.get(e).doubleValue();
            double value;
            if (e instanceof MetaEdge) {
                value = ((MetaEdge) e).getNumEdgeSetBundled();
                if (value > 7) {
                    return heavy2;
                } else if (value > 3) {
                    return heavy;
                } else {
                    return basic;
                }
            } else if (e instanceof SemanticEdge) {
                value = ((SemanticEdge) e).getInnerProduct();
                if (value > 0.8) {
                    return sHeavy2;
                } else if (value > 0.3) {
                    return sHeavy;
                } else {
                    return sBasic;
                }
            } else {
                value = edge_weight.getWeight(e);
                if (value > 7) {
                    return heavy;
                } else if (value > 3) {
                    return new BasicStroke(3);
                } else {
                    return basic;
                }
                
            }
            
//            }
//            else
//                return basic;
            
        }//        protected boolean drawHeavy(E e)
//        {
//            double value = edge_weight.get(e).doubleValue();
//            if (value > 0.7)
//                return true;
//            else if (value > 5)
//
//                return false;
//        }
    }
    /*
     * Already commonly used by doubleclickplugin function
     */
    private boolean zoomInAction(Set vertexToProcessed){
               
        int countBioObjSet = 0;
        
        Set setOfcomNodeCSet = new HashSet();
        


        /* check if the vertex is the set (of set or of BioObject) */

        boolean lastLevel = false;
        ViewHistory viewhist = new ViewHistory(curCSetBeforeVisClust, curComNodeCSetBeforeVisClust, curGOP, dynamicGraph);
        viewHistoryList.add(viewhist);
        viewhist.setStoredGraph(dynamicGraph); viewhist.setUsualGraph(currentLevelGraph);
        viewhist.setNodeToClusterMap(nodeToClusterMap);
//        historyCSetList.add(curCSetBeforeVisClust);
//        historyComNodeCSetList.add(curComNodeCSetBeforeVisClust);
//        historyGOProcessors.add(curGOP);
        System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
        zoomOutButton.setEnabled(true);
        Set set = new HashSet();
        Set comNodeSet = new HashSet();
        
        for (Object ver : vertexToProcessed) {
            Set vertex = (Set) ver;
            System.out.println("\nVertex: " + vertex);
            System.out.println("\nVertex size: " + vertex.size());

            /* consider the case when mixing clusters together later */
            curComNodeCSet = flatClustToComNodeClust.get(vertex);
//                            BioObject bioObj = (BioObject)((Set)vertex).iterator().next();
//                            System.out.println("bioObj "+bioObj);

            System.out.println("curComNodeCSet: " + curComNodeCSet);

            /* considered now if populate two set */
            /* to be considered later --> ok now */
            while ((curComNodeCSet.size() == 1) && (curComNodeCSet.iterator().next() instanceof Set)) {
                /* for [[A,B]] set, it will terminate immediately and do not run in this loop */
                Set tmpSet = curComNodeCSet.iterator().next();
                if ((tmpSet.iterator().next() instanceof BioObject)) {
                    countBioObjSet++;
                    break;
                }
                curComNodeCSet = tmpSet;
//                        tmpSet = curComNodeCSet.iterator().next();
                System.out.println("curComNodeCSet: " + curComNodeCSet);
//                        if (tmpSet.iterator().next() instanceof BioObject) {
//                            countBioObjSet++;
//                            break;
//                        }
            }
            setOfcomNodeCSet.add(curComNodeCSet);
        }
        /* if not all pickedSet vertex contains BioObject directly,
         *  Just treat them as normal set
         * Set of one member containing BioObject is also treated normally.
         * I will not extract a member of such sets anymore
         */
        if (countBioObjSet != vertexToProcessed.size()) {
            for (Object object : setOfcomNodeCSet) {
                Set comNodeCSet = (Set) object;
                Iterator it = comNodeCSet.iterator();
//                            for (Object obj : curComNodeCSet)
                for (; it.hasNext();) {
                    Object obj = it.next();
                    System.out.println("Obj " + obj);
                    /* may not be used, need to be confirmed */
                    if (obj instanceof BioObject) {
//                                    Set tmpSet = new HashSet(); tmpSet.add(obj);
//                                    set.add(tmpSet);
                        set.add(obj);
                        lastLevel = true;
                    } else {

                        if (comNodeClustToFlatClust.get(obj) != null) {
//                            System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
                        }
                        set.add(comNodeClustToFlatClust.get(obj));
//                            System.out.println("vertex size "+comNodeClustToFlatClust.get(obj).size());
                    }

                }
                comNodeSet.addAll(comNodeCSet);
//                    System.out.println("cur Set: " + set);
//                    System.out.println("cur Set size: " + set.size());
            }
        } /* Extract BioObjects of each set and mix them together to get one larger set
         */ else {
            for (Object object : setOfcomNodeCSet) {
                Set comNodeCSet = (Set) object;
                /* assume that there is only one member (set of bioObj)*/
                lastLevel = true;
                Set setOfBioObj = (Set) comNodeCSet.iterator().next();
                Iterator it = setOfBioObj.iterator();
//                            for (Object obj : curComNodeCSet)

                for (; it.hasNext();) {
                    Object obj = it.next();

                    System.out.println("Obj " + obj);

                    if (obj instanceof BioObject) {
//                                    Set tmpSet = new HashSet(); tmpSet.add(obj);
//                                    set.add(tmpSet);
                        set.add(obj);

                    } /* may not be used, need to be confirmed */ else {

                        if (comNodeClustToFlatClust.get(obj) != null) {
                            System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
                        }
                        set.add(comNodeClustToFlatClust.get(obj));
//                            System.out.println("vertex size "+comNodeClustToFlatClust.get(obj).size());
                    }

                }
                comNodeSet.addAll(setOfBioObj);
//                    System.out.println("cur Set: " + set);
//                    System.out.println("cur Set size: " + set.size());
            }
        }
        curCSet = set;
        curComNodeCSet = comNodeSet;
//                System.out.println("curCSet: " + curCSet);
//                System.out.println("curCSet size: "+curCSet.size());
//                int num = 0;
//                for (Set s : curCSet){
//                    System.out.println("vertex size: "+s.size());
//                    num += s.size();
//                }
//                System.out.println("Size: "+num);


        layout.initialize();

        Relaxer relaxer = new VisRunner((IterativeContext) layout);
        relaxer.stop();
        relaxer.prerelax();

//                if (!lastLevel) {
//                    GOProcessor gp = new GOProcessor();
//                    gp.populateGOTerms(curCSet);
//                    
//                    curCSetBeforeVisClust = curCSet;
//                    curComNodeCSetBeforeVisClust = curComNodeCSet;
//                    curGOP = gp;
//                    System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
//                    if (curCSet.size() > Integer.parseInt(thresholdTextField.getText())) {
//                        semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSet, curCSet, Integer.parseInt(thresholdTextField.getText()));
//                        curCSet = transformDataClusterList(semanticClusterList, false);
//                    } else {
//                        putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
//                    }
//
//                    dynamicGraph = createGraphFromCSet(curCSet);
//                    colorCluster(curCSet, mainColor);
//                } else {
//                    medp.setLowestLevel(true);
//                    zoomInButton.setEnabled(false);
//                    dynamicGraph = createGraphFromBioNodeSet(curCSet);
//                }

        GOProcessor gp = new GOProcessor();
        gp.populateGOTerms(curCSet);
//                            if (!lastLevel){
                                /* In the case which cSet is the set of BioObject, curCSet is the same as curComNodeCSet */
        curCSetBeforeVisClust = curCSet;
        curComNodeCSetBeforeVisClust = curComNodeCSet;
        curGOP = gp;
        System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
//                            }

        if (curCSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
            reLouvainCluster(curCSetBeforeVisClust, true);

//                    if (!lastLevel) {
//                        semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSet, curCSet, Integer.parseInt(thresholdTextField.getText()));
//                    } else {
//                        semanticClusterList = gp.preCluster(curCSet, Integer.parseInt(thresholdTextField.getText()));
//                    }
//
//                    curCSet = transformDataClusterList(semanticClusterList, false,true);
//                    System.out.println("cur C Set after seman clust: " + curCSet);
//
////                    dynamicGraph = createGraphFromCSet(curCSet);
//                    dynamicGraph = createGraph(curCSet);
//
//                    colorCluster(curCSet, mainColor);



        } else {
            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
            if (lastLevel) {

//                        medp.setLowestLevel(true);
                zoomInButton.setEnabled(false);
//                        dynamicGraph = createGraphFromBioNodeSet(curCSet);
                dynamicGraph = createGraph(curCSet);
            } else {

                System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
//                        dynamicGraph = createGraphFromCSet(curCSet);
                dynamicGraph = createGraph(curCSet);
                colorCluster(curCSet, mainColor);
            }
        }


        layout.setGraph(dynamicGraph);
        currentLevelGraph = dynamicGraph;
        StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);

//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
        LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), layout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
        Animator animator = new Animator(lt);
        animator.start();

//        reLouvainCluster(curCSetBeforeVisClust, true);
//        layout.setGraph(newgraph);
        /* Deal with search function */
        Object[] searchedListArr = new Object[listModel.size()];
        listModel.copyInto(searchedListArr);
        System.out.println("listModel " + listModel.size());
//            System.out.println("searchedList "+searchedListArr.length);
        Set settemp = new HashSet(Arrays.asList(searchedListArr));
        System.out.println("settemp " + settemp.size());
        Set currentVertices = new HashSet();
        for (Object obj : dynamicGraph.getVertices()) {
            if (obj instanceof Set) {
                currentVertices.addAll((Set) obj);
            } else if (obj instanceof BioObject) {
                currentVertices.add(obj);
            }
        }

        currentVertices.retainAll(settemp);
        System.out.println("currentVer " + currentVertices);
        listModel.removeAllElements();

        for (Object obj : currentVertices) 
            listModel.addElement(obj);
        
        System.out.println("vertexToProcessed: "+vertexToProcessed.size());
        if ((highlightedNode != null) && vertexToProcessed.contains(highlightedNode)){
            focusNodeBySearch(searchedBioObj);
            searchResList.setSelectedValue(searchedBioObj, true);
//            System.out.println("Yeah contain");
        } else {
            
            
        }
        vv.repaint();



        return true;
    }
    public class DoubleClickZoomInPlugin<V,E> extends AbstractGraphMousePlugin
        implements MouseListener{
        public DoubleClickZoomInPlugin(){
            this(MouseEvent.BUTTON1_DOWN_MASK);
        }
        public DoubleClickZoomInPlugin(int modifier){
            super(modifier);
        }
        private boolean isContainedIn(BioObject bioObj,Set hierSet){
            boolean isContained = false;
            if (hierSet.contains(bioObj)){
                    return true;
            }
            for (Object obj : hierSet){
                if (obj instanceof Set){
                    
                    
                    isContained |= isContainedIn(bioObj,(Set) obj);   
                }
            }
            return isContained;
        }
        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2 && !e.isConsumed()) {
                e.consume();
                
                        
                final VisualizationViewer<V,E> vv =
                        (VisualizationViewer<V, E>) e.getSource();
                final Point2D p = e.getPoint();
                GraphElementAccessor<V, E> pickSupport = vv.getPickSupport();
                if (pickSupport != null) {
//                    Graph<V, E> graph = vv.getModel().getGraphLayout().getGraph();

                    
                    final V vertex = pickSupport.getVertex(vv.getModel().getGraphLayout(), p.getX(), p.getY());
                    
                    if (vertex != null){
                        

//                        zoomOutButton.setEnabled(true);
                        System.out.println("\nVertex: "+vertex);
//                        for (Object ver : vv.getModel().getGraphLayout().getGraph().getVertices()){
//                            System.out.println("flat "+flatClustToComNodeClust.get(ver));
//                        }
                        if (vertex instanceof Set){
                            Set toZoomInAction = new HashSet();
                            toZoomInAction.add(vertex);
                            zoomInAction(toZoomInAction);
//                            historyCSetList.add(curCSetBeforeVisClust); historyComNodeCSetList.add(curComNodeCSetBeforeVisClust);
//                            historyGOProcessors.add(curGOP);
//                            System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
//                            curComNodeCSet = flatClustToComNodeClust.get(vertex);
////                            BioObject bioObj = (BioObject)((Set)vertex).iterator().next();
////                            System.out.println("bioObj "+bioObj);
//                            Set set = new HashSet();
//                            
//                            System.out.println("curComNodeCSet: "+curComNodeCSet);
//                            while ((curComNodeCSet.size() == 1) && (curComNodeCSet.iterator().next() instanceof Set)) {
//                                
//                                curComNodeCSet = curComNodeCSet.iterator().next();
////                                Set tmpSet = curComNodeCSet.iterator().next();
//                                System.out.println("curComNodeCSet: "+curComNodeCSet);
////                                if (tmpSet.iterator().next() instanceof BioObject)
////                                    break;
//                            }
//                            
////                            if (curComNodeCSet.iterator().next() instanceof BioObject){
////                                System.out.println("BioObject");
////                            } else {
//                            Iterator it = curComNodeCSet.iterator();
//                            boolean lastLevel = false;
//                            for (;it.hasNext();)
////                            for (Object obj : curComNodeCSet)
//                            {
//                                Object obj = it.next();
//                                System.out.println("Obj "+obj);
////                                System.out.println(obj);
////                                Set hierSet = (Set)obj;
//                                if (obj instanceof BioObject){
////                                    Set tmpSet = new HashSet(); tmpSet.add(obj);
////                                    set.add(tmpSet);
//                                    set.add(obj);
//                                    lastLevel = true;
//                                } else {
//                                
////                                if (isContainedIn(bioObj,hierSet))
////                                    System.out.println("bio obj "+bioObj+" Obj "+hierSet);
//                                
//                                    if (comNodeClustToFlatClust.get(obj) != null) {
//                                        System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
//                                    }
//                                    set.add(comNodeClustToFlatClust.get(obj));
//                                }
////                                else {
////                                    System.out.println("No!");
////                                }
////                                Set tmpSet = null;
//                                
////                                for (Entry<Set,Set> entry : flatClustToComNodeClust.entrySet()){
//////                                    System.out.println(entry.getValue());
//////                                    if (isContainedIn(bioObj, entry.getValue())){
//////                                        System.out.println("Entry getvalue (Com Node) "+entry.getValue()+" key (flat clust) "+entry.getKey());
//////                                    }
////                                    if (entry.getValue().equals(hierSet)){
//////                                    if (((Set)entry.getValue()).containsAll((Set)obj)){
////                                        tmpSet =  entry.getKey();
////                                        break;
////                                    }
////                                }
////                                if (tmpSet != null){
////                                    System.out.println("tmp Set: "+tmpSet);
////                                    set.add(tmpSet);
////                                } else {
//////                                    System.out.println("Oh no");
////                                }
////                                System.out.println("");
//                            }
//                            
//                            curCSet = set;
////                            System.out.println(flatClustToComNodeClust.get(vertex));
//                            System.out.println("curCSet: " + curCSet);
//                            System.out.println("curComNodeSet: "+curComNodeCSet);
//                            
//                                                        
//                            layout.initialize();
//
//                            Relaxer relaxer = new VisRunner((IterativeContext) layout);
//                            relaxer.stop();
//                            relaxer.prerelax();
//                            
//                            GOProcessor gp = new GOProcessor();
//                            gp.populateGOTerms(curCSet);
////                            if (!lastLevel){
//                                /* In the case which cSet is the set of BioObject, curCSet is the same as curComNodeCSet */
//                            curCSetBeforeVisClust = curCSet;
//                            curComNodeCSetBeforeVisClust = curComNodeCSet;
//                            curGOP = gp;
//                            System.out.println("GO Proc size before (Relouvain) Vis clust: " + curGOP.clusterScoreMap.size());
//                            
////                            }
//                            
//                            if (curCSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
////                              /* can be customized whether to do reLouvainCluster or not */
//                                reLouvainCluster(curCSetBeforeVisClust, true);
//                                
////                                if (!lastLevel)
////                                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSet, curCSet, Integer.parseInt(thresholdTextField.getText()));
////                                else{
////                                    semanticClusterList = gp.preCluster(curCSet, Integer.parseInt(thresholdTextField.getText()));
////                                }
////                                    
////                                curCSet = transformDataClusterList(semanticClusterList, false,true);
////                                System.out.println("cur C Set after seman clust: "+curCSet);
////                                
//////                                dynamicGraph = createGraphFromCSet(curCSet);
////                                dynamicGraph = createGraph(curCSet);
////                                colorCluster(curCSet, mainColor);
////                                
//                                
//                                
//                            } else {
//                                putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
//                                if (lastLevel) {
//                            
////                                    medp.setLowestLevel(true);
//                                    zoomInButton.setEnabled(false);
////                                    dynamicGraph = createGraphFromBioNodeSet(curCSet);
//                                    dynamicGraph = createGraph(curCSet);
//                                } else {
//                            
//                                    System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
////                                    dynamicGraph = createGraphFromCSet(curCSet);
//                                    dynamicGraph = createGraph(curCSet);
//                                    colorCluster(curCSet, mainColor);
//                                }
//                            }
//
//
////        colorTopLevel(newgraph);
////        dynamicGraph = updateMetaEdges(dynamicGraph);
////        System.out.println("Dynamic Graph:"+dynamicGraph);
//                            
//                            layout.setGraph(dynamicGraph);
//                            currentLevelGraph = dynamicGraph;
//                            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                            
////                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
//                            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
////                            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), layout);
////                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
////                                    staticLayout);
//                            Animator animator = new Animator(lt);
//                            animator.start();
//                            
////        layout.setGraph(newgraph);
//                            vv.repaint();
////                            reLouvainCluster(curCSetBeforeVisClust, true);
//               
////                        }
                        }
                    }
                }
//                System.out.println(e.getSource());
            }
        }
       
        public void mouseEntered(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(cursor);
        }

        public void mouseExited(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }

        public void mouseMoved(MouseEvent e) {
        }

        public void mousePressed(MouseEvent e) {
            
        }

        public void mouseReleased(MouseEvent e) {
           
        }
    }
    public class VertexFontTransformer implements Transformer<Object,Font>{
        
        public Font transform(Object vertex) {
           return new Font("Serif",Font.PLAIN,13);
        }
        
    }
    public class GOStringLabeller extends ToStringLabeller {
        /* (non-Javadoc)
         * @see edu.uci.ics.jung.visualization.decorators.DefaultToolTipFunction#getToolTipText(java.lang.Object)
         */

        @Override
        public String transform(Object v) {

            String res = "<html><center>";

            if (v instanceof Set) {

                DataVector vec = nodesGOVectorMap.get(v);
                        
                if (vec != null) {

                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
//                                IdentifiedObject obj = obosession.getObject((String)entry.getKey());
//                                res += "<p>" + entry.getKey() + " with " + entry.getValue();
//                                String toPrint = obj.getName();
                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();
                        
                        if (toPrint.length() > 20) {
                            toPrint = toPrint.substring(0, 20);
                            toPrint += "...";
                        }
//                                if (i > 1)
//                                    res += "";
                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());
                        
                        res += "<p>";
                        if (goTerm.getNamespace().equals(NameSpace.CC))
                            res += "<font color = #ED143F>";
                        else if (goTerm.getNamespace().equals(NameSpace.MF)) 
                            res += "<font color = #338F06>";
                        else 
                            res += "<font color = #3425B1>";
                        res += toPrint + " (" + output + ")";
                        res += "</font>";
                        i++;
                        if (i == 3) {
                            break;
                        }
                    }
                    res += "</center></html>";
                } else {

                    res += "#Nodes: " + ((Set) v).size();
                    res += "</html>";
//                            System.out.println("!!!");
                }
            } else if (v instanceof BioObject) {
                res += ((BioObject)v).getName();
//                res += "#Nodes: " + findNoMemInHier(v);
                res += "</html>";

            }

            return res;
        }
    }
    private final class VertexShapeSizeAspect<V, E>
            extends AbstractVertexShapeTransformer<V>
            implements Transformer<V, Shape> {

//        protected boolean stretch = false;
//        protected boolean scale = false;
//        protected boolean funny_shapes = false;
//        protected Map<V, Number> voltages;
//        protected Graph<V, E> graph;
//        protected AffineTransform scaleTransform = new AffineTransform();
        public Shape transform(V v) {
//            if (funny_shapes) {
//                if (realGraph.degree(v) < 5) {
//                    int sides = Math.max(realGraph.degree(v), 3);
//                    return factory.getRegularPolygon(v, sides);
//                } else {
//                    return factory.getRegularStar(v, realGraph.degree(v));
//                }
//            } else {
            if (v instanceof BioObject)
                return factory.getRectangle(v);
            return factory.getEllipse(v);
//            }
        }
        public VertexShapeSizeAspect(Graph<V, E> graphIn) {//, Map<V, Number> voltagesIn) {
//            this.graph = graphIn;
//            this.voltages = voltagesIn;
            setSizeTransformer(new Transformer<V, Integer>() {

                public Integer transform(V v) {
//                    if (scale) {
                    int numMember = 0;

                    if (v instanceof Set) {
                        
                        numMember = ((Set)v).size();
                        int value = (int) (Math.log10(numMember) / Math.log10(4) * 20);
                        if (numMember == 0)
                            return 20;
                        else if (value < 20)
                            return 20;
                        else 
                            return value;
//                        System.out.println("");
//                        System.out.println("Ver: "+v+" Num member: "+numMember);
//                        System.out.println("");
//                        return (int) ((Graph) v).getVertexCount() * 15;
//                       System.out.println("num mem: "+numMember+" size: "+(Math.log10(numMember)/Math.log10(2)*20));
//                        return (int) (Math.log10(numMember) / Math.log10(4) * 20);


                    } else
                    {
                        return 20;
                    }
                }
            });
            
           

        }


    }

    public class PickedEdgePaintFunction<V, E> implements Transformer<E,Paint>{

        private Transformer<E, Paint> defaultFunc;
//        protected boolean fill_edge = false;
//        Predicate<Context<Graph<V, E>, E>> selfLoop = new SelfLoopEdgePredicate<V, E>();

        public PickedEdgePaintFunction(Transformer<E, Paint> defaultEdgePaintFunction,
                                               VisualizationViewer<V, E> vv) {
//            super(Color.WHITE, Color.BLACK, vv);
            this.defaultFunc = defaultEdgePaintFunction;
        }

//        public void useFill(boolean b) {
//            fill_edge = b;
//        }

        public Paint transform(E e) {
//            if (gradient_level == GRADIENT_NONE) {
            if (e instanceof SemanticEdge)
                return new Color(182,182,182);
            else
                return defaultFunc.transform(e);
//            } else {
//                return super.transform(e);
//            }
        }

//        protected Color getColor2(E e) {
//            return vv.getPickedEdgeState().isPicked(e) ? Color.CYAN : c2;
//        }//        public Paint getFillPaint(E e)
//        {
//            if (selfLoop.evaluateEdge(vv.getGraphLayout().getGraph(), e) || !fill_edge)
//                return null;
//            else
//                return getDrawPaint(e);
//        }
    }

    private final class LayoutChooser implements ActionListener {

        private final JComboBox jcb;
        private final VisualizationViewer<Object, Object> vv;

        private LayoutChooser(JComboBox jcb, VisualizationViewer<Object,Object> vv)
        {
            super();
            this.jcb = jcb;
            this.vv = vv;
        }

        public void actionPerformed(ActionEvent arg0)
        {
            Object[] constructorArgs = {dynamicGraph};

            Class<? extends Layout<Integer,Number>> layoutC = 
                (Class<? extends Layout<Integer,Number>>) jcb.getSelectedItem();
//            Class lay = layoutC;
            try
            {
                Constructor<? extends Layout<Integer, Number>> constructor = layoutC
                        .getConstructor(new Class[] {Graph.class});
                Object o = constructor.newInstance(constructorArgs);
                Layout<Object,Object> l = (Layout<Object,Object>) o;
                l.setInitializer(vv.getGraphLayout());
                l.setSize(vv.getSize());
                
                LayoutTransition<Object, Object> lt =
                        new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), l);
                Animator animator = new Animator(lt);
                animator.start();
                vv.getModel().setGraphLayout(l);
                
                vv.getRenderContext().getMultiLayerTransformer().setToIdentity();
                vv.repaint();
                
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
    
   
    
}
class SemanticEdge extends Object{
    String name = "";

    public double getInnerProduct() {
        return innerProduct;
    }

    public void setInnerProduct(double innerProduct) {
        this.innerProduct = innerProduct;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    DataVector dv1, dv2;
    double innerProduct = 0;
    public SemanticEdge(String name,DataVector dv1, DataVector dv2){
        this.name = name;
        this.dv1 = dv1;
        this.dv2 = dv2;
        innerProduct = KMeanClusterer.similarity(dv1, dv2);
    }
    @Override
    public String toString() {
        return "Inner Product: " + innerProduct;
    }
}
class MetaEdge<E> extends Object {

    String name = "";
    Set<E> edgeSetBundled = new HashSet<E>();
    int numEdgeSetBundled = 0;
    //Intentionally not clone or copy. Just refer to the edgeSet
    public MetaEdge(String s, Set<E> edgeSet) {
        name = s;
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }
    public MetaEdge(String s, E edge) {
        name = s;
        this.addEdge(edge);
    }
    public MetaEdge(String s) {
        name = s;
        
    }

    public void setName(String s) {
        name = s;
    }

    public void setEdgeSetBundled(Set<E> edgeSet) {
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }

    public void addEdge(E edge){
        edgeSetBundled.add(edge);
        numEdgeSetBundled += 1;
    }
    public String getName() {
        return name;
    }

    public Set<E> getEdgeSetBundled() {
        return edgeSetBundled;
    }

    public int getNumEdgeSetBundled() {
        return numEdgeSetBundled;
    }

    @Override
    public String toString() {
        return "Num edge: " + numEdgeSetBundled + " " + edgeSetBundled;
    }
}

