/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package main;

/**
 *
 * @author Knacky
 */
import edu.uci.ics.jung.algorithms.layout.AggregateLayout;
import edu.uci.ics.jung.algorithms.layout.CircleLayout;
import edu.uci.ics.jung.algorithms.layout.FRLayout;
import edu.uci.ics.jung.algorithms.layout.GraphElementAccessor;
import edu.uci.ics.jung.algorithms.layout.ISOMLayout;
import edu.uci.ics.jung.algorithms.layout.KKLayout;
import edu.uci.ics.jung.algorithms.layout.Layout;

import edu.uci.ics.jung.algorithms.layout.SpringLayout;
import edu.uci.ics.jung.algorithms.layout.SpringLayout2;
import edu.uci.ics.jung.algorithms.layout.StaticLayout;
import edu.uci.ics.jung.algorithms.layout.util.Relaxer;
import edu.uci.ics.jung.algorithms.layout.util.VisRunner;
import edu.uci.ics.jung.algorithms.transformation.DirectionTransformer;


import edu.uci.ics.jung.algorithms.util.IterativeContext;
import edu.uci.ics.jung.graph.Graph;


import edu.uci.ics.jung.graph.SparseMultigraph;
import edu.uci.ics.jung.graph.UndirectedSparseGraph;

import edu.uci.ics.jung.graph.util.Context;
import edu.uci.ics.jung.graph.util.DefaultParallelEdgeIndexFunction;
import edu.uci.ics.jung.graph.util.Pair;
import edu.uci.ics.jung.io.PajekNetReader;

import edu.uci.ics.jung.visualization.GraphZoomScrollPane;

import edu.uci.ics.jung.visualization.RenderContext;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.AbstractGraphMousePlugin;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;

import edu.uci.ics.jung.visualization.decorators.AbstractVertexShapeTransformer;
import edu.uci.ics.jung.visualization.decorators.EdgeShape;
import edu.uci.ics.jung.visualization.decorators.EdgeWeightLabeller;
import edu.uci.ics.jung.visualization.decorators.NumberEdgeValue;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.layout.LayoutTransition;
import edu.uci.ics.jung.visualization.renderers.Renderer;
import edu.uci.ics.jung.visualization.subLayout.GraphCollapser;
import edu.uci.ics.jung.visualization.util.Animator;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JApplet;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JToggleButton;
import javax.swing.filechooser.FileFilter;
import kmean.DataCluster;
import kmean.DataVector;
import kmean.MeanVector;
import org.apache.commons.collections15.Factory;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.collections15.Transformer;
import org.apache.commons.collections15.functors.ConstantTransformer;
import org.apache.commons.collections15.functors.MapTransformer;
import org.apache.commons.collections15.map.LazyMap;
import org.geneontology.oboedit.dataadapter.OBOParseException;
import util.StopWatch;
import main.GOProcessor;
import org.geneontology.oboedit.datamodel.IdentifiedObject;
import org.geneontology.oboedit.datamodel.OBOSession;


/**
 *
 * @author Knacky
 */
public class LouvainClustererTest_1 extends JFrame {

    private boolean UIWanted;
    private String stringStream = "";
//    private static final Object DEMOKEY = "DEMOKEY";
    VisualizationViewer<Object, Object> vv;//	Factory<Graph<Number,Number>> graphFactory;
    Map<Object, Paint> vertexPaints =
            LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.white));
    Map<Object, Paint> edgePaints =
            LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.BLACK));
    Map<Integer, BioObject> nodeMap = new HashMap<Integer, BioObject>();
    public final Color[] similarColors = {
        new Color(216, 134, 134),
        new Color(135, 137, 211),
        new Color(134, 206, 189),
        new Color(206, 176, 134),
        new Color(194, 204, 134),
        new Color(145, 214, 134),
        new Color(133, 178, 209),
        new Color(103, 148, 255),
        new Color(60, 220, 220),
        new Color(30, 250, 100)
    };

    private static Class<? extends Layout>[] getLayoutCombos()
    {
        List<Class<? extends Layout>> layouts = new ArrayList<Class<? extends Layout>>();
        layouts.add(KKLayout.class);
        layouts.add(FRLayout.class);
        layouts.add(CircleLayout.class);
        layouts.add(SpringLayout.class);
        layouts.add(SpringLayout2.class);
        layouts.add(ISOMLayout.class);
        return layouts.toArray(new Class[0]);
    }
    
    public static void main(String[] args) {
//        KleinbergSmallWorldGenerator kg = new KleinbergSmallWorldGenerator(6, 2.5);
//        Graph realGraph;
//        realGraph = (Graph) kg.generateGraph();
//        System.out.println("num node: " + realGraph.numVertices() + " num edge: " + realGraph.numEdges());

//        // Add a restart button so the realGraph can be redrawn to fit the size of the frame
        LouvainClustererTest test = new LouvainClustererTest();
//        test.setName("Interactive Bio Graph Explorer");
        test.setTitle("Interactive Bio Graph Explorer");

//        JFrame jf = new JFrame();
//        
//        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//        test.setPreferredSize(new Dimension(500, 500));
//        JFrame.setDefaultLookAndFeelDecorated(true);

//        jf.getContentPane().add(test);
        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        test.start();

        test.pack();
//        test.setLocationByPlatform(true);
        test.setVisible(true);
        
//        test.validate();
//        jf.pack();
//        jf.setVisible(true);
//        jf.validate();

    }
    private double threshold;
    private MetaEdgeDisplayPredicate medp;
    private EdgeWeightLabeller ew;
//    /** Initializes the applet NewJApplet */
//    public void init() {
//        try {
//            java.awt.EventQueue.invokeAndWait(new Runnable() {
//                public void run() {
//                    start();
//                }
//            });
//        } catch (Exception ex) {
//            ex.printStackTrace();
//        }
//    }
    public Graph<Object, Object> loadModNet(BufferedReader br) throws IOException {

//        int tNumLinks = 0;
        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1, numNode = -1;


        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        BioObject bioObj = null;
//        if (UIWanted){
//            StringLabeller sl = StringLabeller.getLabeller(newgraph,"node name");
//        EdgeWeightLabeller ew = EdgeWeightLabeller.getLabeller(newgraph,"weight");
        //check header
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Vertices")) {
                    numNode = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        int id = -1;
        String stdName = "", name = "", sgdid = "", type = "";
        String goId = "", ref = "", aspect = "";
        for (int i = 0; i < numNode; i++) {
//        while ((st = br.readLine()) != null){
            st = br.readLine();
//            System.out.println(st);
            stn = new StringTokenizer(st, "\t", true);
            assert (stn.hasMoreTokens());
            id = Integer.parseInt(stn.nextToken());
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            stdName = stn.nextToken();
            if (stdName.equals("\t")) {
                stdName = "";
            } else {
                stn.nextToken();
            }

            assert (stn.hasMoreTokens());
            name = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            sgdid = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            if (sgdid.equals("\t")) {
                bioObj = new BioObject(id, name);
                bioObj.setStandardName(stdName);
            } else {
//                assert (stn.hasMoreTokens());
//                sgdid = stn.nextToken();
//                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                type = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                goId = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                ref = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                aspect = stn.nextToken();
//            if (stn.nextToken().equals("\t"));


                bioObj = new BioObject(id, sgdid, name);
                bioObj.setStandardName(stdName);
                bioObj.setType(type);

                StringTokenizer stz = new StringTokenizer(goId, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getGoIdList().add(stz.nextToken());
                }


//                System.out.println(ref);
                stz = new StringTokenizer(ref, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getRefList().add(stz.nextToken());
                }

                stz = new StringTokenizer(aspect, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getAspectList().add(stz.nextToken());
                }
            }
            newgraph.addVertex(bioObj);
            nodeMap.put(id, bioObj);
        }
        int numEdge = -1;
        //check header
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Edges")) {
                    numEdge = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }

        ew = new EdgeWeightLabeller<Number>();
        for (int i = 0; i < numEdge; i++) {
//        while ((st = br.readLine()) != null) {
            st = br.readLine();
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
            stringStream += src + "\t" + dest + "\t";
//            Number vSrc = null,vDest = null;
//            newgraph.addVertex(src);
//            newgraph.addVertex(dest);

//            System.out.println("src: "+src+" dest: "+dest);
            String e1 = src + ":" + dest;
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
                stringStream += weight;
                ew.setWeight(e1, weight);
            }
            stringStream += "\n";

            newgraph.addEdge(e1, nodeMap.get(src), nodeMap.get(dest));
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));




//            if (!newVertexSet.get(indStart).isNeighborOf(new/VertexSet.get(indEnd)))
////            if (edgeToDraw.getEqualEdge(g) == null)
////            if (!newgraph.getEdges().contains(edgeToDraw))
//            {
//                newgraph.addEdge(edgeToDraw);
//                edgeToDraw.addUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight , UserData.SHARED);
//            }
//            else
//            {
////                edgeToDraw = (Edge) edgeToDraw.getEqualEdge(newgraph);
//                edgeToDraw = (Edge) newVertexSet.get(indStart).findEdge(newVertexSet.get(indEnd));
////                System.out.println(edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight"));
//                Float oldWeight = (unweighted)? new Float(1):(Float) edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
////                oldWeight = (Float)edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
//                edgeToDraw.setUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight+oldWeight , UserData.SHARED);
//            }

        }

        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
        System.out.println("Num nodes double checked: " + numNode + " Num edges double checked: " + numEdge);
//        }


//        System.out.println(newgraph.getEdges());
        return newgraph;
//        return null;
    }

    public Graph<Object, Object> load(BufferedReader br) throws IOException {

//        int tNumLinks = 0;
        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1;


        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();

//        if (UIWanted){
//            StringLabeller sl = StringLabeller.getLabeller(newgraph,"node name");
//        EdgeWeightLabeller ew = EdgeWeightLabeller.getLabeller(newgraph,"weight");
        ew = new EdgeWeightLabeller<Number>();

        while ((st = br.readLine()) != null) {
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
//            Number vSrc = null,vDest = null;
            newgraph.addVertex(src);
            newgraph.addVertex(dest);
//            if (!newgraph.getVertices().contains(src)){
//                newgraph.addVertex(src);
//                
//            } else {
//                
//            }
//            if (sl.getVertex(Integer.toString(src)) == null){
//                try {
//                    vSrc = newgraph.addVertex(new UndirectedSparseVertex());
//                    sl.setLabel(vSrc, Integer.toString(src));
//                } catch (UniqueLabelException ex) {
//                    Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//                }
//            }
//            else {
//                vSrc = sl.getVertex(Integer.toString(src));
//            }

//            if (sl.getVertex(Integer.toString(dest)) == null){
//                try {
//                    vDest = newgraph.addVertex(new UndirectedSparseVertex());
//                    sl.setLabel(vDest, Integer.toString(dest));
//                } catch (UniqueLabelException ex) {
//                    Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//                }
//            } else {
//                vDest = sl.getVertex(Integer.toString(dest));
//            }
//            System.out.println("src: "+src+" dest: "+dest);
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
            }
            String e1 = src + ":" + dest;
            newgraph.addEdge(e1, src, dest);
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));

            ew.setWeight(e1, weight);


//            if (!newVertexSet.get(indStart).isNeighborOf(new/VertexSet.get(indEnd)))
////            if (edgeToDraw.getEqualEdge(g) == null)
////            if (!newgraph.getEdges().contains(edgeToDraw))
//            {   
//                newgraph.addEdge(edgeToDraw);
//                edgeToDraw.addUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight , UserData.SHARED);
//            }
//            else
//            {
////                edgeToDraw = (Edge) edgeToDraw.getEqualEdge(newgraph);
//                edgeToDraw = (Edge) newVertexSet.get(indStart).findEdge(newVertexSet.get(indEnd));
////                System.out.println(edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight"));
//                Float oldWeight = (unweighted)? new Float(1):(Float) edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
////                oldWeight = (Float)edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
//                edgeToDraw.setUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight+oldWeight , UserData.SHARED);
//            }   

        }

        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
//        }


//        System.out.println(newgraph.getEdges());
        return newgraph;
//        return null;
    }
//    String filename = "src/karate";
//    String filename = "/Users/Knacky/NetBeansProjects/BlondelAlgorithm/src/input";
    String filename = "expmore3.mnet";
//    String filename = "..\\BlondelAlgorithm\\src\\input";
//        String filename = "src/arxiv";
//        String filename = "src/kl265";s
//        String filename = "src/example";       
//        String filename = "src/temp2";
    /*Yeast SGD Data Set*/
//        String filename = "src/all_yeast_intdata.txt";
//          String filename = "src/all_yeast_intdata_noself";
//        String filename = "src/RefMore3intdata";
//        String filename = "src/ExpMore3intdata";
//          String filename = "src/IntMore1intdata";
//          String filename = "src/CurMore1intdata";
//          String filename = "src/CurHighintdata";
//          String filename = "src/CurManintdata";
//        String filename = "src/ItoT_intdata";
    File fileToOpen = null;
    Graph<Object, Object> realGraph, originalGraph;
    Graph dynamicGraph;
    AggregateLayout<Object, Object> layout;
    GraphCollapser collapser;
    JButton collapseButton;
    JButton expandButton;
//    @Override
    public void start() {
        threshold = 0.000001;

//        UIWanted = false;
        UIWanted = true;
//        File f = new File("src/input.txt");
//        File f = new File("src/ItoT_intdata.net");
//        File f = new File(filename+".net");
//        File f = new File("src/example.net");
//        System.out.println(f.getAbsolutePath());

//        System.out.println(f.getAbsolutePath());

        Factory<Object> vertexFactory = new Factory<Object>() {

            int n = 0;

            public Number create() {
                return n++;
            }
        };
        Factory<Object> edgeFactory = new Factory<Object>() {

            int n = 0;

            public String create() {
                return "" + (n++);
            }
        };


        try {
//            JFileChooser fileChooser = new JFileChooser(new File(filename + ".txt"));
//            fileChooser.setAcceptAllFileFilterUsed(false);
//            fileChooser.addChoosableFileFilter(new TextFileFilter());

//            System.out.println(new File(filename+".txt").getPath());
//            fileChooser.showOpenDialog(LouvainClustererTest.this);
//            fileToOpen = fileChooser.getSelectedFile();
            fileToOpen = new File(filename);
            if (fileToOpen == null) {
                fileToOpen = new File(filename + ".txt");

            }
            System.out.println(fileToOpen.getName());
//            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
//            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filename+".txt"))));
            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));


            PajekNetReader<Graph<Object, Object>, Object, Object> pnr =
                    new PajekNetReader<Graph<Object, Object>, Object, Object>(vertexFactory, edgeFactory);

            realGraph = new SparseMultigraph<Object, Object>();




            StopWatch loadingTime = new StopWatch();
            loadingTime.start();
//             PajekNetReader pnr = new PajekNetReader();
//            Graph realGraph = pnr.load(br,new UserDatumNumberEdgeValue("jung.io.PajekNetFile.EdgeWeight",UserData.SHARED));
//            Graph realGraph = pnr.load(br);
//            pnr.load(br, realGraph);
//            realGraph = load(br);
            realGraph = loadModNet(br);
            originalGraph = realGraph;
            dynamicGraph = realGraph;
            loadingTime.stop();
            System.out.println("Loading Time: " + loadingTime);
            collapser = new GraphCollapser(realGraph);
//            System.out.println("After loading");

//            System.exit(0);
//            realGraph = DirectionTransformer.toUndirected((Graph)realGraph);
//            realGraph = new SparseGraph();

//            int numnode = 305;//1462
//            int numedge = 6942;
            int numnode = 928;//2708
            int numedge = 7120;
//            int numnode = 2928;//2708
//            int numedge = 10000;
//            int numedgeperstep = 6;
            int numedgeperstep = 4;
//            int numedgeperstep = 4;

            /*Generate Graph using models*/
//            BarabasiAlbertGenerator ba = new BarabasiAlbertGenerator(numnode, numedgeperstep);
//            KleinbergSmallWorldGenerator kg = new KleinbergSmallWorldGenerator(10, 2.5);
//            realGraph.getEdgeConstraints().add(Graph.UNDIRECTED_EDGE);
//            realGraph = DirectionTransformer.toUndirected((Graph)kg.generateGraph());
//            StopWatch baGenTime= new StopWatch();
//            baGenTime.start();
//            realGraph = (Graph)ba.generateGraph();
//            ba.evolveGraph((int)numedge/numedgeperstep);
//            baGenTime.stop();
//            System.out.println("BA Gen Time: "+baGenTime);
//            PajekNetWriter pnw = new PajekNetWriter();
//            pnw.save(realGraph, "ba2708_7120_step4.out");
//           
//            System.exit(0);
//            Set<Vertex> vertices = realGraph.getVertices();
//            for (Vertex v : vertices){
//                System.out.println(v);
//            }

//            Set<Edge> edges = realGraph.getEdges();
//            for (Edge e : edges)
//            {
//                System.out.println(e.getUserDatum("jung.io.PajekNetFile.EdgeWeight").getClass());
//            }

//            final SubLayoutDecorator layout = new SubLayoutDecorator(new FRLayout(realGraph));
//            layout = new AggregateLayout<Object, Object>(new FRLayout<Object, Object>(realGraph));
//            layout = new AggregateLayout<Object, String>(new SpringLayout<Object, String>(realGraph));
            layout = new AggregateLayout<Object, Object>(new CircleLayout<Object, Object>(realGraph));

//            System.out.println("After layout");

            vv = new VisualizationViewer<Object, Object>(layout);//,new Dimension(700, 600));
            vv.setBackground(Color.white);
            System.out.println("vv "+vv.getSize());
            DefaultParallelEdgeIndexFunction dpeif = DefaultParallelEdgeIndexFunction.getInstance();
            vv.getRenderContext().setParallelEdgeIndexFunction(dpeif);
            medp = new MetaEdgeDisplayPredicate();
//            vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line<Object,Object>());
            vv.getRenderContext().setEdgeLabelTransformer(new EdgeLabeller(ew));
            vv.getRenderContext().setEdgeIncludePredicate(medp);
            //Tell the renderer to use our own customized color rendering
            
            vv.setVertexToolTipTransformer(new NumMemberGOTips());
            vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller() {

                /* (non-Javadoc)
                 * @see edu.uci.ics.jung.visualization.decorators.DefaultToolTipFunction#getToolTipText(java.lang.Object)
                 */
                @Override
                public String transform(Object v) {
//                    int numMember = 0;
//
//                    if (v instanceof Graph) {
////                        numMember = numMemberInClusteredGraph(v);
//                        numMember = findNoMemInHier(v);
////                        System.out.println("");
////                        System.out.println("Ver: "+v+" Num member: "+numMember);
////                        System.out.println("");
////                        return (int) ((Graph) v).getVertexCount() * 15;
//                        return numMember + " nodes";
////                        return ((Graph) v).getVertices().size()+" nodes";
//                    } else {
//                        return super.transform(v);
//                    }
                    String res = "<html><center>";
                    
                    if (v instanceof Graph) {
                                                
                        DataVector vec = nodesGOVectorMap.get(v);
                        if (vec == null){
                            Graph vertex = (Graph) v;
                            for (Object ver : nodesGOVectorMap.keySet()) {
                                if (ver instanceof Graph) {
                                    Graph vv = (Graph) ver;
//                            Set verSet = new HashSet(vv.getVertices());
                                    Object rest = findVertex(vv, vertex);
                                    if (rest != null) {
                                        System.out.println("rest : " + vv);
                                        vec = nodesGOVectorMap.get(ver);
                                        break;
                                    }
                                }
                            }
                        }
                        
                            
                        if (vec != null) {

                            Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                                public int compare(Object o1, Object o2) {
                                    Entry<String, Double> e1 = (Entry<String, Double>) o1;
                                    Entry<String, Double> e2 = (Entry<String, Double>) o2;
                                    if (e1.getValue() > e2.getValue()) {
                                        return -1;
                                    } else if (e1.getValue() < e2.getValue()) {
                                        return 1;
                                    } else {
                                        return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                                    }
                                }
                            });
                            sortedMap.addAll(vec.getValueMap().entrySet());
                            int i = 0;
                            for (Entry entry : sortedMap) {
//                                IdentifiedObject obj = obosession.getObject((String)entry.getKey());
//                                res += "<p>" + entry.getKey() + " with " + entry.getValue();
//                                String toPrint = obj.getName();
                                String toPrint = GOProcessor.goTermsMap.get((String)entry.getKey()).getName();
                                if (toPrint.length() > 20){
                                    toPrint = toPrint.substring(0, 20); 
                                    toPrint += "...";
                                }
//                                if (i > 1)
//                                    res += "";
                                DecimalFormat myFormatter = new DecimalFormat(".00");
                                String output = myFormatter.format(entry.getValue());

                                res +=  "<p>"+toPrint + " (" + output+")"; 
                                i++;
                                if (i == 3) {
                                    break;
                                }
                            }
                            res += "</center></html>";
                        } else {
//                            Graph vertex = (Graph) v;
//                            for (Object ver : nodesGOVectorMap.keySet()) {
//                                if (ver instanceof Graph) {
//                                    Graph vv = (Graph) ver;
////                            Set verSet = new HashSet(vv.getVertices());
//                                    Object rest = findVertex(vv, vertex);
//                                    if (rest != null) {
//                                        System.out.println("rest : " + vv);
//                                    }
//                                }
//                            }
//                            System.out.println("");
                            res += "#Nodes: " + findNoMemInHier(v);
                            res += "</html>";
//                            System.out.println("なぜ!!!");
                        }
                    } else {
                        
                        res += "#Nodes: " + findNoMemInHier(v);
                        res += "</html>";
                        
                    }

                    return res;
                }
            });

            vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
//            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(realGraph));
            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(dynamicGraph));


            vv.getRenderContext().setVertexFillPaintTransformer(MapTransformer.<Object, Paint>getInstance(vertexPaints));
            vv.getRenderContext().setVertexDrawPaintTransformer(new Transformer<Object, Paint>() {

                public Paint transform(Object v) {
                    if (vv.getPickedVertexState().isPicked(v)) {
                        return Color.cyan;
                    } else {
                        return Color.BLACK;
                    }
                }
            });

            vv.getRenderContext().setEdgeDrawPaintTransformer(MapTransformer.<Object, Paint>getInstance(edgePaints));

            vv.getRenderContext().setEdgeStrokeTransformer(new EdgeWeightStrokeFunction(ew));
//            vv.getRenderContext().setEdgeStrokeTransformer(new Transformer<Object, Stroke>() {
//
//                protected final Stroke THIN = new BasicStroke(1);
//                protected final Stroke THICK = new BasicStroke(2);
//
//                public Stroke transform(Object e) {
//                    Paint c = edgePaints.get(e);
//                    if (c == Color.LIGHT_GRAY) {
//                        return THIN;
//                    } else {
//                        return THICK;
//                    }
//                }
//            });


            final JToggleButton groupVertices = new JToggleButton("Group Clusters");

//            final VisualizationViewer vv = new VisualizationViewer(layout, pr,new Dimension(550,550));

//            getContentPane().add(vv);
//            System.out.println("Visualization Viewer");


            //Tell the renderer to use our own customized color rendering
            JButton openFile = new JButton("Open");
            openFile.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
//                    File ff = new File("../NetBeansProjects/BlondelAlgorithm/src");
//                    System.out.println(ff.getPath());
                    JFileChooser fileChooser = new JFileChooser(fileToOpen);
                    File tempFile = fileToOpen;
//                    fileChooser.addChoosableFileFilter(new TextFileFilter());
                    fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                    fileChooser.setFileFilter(new TextFileFilter());
//                    fileChooser.setFileHidingEnabled(false);
                    fileChooser.showOpenDialog(LouvainClustererTest.this);
                    fileToOpen = fileChooser.getSelectedFile();
                    if (fileToOpen != null) {
                        try {
                            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));

//                            realGraph = load(br);
                            realGraph = loadModNet(br);
                            originalGraph = realGraph;
                            collapser = new GraphCollapser(realGraph);
                            layout.setGraph(realGraph);
                            dynamicGraph = realGraph;
//                            AggregateLayout<> l = new SubLayoutDecorator(new FRLayout(realGraph));
//                            layout = l;
//                            layout = new ISOMLayout(realGraph);

                            vv.setGraphLayout(layout);
                            clusterAndRecolor(layout, similarColors, groupVertices.isSelected(), true);
                            vv.getRenderContext().getParallelEdgeIndexFunction().reset();

                            System.out.println("Group Vertices: " + groupVertices.isSelected());
//                            vv.restart();
                            layout.initialize();
                            Relaxer relaxer = vv.getModel().getRelaxer();
                            if (relaxer != null) {
                                relaxer.stop();
                                relaxer.prerelax();
                                relaxer.relax();
                            }
                            currentLevel = 0;
                            collapseButton.setEnabled(false);
                            expandButton.setEnabled(true);

                        } catch (IOException ex) {
                            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    } else {
                        fileToOpen = tempFile;
                    }
                }
            });

//            System.out.println(System.getProperties().getProperty("user.dir"));
//            System.out.println(new File("/").getPath());
//            System.out.println(new File("/").getAbsolutePath());
//            System.out.println(new File("/").getCanonicalPath());
//            System.out.println(new File("/").getParent());
//            System.out.println(new File("/").getName());
//            for (String ss : new File("/").list()){
//                System.out.println(ss);
//            }
//            System.out.println(new File("/").list()[2]);
            JButton saveButton = new JButton("Save");
            saveButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    JFileChooser chooser = new JFileChooser(new File("/Users/Knacky/Desktop"));
//                    chooser.setAcceptAllFileFilterUsed(false);
                    int option = chooser.showSaveDialog(LouvainClustererTest.this);

                    if (option == JFileChooser.APPROVE_OPTION) {
                        File file = chooser.getSelectedFile();
                        int width = vv.getWidth();
                        int height = vv.getHeight();

                        BufferedImage bi = new BufferedImage(width, height,
                                BufferedImage.TYPE_INT_RGB);
                        Graphics2D graphics = bi.createGraphics();
                        vv.paint(graphics);
                        graphics.dispose();

                        try {
                            ImageIO.write(bi, "jpeg", file);
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                    }
                }
            });

            //add restart button
            JButton scramble = new JButton("Restart");
            scramble.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
                    Layout layout = vv.getGraphLayout();
                    layout.initialize();
                    Relaxer relaxer = vv.getModel().getRelaxer();
                    if (relaxer != null) {
                        relaxer.stop();
                        relaxer.prerelax();
                        relaxer.relax();
                    }
                }
            });

            DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
            vv.setGraphMouse(gm);
            
            gm.add(new DoubleClickZoomInPlugin<Object,Object>());



//		edgeBetweennessSlider.setBorder(BorderFactory.createLineBorder(Color.black));
            //TO DO: edgeBetweennessSlider.add(new JLabel("Node Size (PageRank With Priors):"));
            //I also want the slider value to appear
            final JPanel eastControls = new JPanel();
            eastControls.setOpaque(true);
            eastControls.setLayout(new BoxLayout(eastControls, BoxLayout.Y_AXIS));
            eastControls.add(Box.createVerticalGlue());


            //eastControls.add(eastSize);
            eastControls.add(Box.createVerticalGlue());

            groupVertices.addItemListener(new ItemListener() {

                public void itemStateChanged(ItemEvent e) {

//                        clusterAndRecolor(layout, similarColors, e.getStateChange() == ItemEvent.SELECTED, false);
                    recolor(layout, similarColors, e.getStateChange() == ItemEvent.SELECTED);
                    layout.initialize();

                    Relaxer relaxer = new VisRunner((IterativeContext) layout);
                    relaxer.stop();
                    relaxer.prerelax();
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(realGraph, layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(),
                            staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
//				vv.getRenderContext().getMultiLayerTransformer().setToIdentity();
                    vv.repaint();

                }
            });


            collapseButton = new JButton("Collapse");
            collapseButton.setEnabled(false);
            collapseButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
//                    hierCSet.length - 1 - 1 - displayHieBox.getSelectedIndex()
                    layout.initialize();

                    Relaxer relaxer = new VisRunner((IterativeContext) layout);
                    relaxer.stop();
                    relaxer.prerelax();
//                    dynamicGraph = layout.getGraph();
                    dynamicGraph = realGraph;
                    System.out.println("comnodehierset.length-1 "+(comNodehierSet.length-1));
                    int index = comNodehierSet.length - 1 - currentLevel;
                    
                    System.out.println("\ncomNodeHierSet "+(index)+": " +comNodehierSet[index] +"\n");
                    for (Set clusterOfComNode : comNodehierSet[index]) {
////                    for (int l = 0; l < comNodehierSet[currentLevel-1].size(); l++) {

//                        System.out.println("\nClusterOfComNode: " + clusterOfComNode+"\n");
                        ArrayList toPreCollapse = new ArrayList();
                        toPreCollapse.addAll(clusterOfComNode);

                        /* Codes below is similar to that of precollapse */
//                        dynamicGraph = LouvainClustererTest.this.preCollapse(dynamicGraph,toPreCollapse);

                        ArrayList listComNodeInGraph = new ArrayList();
                        for (Object v : toPreCollapse) {
//            System.out.println("V: "+ v);
                            Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
                            listComNodeInGraph.add(comNodeInGraph);
                        }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
                        Set toCollapseNode = new HashSet();
                        toCollapseNode.addAll(listComNodeInGraph);
//        System.out.println("toCollapseNode: "+toCollapseNode);


                        Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
                        vertexPaints.put(clusterGraph, (Color) vertexPaints.get(listComNodeInGraph.get(0)));
//        System.out.println(clusterGraph);
                        dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);

                    /* end of copied codes */

//                System.out.println(cluster);

                    }
                    dynamicGraph = updateMetaEdges(dynamicGraph);
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
                    layout.setGraph(dynamicGraph);
                    vv.getRenderContext().getParallelEdgeIndexFunction().reset();
//                    System.out.println("\nDynamic Graph: ");
//                    for (Object v : dynamicGraph.getVertices()) {
//                        if (v instanceof Graph) {
//                            System.out.println("Vertex: " + ((Graph) v).getVertices());
//                        } else {
//                            System.out.println("Vertex: " + v);
//                        }
//                    }
                    vv.repaint();
                    expandButton.setEnabled(true);
                    currentLevel--;
                    if (currentLevel == 0) {
                        ((JButton) (arg0.getSource())).setEnabled(false);
                    }
                    System.out.println("\nCollapse complete!!!!\n");
                }
            });

            expandButton = new JButton("Expand");
            expandButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {

                    layout.initialize();

                    Relaxer relaxer = new VisRunner((IterativeContext) layout);
                    relaxer.stop();
                    relaxer.prerelax();

//                    Graph tempGraph = layout.getGraph();
                    Graph tempGraph = realGraph;

                    Collection vertices = tempGraph.getVertices();
//                    System.out.println("\nExpand Start: ");
//                    System.out.println("Current Level: "+currentLevel);
                    System.out.println("current level "+currentLevel+" comNodehierset.length-1 "+(comNodehierSet.length-1));
                    for (Object v : vertices) {
                        boolean isSemiFinalLevel = false;
                        if ((v instanceof Graph)) {
//                            System.out.println("Vertex: "+((Graph)v).getVertices());
//                            System.out.println("Vertex count: "+((Graph)v).getVertexCount());
                            Object vnest = ((Graph) v).getVertices().iterator().next();
                            if (!(vnest instanceof Graph)) {
                                isSemiFinalLevel = true;
                            }
                            
                            if ((currentLevel + 1 >= comNodehierSet.length - 1) || !isSemiFinalLevel) {
//                            Graph g = collapser.expand(layout.getGraph(), (Graph) v);
                                Set set = new HashSet();
                                set.addAll(((Graph) v).getVertices());
                                colorCluster(set, (Color) vertexPaints.get(v));
//                                System.out.println("ver: "+v);
                                Graph g = collapser.expand(tempGraph, (Graph) v);
//                                vv.getRenderContext().getParallelEdgeIndexFunction().reset();
                                tempGraph = g;

//                            System.out.println("\nTemp Graph:");
//                            for (Object ve : tempGraph.getVertices()) {
//                                if (ve instanceof Graph) {
//                                    System.out.println("Vertex: " + ((Graph) ve).getVertices());
//                                } else {
//                                    System.out.println("Vertex: " + ve);
//                                }
//                            }
//                            layout.setGraph(g);

//                                    vv.repaint();
                            }
                        }

//                                vv.repaint();
                    }
                    if (!(vertices.iterator().next() instanceof Graph)) {
                        medp.setLowestLevel(true);
//                    for (Object v : tempGraph.getVertices()){
//                        if (v instanceof Graph){
//                            System.out.println("Vertex: "+((Graph)v).getVertices());
//                        } else
//                            System.out.println("Vertex: "+v);
//                    }
                    }
                    tempGraph = updateMetaEdges(tempGraph);
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(tempGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
//                        }
                    layout.setGraph(tempGraph);
                    vv.getRenderContext().getParallelEdgeIndexFunction().reset();
                    vv.repaint();
                    currentLevel++;
                    collapseButton.setEnabled(true);
                    if (currentLevel == hierCSet.length - 1) {
                        ((JButton) (arg0.getSource())).setEnabled(false);
                    }
                    System.out.println("\nExpand complete!!!!\n");
                }
            });

            JPanel clusterPanel = new JPanel(new GridLayout(2, 1));
            clusterPanel.setBorder(BorderFactory.createTitledBorder("Operations"));
            clusterPanel.add(collapseButton);
            clusterPanel.add(expandButton);

//            displayHieBox.addItemListener(new ItemListener() {
//
//                public void itemStateChanged(ItemEvent event) {
////                    System.out.println(displayHieBox.getSelectedIndex());
////                    System.out.println(currentLevel);
////                    if ((event.getStateChange() == ItemEvent.SELECTED) && (displayHieBox.getSelectedIndex() > currentLevel)) {
//                    if (displayHieBox.getSelectedIndex() > currentLevel){
//                        
//                        clusterSet = hierCSet[hierCSet.length - 1 - 1 - displayHieBox.getSelectedIndex()];
////                        System.out.println("length: "+hierCSet.length);
////                        System.out.println("selected index: "+displayHieBox.getSelectedIndex());
////                        System.out.println("index hi set: "+(hierCSet.length-1-1-displayHieBox.getSelectedIndex()));
////                        System.out.println(hierCSet[hierCSet.length-1-1-displayHieBox.getSelectedIndex()]);
////                        System.out.println("hier 0: "+hierCSet[0]);
////                        vv.restart();
////                        recolor(layout, similarColors, groupVertices.isSelected());
//                        
////                        if (groupVertices.isSelected()) {
//                        layout.initialize();
//
//                            Relaxer relaxer = new VisRunner((IterativeContext) layout);
//                            relaxer.stop();
//                            relaxer.prerelax();
//                            
//                            Collection vertices = layout.getGraph().getVertices();
//                            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(layout.getGraph(), layout);
//                            for (Object v : vertices) {
//                                if (v instanceof Graph) {
//                                    
//                                    
//                                    Graph g = collapser.expand(layout.getGraph(), (Graph) v);
////                                vv.getRenderContext().getParallelEdgeIndexFunction().reset();
//                                    layout.setGraph(g);
//                                    
////                                    vv.repaint();
//                                }
//                                
////                                vv.repaint();
//                            }
//                            
//                            LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayout, vv.getGraphLayout());
////                                    staticLayout);
//                        Animator animator = new Animator(lt);
//                        animator.start();
////                        }
//
//                        vv.repaint();
//                    }
//                    currentLevel=displayHieBox.getSelectedIndex();
////                    throw new UnsupportedOperationException("Not supported yet.");
//                }
//            });
            
            Class[] combos = getLayoutCombos();
            final JComboBox jcb = new JComboBox(combos);
            // use a renderer to shorten the layout name presentation
            jcb.setRenderer(new DefaultListCellRenderer() {

                public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                    String valueString = value.toString();
                    valueString = valueString.substring(valueString.lastIndexOf('.') + 1);
                    return super.getListCellRendererComponent(list, valueString, index, isSelected,
                            cellHasFocus);
                }
            });
            
            
            
            clusterAndRecolor(layout, similarColors, groupVertices.isSelected(), true);
            jcb.addActionListener(new LayoutChooser(jcb, vv));
            jcb.setSelectedItem(CircleLayout.class);

            Container content = getContentPane();
            content.add(new GraphZoomScrollPane(vv));
            JPanel south = new JPanel();
            south.setPreferredSize(new Dimension(180,600));
            JPanel grid = new JPanel(new GridLayout(2, 1));
            JPanel grid2 = new JPanel(new GridLayout(2, 1));
            grid.add(scramble);
//            grid.add(groupVertices);
            grid2.add(openFile);
            grid2.add(saveButton);

            south.add(grid2);
            south.add(grid);
            south.add(clusterPanel);
            south.add(jcb);
//            south.add(displayHieBox);
            south.add(eastControls);
            JPanel p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Mouse Mode"));
            p.add(gm.getModeComboBox());
            south.add(p);
            content.add(south, BorderLayout.EAST);
            pack();
            setVisible(true);

        } catch (IOException e) {
            // TODO Auto-generated catch block
            System.out.println("Error in loading graph");
            e.printStackTrace();
        }
    }
    JComboBox displayHieBox = new JComboBox();
    Set<Set<Object>>[] hierCSet = null;
    Set<Set<Object>>[] comNodehierSet = null;
//    BlondelClusterer clusterer;
    Set<Set<Object>> clusterSet;

//    public BioObject[][] changeToBioObject(int[][] hierarchyComNode){
//
//        return null;
//    }
    public void clusterAndRecolor(AggregateLayout<Object, Object> layout,
                                  Color[] colors, boolean groupClusters, boolean clustering) throws FileNotFoundException, IOException {
        //Now cluster the vertices by removing the top 50 edges with highest betweenness
        //		if (numEdgesToRemove == 0) {
        //			colorCluster( g.getVertices(), colors[0] );
        //		} else {
//        int numClustersWanted = 5;
        Graph<Object, Object> g = layout.getGraph();

        if (clustering == true) {
//            System.out.println("num node: " + g.getVertexCount() + " num edge: " + g.getEdgeCount());
//            clusterer = new BlondelClusterer(threshold);

//        EdgeBetweennessClusterer clusterer =
//                new EdgeBetweennessClusterer(numEdgesToRemove);
            StopWatch stopwatch = new StopWatch();
            stopwatch.start();
//            clusterSet = clusterer.extract(g);
//            clusterer.extractHierarchy(g);
            MainLouvain ml = new MainLouvain();

//            int[][] hierarchyComNode = ml.louvainClusterer(fileToOpen.getPath(),true);
            int[][] hierarchyComNode = ml.louvainClusterer(stringStream, false);
//            BioObject[][] hierBioObjComNode = changeToBioObject(hierarchyComNode);
            System.out.println("After Clustering");
            GOProcessor.loadGOTermsMap();
            clusterSet = processClusterSet(g, hierarchyComNode);
            System.out.println("Process After Clustering");
            stopwatch.stop();
//            displayHieBox = new JComboBox();
            displayHieBox.removeAllItems();
//            System.out.println(displayHieBox.getItemListeners().length);
//            for (ItemListener il : displayHieBox.getItemListeners()){
//                System.out.println(il);
//            }
            for (int i = hierarchyComNode.length - 1 - 1; i >= 0; i--) {
                displayHieBox.addItem("level " + (hierarchyComNode.length - 1 - 1 - i) + " (" + hierarchyComNode[i + 1].length + " clusters)");
            }
            displayHieBox.validate();
//            System.out.println(stopwatch);


            if (!UIWanted) {
                System.exit(0);
//        System.out.println("remove num edges: " + clusterer.getNumEdgesRemoved() + " Number of Clusters produced: " + numClustersWanted + " " + clusterSet.size());
            }
        }
//        Iterator s = ((Vertex)(clusterSet.getCluster(0).toArray()[0])).getUserDatumKeyIterator();
        //s.next(); //s.next();
//        System.out.println(s.next());
//        List edges = clusterer.getEdgesRemoved();

        recolor(layout, colors, groupClusters);
//        List edges = new ArrayList();
//
//        int i = 0;
//        //Set the colors of each node so that each cluster's vertices have the same color
//        for (Iterator cIt = clusterSet.iterator(); cIt.hasNext();) {
//
//            Set vertices = (Set) cIt.next();
//            Color c = colors[i % colors.length];
//
//            colorCluster(vertices, c);
//            if (groupClusters == true) {
//                groupCluster(layout, vertices);
//            }
//            i++;
//        }
//        for (Iterator it = g.getEdges().iterator(); it.hasNext();) {
//            Edge e = (Edge) it.next();
//            if (edges.contains(e)) {
//                e.setUserDatum(DEMOKEY, Color.LIGHT_GRAY, UserData.SHARED);
//            } else {
//                e.setUserDatum(DEMOKEY, Color.BLACK, UserData.SHARED);
//            }
//        }

    }

    private void recolor(AggregateLayout<Object, Object> layout, Color[] colors, boolean groupClusters) {
//        List edges = new ArrayList();
        Graph<Object, Object> g = layout.getGraph();
        layout.removeAll();
        int i = 0;
//        clusterSet = hierCSet[hierCSet.length - 1 - currentLevel];
//        System.out.println("clusterSet: "+clusterSet);
        //Set the colors of each node so that each cluster's vertices have the same color
        for (Iterator<Set<Object>> cIt = clusterSet.iterator(); cIt.hasNext();) {

            Set<Object> vertices = (Set) cIt.next();
            Color c = colors[i % colors.length];

            colorCluster(vertices, c);
            if (groupClusters == true) {
                groupCluster(layout, vertices);
            }
            i++;
        }
        for (Object e : g.getEdges()) {
//        for (String e : g.getEdges()) {

//            if (edges.contains(e)) {
//                edgePaints.put(e, Color.lightGray);
//            } else {
            if (e instanceof String) {
                edgePaints.put(e, Color.LIGHT_GRAY);
//            }
            }
        }

    }

    private void colorCluster(Set<Object> vertices, Color c) {
        for (Object v : vertices) {
            vertexPaints.put(v, c);
        }

    }

    private void colorTopLevel(Graph graph) {
        int i = 0;
//        System.out.println("comNode: "+comNodehierSet.length);
        for (Set set : comNodehierSet[comNodehierSet.length - 2]) {
            Color c = similarColors[i % similarColors.length];

            vertexPaints.put(findVertexInClusteredGraph(graph, set), c);
            i++;
        }
    }

    private void groupCluster(AggregateLayout<Object, Object> layout, Set<Object> vertices) {

        if (vertices.size() < layout.getGraph().getVertexCount()) {
            Point2D center = layout.transform(vertices.iterator().next());
            Graph<Object, Object> subGraph = SparseMultigraph.<Object, Object>getFactory().create();
            for (Object v : vertices) {
                subGraph.addVertex(v);
            }
            Layout<Object, Object> subLayout =
                    new CircleLayout<Object, Object>(subGraph);
            subLayout.setInitializer(vv.getGraphLayout());
            subLayout.setSize(new Dimension(40, 40));

            layout.put(subLayout, center);
            vv.repaint();
        }
    }

    Graph preCollapse(Graph inGraph, ArrayList toCollapse) {
        ArrayList listComNodeInGraph = new ArrayList();
        for (Object v : toCollapse) {
//            System.out.println("V: "+ v);
            Object comNodeInGraph = findVertexInClusteredGraph(inGraph, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
            listComNodeInGraph.add(comNodeInGraph);
        }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
        Set toCollapseNode = new HashSet();
        toCollapseNode.addAll(listComNodeInGraph);
//        System.out.println("toCollapseNode: "+toCollapseNode);
        return collapseNodeSet(inGraph, toCollapseNode);
    }

    private Graph collapseNodeSet(Graph inGraph, Set toBeColl) {
//        Graph inGraph = layout.getGraph();
        Graph clusterGraph = collapser.getClusterGraph(inGraph, toBeColl);

//        System.out.println(clusterGraph);
        return collapser.collapse(inGraph, clusterGraph);
//        System.out.println("Vertices:--- " + g.getVertices());
//        System.out.println("Edges:--- " + g.getEdges());
//        double sumx = 0;
//        double sumy = 0;
//        for (Object v : toBeColl) {
//            Point2D p = (Point2D) layout.transform(v);
//            sumx += p.getX();
//            sumy += p.getY();
//        }
//        Point2D cp = new Point2D.Double(sumx / toBeColl.size(), sumy / toBeColl.size());
//        layout.setGraph(g);

//        layout.setLocation(clusterGraph, cp);
//        vertexPaints.put(clusterGraph, similarColors[0]);
//        vv.repaint();
    }
    /**
     * Search in the inGraph which (meta)vertex corresponds to the vertex
     * @param inGraph
     * @param vertex
     * @return real vertex in the JUNG Graph corresponding to the vertex
     */
    Object findVertexInClusteredGraph(Graph inGraph, Object vertex) {

        while (vertex instanceof Collection) {
//            System.out.println("Vertex: "+vertex);
            Collection c = (Collection) vertex;
            vertex = c.iterator().next();
        }
//        System.out.println("Final Vertex: "+vertex);
        return findVertex(inGraph, vertex);
    }
    /**
     * find vertex in the given inGraph recursively
     *  
     * @param inGraph
     * @param vertex
     * @return v which contains the vertex
     */
    Object findVertex(Graph inGraph, Object vertex) {
        Collection vertices = inGraph.getVertices();
        if (vertices.contains(vertex)) {
            return vertex;
        }
        for (Object v : vertices) {
            if (v instanceof Graph) {
                Graph g = (Graph) v;
                if (contains(g, vertex)) {
                    return v;
                }
            }
        }
        return null;
    }

    private boolean contains(Graph inGraph, Object vertex) {
        boolean contained = false;
        if (inGraph.getVertices().contains(vertex)) {
            return true;
        }
        for (Object v : inGraph.getVertices()) {
            if (v instanceof Graph) {
                contained |= contains((Graph) v, vertex);
            }
        }
        return contained;
    }
    int currentLevel = 0;

    private Set<Set<Object>> processClusterSet(Graph g, int[][] hierarchyComNode) throws IOException {
        ArrayList<Integer> labelList = new ArrayList();
        ArrayList<ArrayList<Object>> csList = new ArrayList();
        ArrayList<ArrayList<Object>> newCsList = new ArrayList();
        ArrayList<ArrayList<Object>> arrComNode = new ArrayList();
//        Set<Set<Number>> cSet = new VertexClusterSet(g);
        Set<Set<Object>> cSet = new HashSet<Set<Object>>();
        Set<Set<Object>> comNodeCSet = new HashSet<Set<Object>>();
        hierCSet = new HashSet[hierarchyComNode.length];
        comNodehierSet = new HashSet[hierarchyComNode.length];
//        int i = 0;

//        if (hierarchyComNode.length < 2)
//        {
//            
//        }

        System.out.println("Start process cluster set!");
        // hierarchyComNode should have length >= 2
        for (int j = 0; j < hierarchyComNode[1].length; j++) {
            csList.add(new ArrayList<Object>());
            arrComNode.add(new ArrayList());
        }
        for (int j = 0; j < hierarchyComNode[0].length; j++) {
            if (!labelList.contains(hierarchyComNode[0][j])) {
                labelList.add(hierarchyComNode[0][j]);
            }
//                StringLabeller sl = StringLabeller.getLabeller(g, "node name");
            int index = labelList.indexOf(hierarchyComNode[0][j]);
//            ArrayList<Object> cluster = csList.get(labelList.indexOf(hierarchyComNode[0][j]));
            ArrayList<Object> cluster = csList.get(index);
            ArrayList clusterOfComNode = arrComNode.get(index);
//            cluster.add(j);
//            clusterOfComNode.add(j);
            cluster.add(nodeMap.get(j));
            clusterOfComNode.add(nodeMap.get(j));
//                System.out.println(i);

//                cluster.add(sl.getVertex(Integer.toString(j)));

        }
//        System.out.println("Vertices: " + g.getVertices());
//        System.out.println("Edges: " + g.getEdges());
//        Set<Object> tToCSet = new HashSet<Object>();
        comNodeCSet = new HashSet<Set<Object>>();
//            System.out.println("arrcomnode: "+arrComNode);
        for (int l = 0; l < csList.size(); l++) {
//        for (ArrayList<Object> cluster : csList) {
            ArrayList<Object> cluster = csList.get(l);
            ArrayList clusterOfComNode = arrComNode.get(l);
            Set<Object> toCSet = new HashSet();
            Set toComNodeCSet = new HashSet();
            toCSet.addAll(cluster);
//            toComNodeCSet.addAll(clusterOfComNode);
            toComNodeCSet.addAll(cluster);
            cSet.add(toCSet);
            comNodeCSet.add(toComNodeCSet);
//            System.out.println("\nCSet: " + toCSet);
//            tToCSet = toCSet;
//            dynamicGraph = collapseNodeSet(dynamicGraph, toCSet);

//            cSet.addCluster(toCSet);
//            System.out.println(cluster);
        }
//        System.out.println("Dynamic Graph Vertices: "+dynamicGraph.getVertices());
//        hierCSet[0] = new VertexClusterSet(g);
//        System.out.println(tToCSet);
//        System.out.println("Graph ver: "+layout.getGraph().getVertices());
//        System.out.println(layout.getGraph().getVertices());
//        Graph vx = null;
//        for (Object v: layout.getGraph().getVertices()){
//            System.out.println(v);
//            vx = (Graph) v;
////            System.out.println(((Graph)v). == collapser.getClusterGraph(realGraph, tToCSet));
//        }
//        System.out.println(collapser.getClusterGraph(realGraph, tToCSet));
//        System.out.println(layout.getGraph().containsVertex(collapser.getClusterGraph(realGraph, tToCSet)));
//        System.out.println(layout.getGraph().containsVertex(vx));

        hierCSet[0] = cSet;
        comNodehierSet[0] = comNodeCSet;
//        System.out.println("\ncomNodehierSet "+0+": "+comNodehierSet[0]+"\n");
//        comNodehierSet[0].addAll(cSet);
//        Set toBeCollpased = new HashSet();

        for (int i = 1; i < hierarchyComNode.length - 1; i++) {
            labelList.clear();
            newCsList.clear();
            arrComNode.clear();
//            System.out.println("size "+(i)+" "+hierarchyComNode[i].length);
//            System.out.println("size "+(i+1)+" "+hierarchyComNode[i+1].length);
            for (int j = 0; j < hierarchyComNode[i + 1].length; j++) {
                newCsList.add(new ArrayList<Object>());
                arrComNode.add(new ArrayList());
            }
//            System.out.println("size csList "+csList.size());
//            System.out.println("size new csList "+newCsList.size());
            for (int j = 0; j < hierarchyComNode[i].length; j++) {
                if (!labelList.contains(hierarchyComNode[i][j])) {
                    labelList.add(hierarchyComNode[i][j]);
                }

//                StringLabeller sl = StringLabeller.getLabeller(g,"node name");
                int index = labelList.indexOf(hierarchyComNode[i][j]);
                ArrayList<Object> cluster = newCsList.get(index);
                ArrayList clusterOfComNode = arrComNode.get(index);
//                System.out.println(i);
                cluster.addAll(csList.get(j));
                clusterOfComNode.add(csList.get(j));
            }

            //clone newCsList to csList
            csList.clear();
            for (ArrayList<Object> av : newCsList) {
                ArrayList<Object> list = new ArrayList<Object>();
                csList.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }
//            csList = newCsList.clone();

//            System.out.println("");
            cSet = new HashSet<Set<Object>>();//new VertexClusterSet(g);
            comNodeCSet = new HashSet<Set<Object>>();
//            System.out.println("arrcomnode: "+arrComNode);
            for (int l = 0; l < csList.size(); l++) {
//            for (ArrayList<Object> cluster : csList) {
                ArrayList<Object> cluster = csList.get(l);
                ArrayList clusterOfComNode = arrComNode.get(l);
                Set<Object> toCSet = new HashSet();
                Set toComNodeCSet = new HashSet();
                toCSet.addAll(cluster);
                toComNodeCSet.addAll(clusterOfComNode);
                cSet.add(toCSet);
                comNodeCSet.add(toComNodeCSet);
//                System.out.println("ClusterOfComNode: "+clusterOfComNode);
//                dynamicGraph = preCollapse(dynamicGraph, clusterOfComNode);
//                collapseNodeSet(layout, toCSet);
//                cSet.addCluster(toCSet);
//                System.out.println(cluster);
            }
            hierCSet[i] = cSet;
            comNodehierSet[i] = comNodeCSet;

            System.out.println("\ncomNodehierSet " + i + ": " + comNodehierSet[i] + "\n");
        }
        

//        colorTopLevel(dynamicGraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
//        layout.setGraph(dynamicGraph);
//        System.out.println("\nDynamic Graph: ");
//        for (Object v : dynamicGraph.getVertices()) {
//            if (v instanceof Graph) {
//                System.out.println("Vertex: " + ((Graph) v).getVertices());
//            } else {
//                System.out.println("Vertex: " + v);
//            }
//        }
//        System.out.println(hierCSet[0]);
        int numSingle = 0;
        int numClustSizeMore1 = 0;
        double avgClustSize = 0;
        int biggestClustSize = -1;
        int sumClustSize = 0;

        /* calculate some stats */
//        for (int ind = 0; ind < cSet.size(); ind++){
        for (Set<Object> set : cSet) {
//            Set<Number> = cSet.
//            Set set = cSet.getCluster(ind);
            int size = set.size();
            if (size == 1) {
                numSingle++;
            } else {
                numClustSizeMore1++;
            }
            if (size > biggestClustSize) {
                biggestClustSize = size;
            }
            sumClustSize += size;
        }
        avgClustSize = (double) sumClustSize / cSet.size();
        double percSingle = (double) numSingle / g.getVertexCount();
        double percBiggest = (double) biggestClustSize / g.getVertexCount();
        System.out.println("Single node num: " + numSingle + " percent: " + percSingle);
        System.out.println("No. cluster size > 1: " + numClustSizeMore1);
        System.out.println("Avg. cluster size: " + avgClustSize);
        System.out.println("Biggest cluster size: " + biggestClustSize + " percent: " + (percBiggest * 100));
//        try {
//            obosession = GOProcessor.getSession("gene_ontology.1_2.obo");
//        } catch (OBOParseException ex) {
//            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//        }
        numOfLouvainClusters = cSet.size();

//        GOTermScoreMap = GOProcessor.populateGOTerms(cSet);
        GOProcessor gp = new GOProcessor();
        gp.populateGOTerms(cSet);
        gp.getNodesGOVectorMapBeforeCluster(cSet);
        semanticClusterList = gp.preCluster(cSet,20);
        
        
        cSet = transformDataClusterList();
        System.out.println("cSet: "+cSet.size());
        Graph newgraph = createGraphFromCSet(cSet);
//        colorTopLevel(dynamicGraph);
        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
//        layout.setGraph(dynamicGraph);
        layout.setGraph(newgraph);
        vv.repaint();
//        GOProcessor.createClusterCommonGOSet(cSet);
        return cSet;
//        return hierCSet[0];
    }
    
    public Graph createGraphFromCSet(Set<Set<Object>> cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        Map<BioObject,Set<Object>> nodeToClusterMap = new HashMap<BioObject, Set<Object>>();
        for (Set<Object> cluster : cSet){
            newgraph.addVertex(cluster);
            for (Object obj : cluster){
                nodeToClusterMap.put((BioObject) obj,cluster);
            }
        }
        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
            BioObject firstVer = (BioObject)pair.getFirst();
            BioObject secondVer = (BioObject)pair.getSecond();
            Object alreadyEdge = newgraph.findEdge(nodeToClusterMap.get(firstVer),nodeToClusterMap.get(secondVer));
            if (alreadyEdge == null){
                HashSet set = new HashSet(); set.add(edge);
                MetaEdge metaedge = new MetaEdge(nodeToClusterMap.get(firstVer)+":"+nodeToClusterMap.get(secondVer), set);
                newgraph.addEdge(metaedge, nodeToClusterMap.get(firstVer),nodeToClusterMap.get(secondVer));
            } else {
                MetaEdge metaedge = (MetaEdge) alreadyEdge;
                metaedge.addEdge(edge);
            }
        }
//        for (Set<Object> cluster : cSet){
//            for (Object obj : cluster){
//                BioObject bio = (BioObject) obj;
//                originalGraph.getNeighbors(bio);
//            }
//        }
        
        
        return newgraph;
    }
    OBOSession obosession = null;
    public int numOfLouvainClusters = 0;
    DataVector centroid = new DataVector();
    /**
     * unused now
     * @param g
     */
    public void processGOLabel(Graph g){
        
        int index = comNodehierSet.length - 1 - currentLevel - 1;
        for (Set clusterOfComNode : comNodehierSet[index]) {
////                    for (int l = 0; l < comNodehierSet[currentLevel-1].size(); l++) {

////                        System.out.println("\nClusterOfComNode: " + clusterOfComNode+"\n");
//                        ArrayList toPreCollapse = new ArrayList();
//                        toPreCollapse.addAll(clusterOfComNode);

            /* Codes below is similar to that of precollapse */
//                        dynamicGraph = LouvainClustererTest.this.preCollapse(dynamicGraph,toPreCollapse);

            ArrayList listComNodeInGraph = new ArrayList();
//                        for (Object v : toPreCollapse) {
            for (Object v : clusterOfComNode) {
//            System.out.println("V: "+ v);
//                Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
                Object comNodeInGraph = findVertexInClusteredGraph(g, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
                listComNodeInGraph.add(comNodeInGraph);
            }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
            Set toCollapseNode = new HashSet();
            toCollapseNode.addAll(listComNodeInGraph);
//        System.out.println("toCollapseNode: "+toCollapseNode);


//            Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
            Graph clusterGraph = collapser.getClusterGraph(g, toCollapseNode);
            vertexPaints.put(clusterGraph, (Color) vertexPaints.get(listComNodeInGraph.get(0)));
//        System.out.println(clusterGraph);
//            dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);
            g = collapser.collapse(g, clusterGraph);

        /* end of copied codes */

//                System.out.println(cluster);

        }
//        dynamicGraph = updateMetaEdges(dynamicGraph);
        g = updateMetaEdges(g);
        dynamicGraph = g;
    }
    
//    public void findCentroid(){
//        System.out.println("Num of Louvain Clusters: "+numOfLouvainClusters);
//        Map<String,Double> valMap = new TreeMap<String,Double>();
//        for (DataCluster dc : semanticClusterList){
//                        
//            for (DataVector member : dc.getMembers()){
////                System.out.println("member: "+member);
////                for (int j = 0; j < member.dimValueList.length; j++) {
//                for (String key : member.getValueMap().keySet()) {
////                    int index = nameArrList.indexOf(member.dimNameList[j]);
////                    int index = nameArrList.indexOf(key);
////                    if (index == -1){
//                    if (!valMap.containsKey(key)){
////                        nameArrList.add(member.dimNameList[j]);
////                        zigmaList.add((double)member.dimValueList[j]/clusterList[i].members.size());
//                        valMap.put(key, (double)member.getValueMap().get(key)/numOfLouvainClusters);
//                    } else {
//                        valMap.put(key, valMap.get(key)+(double)member.getValueMap().get(key)/numOfLouvainClusters);
////                        zigmaList.set(index,zigmaList.get(index)+(double)member.dimValueList[j]/clusterList[i].members.size());
//                    }
////                    zigmaList[j] += (double)member.dimValueList[j]/clusterList[i].members.size();
//                }
//                
//            }
//            
//        }
//        centroid = new MeanVector(valMap);
//    }
//    Set<Graph> debugSet = new HashSet<Graph>();
    public Set<Set<Object>> transformDataClusterList(){
        
//        Set<Set<Number>> cSet = new VertexClusterSet(g);
        Set<Set<Object>> cSet = new HashSet<Set<Object>>();
        Set<Set<Object>> comNodeCSet = new HashSet<Set<Object>>();
        Set<Object> cluster = new HashSet<Object>();
        Set<Object> clusterComNode = new HashSet<Object>();
//        Set<Graph> tmpSet = new HashSet<Graph>();
        centroid = DataCluster.findCentroidFromDCList(semanticClusterList,numOfLouvainClusters);
//        findCentroid();
        for (int i = 0; i < semanticClusterList.length; i++){
            DataCluster dc = semanticClusterList[i];
            if (dc.getMembers().size() == 0){
                System.out.println("Found zero member cluster!!!!!!");
                continue;
            }
            DataVector[] dvList = dc.getMembers().toArray(new DataVector[1]);
            cluster = new HashSet<Object>();
            clusterComNode = new HashSet<Object>();
            for (DataVector dv :dvList){
//                System.out.println(dv);
                //clusterRef points to a cluster (set of set) not a real metanode in the graph
                cluster.addAll((Set<Object>)dv.clusterRef);
                clusterComNode.add((Set<Object>)dv.clusterRef);
            }
            cSet.add(cluster);
            comNodeCSet.add(clusterComNode);
            ArrayList toPreCollapse = new ArrayList(clusterComNode.size());
            toPreCollapse.addAll(clusterComNode);
//            dynamicGraph = preCollapse(dynamicGraph, toPreCollapse);
//            ArrayList listComNodeInGraph = new ArrayList();
            Set toCollapseNode = new HashSet();
            for (Object v : toPreCollapse) {
//            System.out.println("V: "+ v);
                Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
//                listComNodeInGraph.add(comNodeInGraph);
                toCollapseNode.add(comNodeInGraph);
            }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
//            toCollapseNode.addAll(listComNodeInGraph);
            Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
//            tmpSet.add(clusterGraph);
            DataVector resultVector = DataVector.minusVector(dc.getRepresentative(), centroid);
            nodesGOVectorMap.put(clusterGraph, resultVector);
//            debugSet.add(clusterGraph);
//        System.out.println(clusterGraph);
            dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);
        }
        
        //extend capacity and copy the contents for cSet
        Set<Set<Object>>[] tmpHierCSet = new HashSet[hierCSet.length+1];
        for (int i = 0; i < hierCSet.length; i++){
            tmpHierCSet[i] = hierCSet[i];
        }
        tmpHierCSet[hierCSet.length-1] = cSet;
        hierCSet = tmpHierCSet;
        
        tmpHierCSet = new HashSet[comNodehierSet.length+1];
        for (int i = 0; i < comNodehierSet.length; i++){
            tmpHierCSet[i] = comNodehierSet[i];
        }
        tmpHierCSet[comNodehierSet.length-1] = comNodeCSet;
        comNodehierSet = tmpHierCSet;
        
//        System.out.println("comNodeHierSet.length-1 "+(comNodehierSet.length-1));
        for (Set<Object> set : cSet){
            System.out.println("cluster with size "+set.size());
        }
//        for (Graph set : tmpSet){
//            System.out.println("cluster with size "+set.getVertexCount());
//        }
//        processGOLabel();
        return cSet;
        
    }
    
    DataCluster[] semanticClusterList = new DataCluster[1];
    Map <Object,DataVector> nodesGOVectorMap = new HashMap<Object, DataVector>();
//    private Map<Object, Map<GOTerm, Double>> GOTermScoreMap = new HashMap<Object, Map<GOTerm, Double>>();
//    private void createClusterCommonGOSet(Set<Set<Object>> cSet){
//        System.out.println("\nCalculate GO Stat\n");
//        for(Set<Object> cluster : cSet){
//            Set commonGOId = new HashSet();
//            int i = 0;
//            String name = "";
//            for (Object node : cluster)
//            {
//                BioObject bioNode = (BioObject)node;
//                if (i == 0){
//                    commonGOId.addAll(bioNode.getGoIdList());
//                    name = bioNode.toString();
//                }
//                else
//                    commonGOId.retainAll(bioNode.getGoIdList());
//                i++;
//            }
//            System.out.println("Num Common GO Id for cluster of "+name+" with size "+cluster.size()+": "+commonGOId.size()+" List: "+commonGOId);
//        }
//    }
    private Graph updateMetaEdges(Graph graph) {
//        realGraph = graph;
        dynamicGraph = graph;
        graph = SparseMultigraph.getFactory().create();
//        for (Object v : realGraph.getVertices()) {
        for (Object v : dynamicGraph.getVertices()) {
            graph.addVertex(v);
        }
//        Collection allEdge = realGraph.getEdges();
        Collection allEdge = dynamicGraph.getEdges();
//        System.out.println("All edges: "+allEdge);
        ArrayList allEdgeList = new ArrayList(allEdge);
//        allEdgeSet.addAll(allEdge);
        while (allEdgeList.size() > 0) {
            Object e = allEdgeList.get(0);
//            Pair p = realGraph.getEndpoints(e);
            Pair p = dynamicGraph.getEndpoints(e);
            Object first = p.getFirst(), second = p.getSecond();
//            Collection edgeSet = realGraph.findEdgeSet(first, second);
            Collection edgeSet = dynamicGraph.findEdgeSet(first, second);
//            System.out.println("Edge set: "+edgeSet);
            Set set = new HashSet();
            set.addAll(edgeSet);
            MetaEdge me = new MetaEdge(edgeSet.toString(), set);
            graph.addEdge(me, p);
//            System.out.println("Pair: "+p);
//            System.out.println("First: "+first);
//            System.out.println("Second: "+second);
//            System.out.println("Meta edges: "+me);
            allEdgeList.removeAll(edgeSet);
//            System.out.println("me first"+realGraph.getEndpoints(me).getFirst());
        }
        return graph;
//        System.out.println("All edges: "+allEdge);

    }

    private int findNoMemInHier(Object v) {
        //assume that v is instance of Graph
//        int num = 0;
        
        int num = hierCSet.length-1-currentLevel;
//        System.out.println("num "+num);
        while (v instanceof Graph) {
            Graph g = (Graph) v;
            v = (Object) g.getVertices().iterator().next();
//            num++;
        }
        // v becomes a vertex 
//        int index = hierCSet.length - 1 - num;
//        System.out.println("\nhierCSet "+ hierCSet[0]);
        int index = num - 1;
        if (index < 0)
            return 0;
//        System.out.println("\nhierCSet "+ hierCSet[index]);
        for (Set verSet : hierCSet[index]) {
            if (verSet.contains( v)) {
//                System.out.println("Ver set: "+verSet);
                return verSet.size();
            }
        }
        return 0;
    }
    public class NumMemberGOTips<V,E>
    	implements Transformer<V,String> {
        
        public String transform(V vertex) {
            String res = "";
            res += "<html>Num Nodes Inside: "+findNoMemInHier(vertex);
            if (vertex instanceof Graph){
                DataVector vec = nodesGOVectorMap.get(vertex);
                if (vec == null) {
                    Graph vert = (Graph) vertex;
                    for (Object ver : nodesGOVectorMap.keySet()) {
                        if (ver instanceof Graph) {
                            Graph vv = (Graph) ver;
//                            Set verSet = new HashSet(vv.getVertices());
                            Object rest = findVertex(vv, vert);
                            if (rest != null) {
//                                System.out.println("rest : " + vv);
                                vec = nodesGOVectorMap.get(ver);
                                break;
                            }
                        }
                    }
                }
                if (vec != null){
                
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
                        res += "<p>" + entry.getKey() + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            }
            res += "</html>";
            return res;
        }
    }
    private class TextFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("txt")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Just text file";
        }
    }

//    private static int numMemberInClusteredGraph(Object v){
//        int numMember = 0;
//        Graph g = (Graph) v;
//        for (Object ver : g.getVertices()){
//           if (ver instanceof Graph) 
//               numMember += numMemberInClusteredGraph(ver);
//           else
//               numMember += 1;
//        }
//        
//        return numMember;
//    }
    private final class MetaEdgeDisplayPredicate<V, E>
            implements Predicate<Context<Graph<V, E>, E>> //extends AbstractGraphPredicate<V,E>
    {

        private boolean isLowestLevel = false;

        public void setLowestLevel(boolean value) {
            isLowestLevel = value;
        }

        public boolean evaluate(Context<Graph<V, E>, E> context) {
            Graph<V, E> graph = context.graph;
            E e = context.element;
            if ((e instanceof MetaEdge) || (isLowestLevel)) {
                return true;
            }
            return false;
//            if (realGraph.getEdgeType(e) == EdgeType.DIRECTED && show_d) {
//                return true;
//            }
//            if (realGraph.getEdgeType(e) == EdgeType.UNDIRECTED && show_u) {
//                return true;
//            }
//            return false;
        }
    }

    private final class EdgeLabeller<E> implements Transformer<E, String> {

        protected EdgeWeightLabeller edge_weight;

        public EdgeLabeller(EdgeWeightLabeller edgeWeight) {
            this.edge_weight = edgeWeight;
        }

        public String transform(E e) {
            int value = 1;
            if (e instanceof MetaEdge) //                return (((MetaEdge)e).edgeSetBundled).toString();
            {
                value = ((MetaEdge) e).numEdgeSetBundled;
            } else {
                value = edge_weight.getWeight(e);
//                return Integer.toString(edge_weight.getWeight(e));
            }
            if (value > 1) {
                return "" + value;
            } else {
                return "";
            }
        }
    }

    private final class EdgeWeightStrokeFunction<E>
            implements Transformer<E, Stroke> {

        protected final Stroke basic = new BasicStroke(1);
        protected final Stroke heavy = new BasicStroke(5);
        protected final Stroke heavy2 = new BasicStroke(8);
//        protected static final Stroke heavy = new BasicStroke();
        protected final Stroke dotted = RenderContext.DOTTED;//        protected boolean weighted = false;
//        protected Map<E,Number> edge_weight;
        protected EdgeWeightLabeller edge_weight;
        protected Graph graph;

//        public EdgeWeightStrokeFunction(Map<E,Number> edge_weight)
        public EdgeWeightStrokeFunction(EdgeWeightLabeller edge_weight) {
            this.edge_weight = edge_weight;
//            this.graph = graph;
        }

//        public void setWeighted(boolean weighted)
//        {
//            this.weighted = weighted;
//        }
        public Stroke transform(E e) {
//            if (weighted)
//            {
//             double value = edge_weight.get(e).doubleValue();
            double value;
            if (e instanceof MetaEdge) {
                value = ((MetaEdge) e).getNumEdgeSetBundled();
            } else {
                value = edge_weight.getWeight(e);
            }
            if (value > 7) {
                return heavy2;
            } else if (value > 3) {
                return heavy;
            } else {
                return basic;
//            }
//            else
//                return basic;
            }
        }//        protected boolean drawHeavy(E e)
//        {
//            double value = edge_weight.get(e).doubleValue();
//            if (value > 0.7)
//                return true;
//            else if (value > 5)
//
//                return false;
//        }
    }
    public class DoubleClickZoomInPlugin<V,E> extends AbstractGraphMousePlugin
        implements MouseListener{
        public DoubleClickZoomInPlugin(){
            this(MouseEvent.BUTTON1_DOWN_MASK);
        }
        public DoubleClickZoomInPlugin(int modifier){
            super(modifier);
        }
        
        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2 && !e.isConsumed()) {
                e.consume();
                final VisualizationViewer<V,E> vv =
                        (VisualizationViewer<V, E>) e.getSource();
                final Point2D p = e.getPoint();
                GraphElementAccessor<V, E> pickSupport = vv.getPickSupport();
                if (pickSupport != null) {
//                    Graph<V, E> graph = vv.getModel().getGraphLayout().getGraph();

                    final V vertex = pickSupport.getVertex(vv.getModel().getGraphLayout(), p.getX(), p.getY());
                    if (vertex != null)
                        System.out.println("Vertex: "+vertex);
                }
//                System.out.println(e.getSource());
            }
        }
       
        public void mouseEntered(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(cursor);
        }

        public void mouseExited(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }

        public void mouseMoved(MouseEvent e) {
        }

        public void mousePressed(MouseEvent e) {
            
        }

        public void mouseReleased(MouseEvent e) {
           
        }
    }
    private final class VertexShapeSizeAspect<V, E>
            extends AbstractVertexShapeTransformer<V>
            implements Transformer<V, Shape> {

//        protected boolean stretch = false;
//        protected boolean scale = false;
//        protected boolean funny_shapes = false;
//        protected Map<V, Number> voltages;
        protected Graph<V, E> graph;
//        protected AffineTransform scaleTransform = new AffineTransform();
        public VertexShapeSizeAspect(Graph<V, E> graphIn) {//, Map<V, Number> voltagesIn) {
            this.graph = graphIn;
//            this.voltages = voltagesIn;
            setSizeTransformer(new Transformer<V, Integer>() {

                public Integer transform(V v) {
//                    if (scale) {
                    int numMember = 0;

                    if (!(v instanceof Graph)) {
                        return 20;
                    } else {
//                        numMember = numMemberInClusteredGraph(v);
                        numMember = findNoMemInHier(v);
                        if (numMember == 0)
                            return 20;
//                        System.out.println("");
//                        System.out.println("Ver: "+v+" Num member: "+numMember);
//                        System.out.println("");
//                        return (int) ((Graph) v).getVertexCount() * 15;
//                       System.out.println("num mem: "+numMember+" size: "+(Math.log10(numMember)/Math.log10(2)*20));
                        return (int) (Math.log10(numMember) / Math.log10(2) * 20);


                    }
                }
            });
//            setAspectRatioTransformer(new Transformer<V, Float>() {
//
//                public Float transform(V v) {
//                    if (stretch) {
//                        return (float) (realGraph.inDegree(v) + 1) /
//                                (realGraph.outDegree(v) + 1);
//                    } else {
//                        return 1.0f;
//                    }
//                }
//            });
        }

//        public void setStretching(boolean stretch) {
//            this.stretch = stretch;
//        }

//        public void setScaling(boolean scale) {
//            this.scale = scale;
//        }

//        public void useFunnyShapes(boolean use) {
//            this.funny_shapes = use;
//        }
        public Shape transform(V v) {
//            if (funny_shapes) {
//                if (realGraph.degree(v) < 5) {
//                    int sides = Math.max(realGraph.degree(v), 3);
//                    return factory.getRegularPolygon(v, sides);
//                } else {
//                    return factory.getRegularStar(v, realGraph.degree(v));
//                }
//            } else {
            return factory.getEllipse(v);
//            }
        }
    }
    private final class LayoutChooser implements ActionListener
    {
        private final JComboBox jcb;
        private final VisualizationViewer<Object,Object> vv;

        private LayoutChooser(JComboBox jcb, VisualizationViewer<Object,Object> vv)
        {
            super();
            this.jcb = jcb;
            this.vv = vv;
        }

        public void actionPerformed(ActionEvent arg0)
        {
            Object[] constructorArgs = {dynamicGraph};

            Class<? extends Layout<Integer,Number>> layoutC = 
                (Class<? extends Layout<Integer,Number>>) jcb.getSelectedItem();
//            Class lay = layoutC;
            try
            {
                Constructor<? extends Layout<Integer, Number>> constructor = layoutC
                        .getConstructor(new Class[] {Graph.class});
                Object o = constructor.newInstance(constructorArgs);
                Layout<Object,Object> l = (Layout<Object,Object>) o;
                l.setInitializer(vv.getGraphLayout());
                l.setSize(vv.getSize());
                
                LayoutTransition<Object, Object> lt =
                        new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), l);
                Animator animator = new Animator(lt);
                animator.start();
                vv.getRenderContext().getMultiLayerTransformer().setToIdentity();
                vv.repaint();
                
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}
class MetaEdge<E> extends Object {

    String name = "";
    Set<E> edgeSetBundled = new HashSet<E>();
    int numEdgeSetBundled = 0;
    //Intentionally not clone or copy. Just refer to the edgeSet
    public MetaEdge(String s, Set<E> edgeSet) {
        name = s;
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }

    public void setName(String s) {
        name = s;
    }

    public void setEdgeSetBundled(Set<E> edgeSet) {
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }

    public void addEdge(E edge){
        edgeSetBundled.add(edge);
        numEdgeSetBundled += 1;
    }
    public String getName() {
        return name;
    }

    public Set<E> getEdgeSetBundled() {
        return edgeSetBundled;
    }

    public int getNumEdgeSetBundled() {
        return numEdgeSetBundled;
    }

    @Override
    public String toString() {
        return "Num edge: " + numEdgeSetBundled + " " + edgeSetBundled;
    }
}

