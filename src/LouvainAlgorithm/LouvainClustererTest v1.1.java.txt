/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package main;

/**
 *
 * @author Knacky
 */
import edu.uci.ics.jung.algorithms.layout.AggregateLayout;
import edu.uci.ics.jung.algorithms.layout.CircleLayout;
import edu.uci.ics.jung.algorithms.layout.FRLayout;
import edu.uci.ics.jung.algorithms.layout.GraphElementAccessor;
import edu.uci.ics.jung.algorithms.layout.ISOMLayout;
import edu.uci.ics.jung.algorithms.layout.KKLayout;
import edu.uci.ics.jung.algorithms.layout.Layout;

import edu.uci.ics.jung.algorithms.layout.SpringLayout;
import edu.uci.ics.jung.algorithms.layout.SpringLayout2;
import edu.uci.ics.jung.algorithms.layout.StaticLayout;
import edu.uci.ics.jung.algorithms.layout.util.Relaxer;
import edu.uci.ics.jung.algorithms.layout.util.VisRunner;


import edu.uci.ics.jung.algorithms.util.IterativeContext;
import edu.uci.ics.jung.graph.Graph;


import edu.uci.ics.jung.graph.SparseGraph;
import edu.uci.ics.jung.graph.SparseMultigraph;

import edu.uci.ics.jung.graph.util.Context;
import edu.uci.ics.jung.graph.util.DefaultParallelEdgeIndexFunction;
import edu.uci.ics.jung.graph.util.Pair;
import edu.uci.ics.jung.io.PajekNetReader;

import edu.uci.ics.jung.visualization.GraphZoomScrollPane;

import edu.uci.ics.jung.visualization.RenderContext;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.AbstractGraphMousePlugin;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;

import edu.uci.ics.jung.visualization.decorators.AbstractVertexShapeTransformer;
import edu.uci.ics.jung.visualization.decorators.EdgeWeightLabeller;
import edu.uci.ics.jung.visualization.decorators.PickableEdgePaintTransformer;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.layout.LayoutTransition;
import edu.uci.ics.jung.visualization.renderers.Renderer;
import edu.uci.ics.jung.visualization.subLayout.GraphCollapser;
import edu.uci.ics.jung.visualization.util.Animator;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileFilter;
import kmean.DataCluster;
import kmean.DataVector;
import kmean.KMeanClusterer;
import org.apache.commons.collections15.Factory;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.collections15.Transformer;
import org.apache.commons.collections15.functors.ConstantTransformer;
import org.apache.commons.collections15.functors.MapTransformer;
import org.apache.commons.collections15.map.LazyMap;
import util.StopWatch;
import main.GOProcessor;
import org.geneontology.oboedit.dataadapter.OBOParseEngine.SOPair;
import org.geneontology.oboedit.datamodel.OBOSession;

/**
 *
 * @author Knacky
 */
public class LouvainClustererTest extends JFrame {

    private boolean UIWanted;
    private String stringStream = "";
    private boolean isWeightGraph = false;
    private int[] sArr = null;
    private int[] dArr = null;
    private double[] wArr = null;
//    private static final Object DEMOKEY = "DEMOKEY";
    VisualizationViewer<Object, Object> vv;//	Factory<Graph<Number,Number>> graphFactory;
    Map<Object, Paint> vertexPaints =
            LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.white));
    Map<Object, Paint> edgePaints =
            LazyMap.<Object, Paint>decorate(new HashMap<Object, Paint>(),
            new ConstantTransformer(Color.BLACK));
    Map<Integer, BioObject> nodeMap = new HashMap<Integer, BioObject>();
    public final Color[] similarColors = {
        new Color(216, 134, 134),
        new Color(135, 137, 211),
        new Color(134, 206, 189),
        new Color(206, 176, 134),
        new Color(194, 204, 134),
        new Color(145, 214, 134),
        new Color(133, 178, 209),
        new Color(103, 148, 255),
        new Color(60, 220, 220),
        new Color(30, 250, 100)
    };
    public Color mainColor = new Color(255,204,22);
    public Color peripheralColor = new Color(0xF6FEAC);
//    public Color mainColor = new Color(138,240,87);
//    public Color mainColor = new Color(153,255,102);

    private static Class<? extends Layout>[] getLayoutCombos()
    {
        List<Class<? extends Layout>> layouts = new ArrayList<Class<? extends Layout>>();
        layouts.add(KKLayout.class);
        layouts.add(FRLayout.class);
        layouts.add(CircleLayout.class);
        layouts.add(SpringLayout.class);
        layouts.add(SpringLayout2.class);
        layouts.add(ISOMLayout.class);
        return layouts.toArray(new Class[0]);
    }
    
    public static void main(String[] args) {
//        KleinbergSmallWorldGenerator kg = new KleinbergSmallWorldGenerator(6, 2.5);
//        Graph realGraph;
//        realGraph = (Graph) kg.generateGraph();
//        System.out.println("num node: " + realGraph.numVertices() + " num edge: " + realGraph.numEdges());

//        // Add a restart button so the realGraph can be redrawn to fit the size of the frame
        LouvainClustererTest test = new LouvainClustererTest();
//        test.setName("Interactive Bio Graph Explorer");
        test.setTitle("Interactive Bio Graph Explorer");

//        JFrame jf = new JFrame();
//        
//        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//        test.setPreferredSize(new Dimension(500, 500));
//        JFrame.setDefaultLookAndFeelDecorated(true);

//        jf.getContentPane().add(test);
        test.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        test.start();

        test.pack();
//        test.setLocationByPlatform(true);
        test.setVisible(true);
        
//        test.validate();
//        jf.pack();
//        jf.setVisible(true);
//        jf.validate();

    }
    private double threshold;
    private EdgeDisplayPredicate medp;
    private EdgeWeightLabeller ew;
//    /** Initializes the applet NewJApplet */
//    public void init() {
//        try {
//            java.awt.EventQueue.invokeAndWait(new Runnable() {
//                public void run() {
//                    start();
//                }
//            });
//        } catch (Exception ex) {
//            ex.printStackTrace();
//        }
//    }
    public Graph<Object, Object> loadModNet(BufferedReader br) throws IOException {

//        int tNumLinks = 0;
        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1, numNode = -1;


        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        BioObject bioObj = null;
//        if (UIWanted){
//            StringLabeller sl = StringLabeller.getLabeller(newgraph,"node name");
//        EdgeWeightLabeller ew = EdgeWeightLabeller.getLabeller(newgraph,"weight");
        //check header
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Vertices")) {
                    numNode = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        int id = -1;
        String stdName = "", name = "", sgdid = "", type = "";
        String goId = "", ref = "", aspect = "";
        StopWatch sw = new StopWatch();
        sw.start();
        for (int i = 0; i < numNode; i++) {
//        while ((st = br.readLine()) != null){
            st = br.readLine();
//            System.out.println(st);
            stn = new StringTokenizer(st, "\t", true);
            assert (stn.hasMoreTokens());
            id = Integer.parseInt(stn.nextToken());
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            stdName = stn.nextToken();
            if (stdName.equals("\t")) {
                stdName = "";
            } else {
                stn.nextToken();
            }

            assert (stn.hasMoreTokens());
            name = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            assert (stn.hasMoreTokens());
            sgdid = stn.nextToken();
            if (stn.nextToken().equals("\t"));

            if (sgdid.equals("\t")) {
                bioObj = new BioObject(id, name);
                bioObj.setStandardName(stdName);
            } else {
//                assert (stn.hasMoreTokens());
//                sgdid = stn.nextToken();
//                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                type = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                goId = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                ref = stn.nextToken();
                if (stn.nextToken().equals("\t"));

                assert (stn.hasMoreTokens());
                aspect = stn.nextToken();
//            if (stn.nextToken().equals("\t"));


                bioObj = new BioObject(id, sgdid, name);
                bioObj.setStandardName(stdName);
                bioObj.setType(type);

                StringTokenizer stz = new StringTokenizer(goId, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getGoIdList().add(stz.nextToken());
                }


//                System.out.println(ref);
                stz = new StringTokenizer(ref, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getRefList().add(stz.nextToken());
                }

                stz = new StringTokenizer(aspect, "|");
                while (stz.hasMoreTokens()) {
                    bioObj.getAspectList().add(stz.nextToken());
                }
            }
            newgraph.addVertex(bioObj);
            nodeMap.put(id, bioObj);
        }
        sw.stop();
        System.out.println("load vertices time: "+sw);
        sw.start();
        int numEdge = -1;
        //check header
        while ((st = br.readLine()) != null) {
            stn = new StringTokenizer(st);
            if (stn.hasMoreTokens()) {
                String temp = stn.nextToken();
                if (temp.equalsIgnoreCase("*Edges")) {
                    numEdge = Integer.parseInt(stn.nextToken());
                    break;
                } else {
                    System.err.println("Error Loading Graph");
                    System.exit(1);
                }

            } else {
                continue;
            }
        }
        
//        StringBuilder stb = new StringBuilder(10000);
        
        sArr = new int[numEdge];
        dArr = new int[numEdge];
        wArr = new double[numEdge];
        boolean isWeight = false;
        
        ew = new EdgeWeightLabeller<Number>();
        for (int i = 0; i < numEdge; i++) {
//        while ((st = br.readLine()) != null) {
            st = br.readLine();
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
//            stringStream += src + "\t" + dest + "\t";
//            stb.append(src).append("\t").append(dest).append("\t");
            sArr[i] = src; dArr[i] = dest;
//            Number vSrc = null,vDest = null;
//            newgraph.addVertex(src);
//            newgraph.addVertex(dest);

//            System.out.println("src: "+src+" dest: "+dest);
            String e1 = src + ":" + dest;
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
//                stringStream += weight;
//                stb.append(weight);
                wArr[i] = weight;
                ew.setWeight(e1, weight);
                isWeight = true;
            }
//            stringStream += "\n";
//            stb.append("\n");

            newgraph.addEdge(e1, nodeMap.get(src), nodeMap.get(dest));
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));




//            if (!newVertexSet.get(indStart).isNeighborOf(new/VertexSet.get(indEnd)))
////            if (edgeToDraw.getEqualEdge(g) == null)
////            if (!newgraph.getEdges().contains(edgeToDraw))
//            {
//                newgraph.addEdge(edgeToDraw);
//                edgeToDraw.addUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight , UserData.SHARED);
//            }
//            else
//            {
////                edgeToDraw = (Edge) edgeToDraw.getEqualEdge(newgraph);
//                edgeToDraw = (Edge) newVertexSet.get(indStart).findEdge(newVertexSet.get(indEnd));
////                System.out.println(edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight"));
//                Float oldWeight = (unweighted)? new Float(1):(Float) edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
////                oldWeight = (Float)edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
//                edgeToDraw.setUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight+oldWeight , UserData.SHARED);
//            }

        }
        sw.stop();
//        stringStream = stb.toString();
        if (!isWeight){
            wArr = null;
        }
        isWeightGraph = isWeight;
        System.out.println("Load edges time: "+sw);
        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
        System.out.println("Num nodes double checked: " + numNode + " Num edges double checked: " + numEdge);
//        }


//        System.out.println(newgraph.getEdges());
        return newgraph;
//        return null;
    }

    public Graph<Object, Object> load(BufferedReader br) throws IOException {

//        int tNumLinks = 0;
        String st;
        StringTokenizer stn;
        int src, dest;
        int weight = 1;


        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();

//        if (UIWanted){
//            StringLabeller sl = StringLabeller.getLabeller(newgraph,"node name");
//        EdgeWeightLabeller ew = EdgeWeightLabeller.getLabeller(newgraph,"weight");
        ew = new EdgeWeightLabeller<Number>();

        while ((st = br.readLine()) != null) {
//            if (tNumLinks%10000==0)
//               System.out.print(".");
            stn = new StringTokenizer(st);

            src = Integer.parseInt(stn.nextToken());
            dest = Integer.parseInt(stn.nextToken());
//            Number vSrc = null,vDest = null;
            newgraph.addVertex(src);
            newgraph.addVertex(dest);
//            if (!newgraph.getVertices().contains(src)){
//                newgraph.addVertex(src);
//                
//            } else {
//                
//            }
//            if (sl.getVertex(Integer.toString(src)) == null){
//                try {
//                    vSrc = newgraph.addVertex(new UndirectedSparseVertex());
//                    sl.setLabel(vSrc, Integer.toString(src));
//                } catch (UniqueLabelException ex) {
//                    Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//                }
//            }
//            else {
//                vSrc = sl.getVertex(Integer.toString(src));
//            }

//            if (sl.getVertex(Integer.toString(dest)) == null){
//                try {
//                    vDest = newgraph.addVertex(new UndirectedSparseVertex());
//                    sl.setLabel(vDest, Integer.toString(dest));
//                } catch (UniqueLabelException ex) {
//                    Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//                }
//            } else {
//                vDest = sl.getVertex(Integer.toString(dest));
//            }
//            System.out.println("src: "+src+" dest: "+dest);
            if (stn.hasMoreTokens()) {
                weight = Integer.parseInt(stn.nextToken());
            }
            String e1 = src + ":" + dest;
            newgraph.addEdge(e1, src, dest);
//            if (!newgraph.getEdges().contains(new UndirectedSparseEdge(vSrc, vDest)))
//                e1 = (Edge) newgraph.addEdge(new UndirectedSparseEdge(vSrc, vDest));

            ew.setWeight(e1, weight);


//            if (!newVertexSet.get(indStart).isNeighborOf(new/VertexSet.get(indEnd)))
////            if (edgeToDraw.getEqualEdge(g) == null)
////            if (!newgraph.getEdges().contains(edgeToDraw))
//            {   
//                newgraph.addEdge(edgeToDraw);
//                edgeToDraw.addUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight , UserData.SHARED);
//            }
//            else
//            {
////                edgeToDraw = (Edge) edgeToDraw.getEqualEdge(newgraph);
//                edgeToDraw = (Edge) newVertexSet.get(indStart).findEdge(newVertexSet.get(indEnd));
////                System.out.println(edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight"));
//                Float oldWeight = (unweighted)? new Float(1):(Float) edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
////                oldWeight = (Float)edgeToDraw.getUserDatum("jung.io.PajekNetFile.EdgeWeight");
//                edgeToDraw.setUserDatum("jung.io.PajekNetFile.EdgeWeight", newWeight+oldWeight , UserData.SHARED);
//            }   

        }

        System.out.println("num nodes: " + newgraph.getVertexCount() + " num edges: " + newgraph.getEdgeCount());
//        }


//        System.out.println(newgraph.getEdges());
        return newgraph;
//        return null;
    }
//    String filename = "src/karate";
//    String filename = "/Users/Knacky/NetBeansProjects/BlondelAlgorithm/src/input";
//    String filename = "expmore3.mnet";
//    String filename = "refmore3.mnet";
    String filename = "curmore2.mnet";
//    String filename = "..\\BlondelAlgorithm\\src\\input";
//        String filename = "src/arxiv";
//        String filename = "src/kl265";s
//        String filename = "src/example";       
//        String filename = "src/temp2";
    /*Yeast SGD Data Set*/
//        String filename = "src/all_yeast_intdata.txt";
//          String filename = "src/all_yeast_intdata_noself";
//        String filename = "src/RefMore3intdata";
//        String filename = "src/ExpMore3intdata";
//          String filename = "src/IntMore1intdata";
//          String filename = "src/CurMore1intdata";
//          String filename = "src/CurHighintdata";
//          String filename = "src/CurManintdata";
//        String filename = "src/ItoT_intdata";
    File fileToOpen = null;
    Graph<Object, Object> realGraph, originalGraph;
    Graph dynamicGraph,currentLevelGraph;
    AggregateLayout<Object, Object> layout;
    GraphCollapser collapser;
    JButton collapseButton;
    JButton expandButton;
    JButton zoomInButton;
    JButton zoomOutButton;
//    @Override
    public void start() {
        threshold = 0.000001;

//        UIWanted = false;
        UIWanted = true;
//        File f = new File("src/input.txt");
//        File f = new File("src/ItoT_intdata.net");
//        File f = new File(filename+".net");
//        File f = new File("src/example.net");
//        System.out.println(f.getAbsolutePath());

//        System.out.println(f.getAbsolutePath());

        Factory<Object> vertexFactory = new Factory<Object>() {

            int n = 0;

            public Number create() {
                return n++;
            }
        };
        Factory<Object> edgeFactory = new Factory<Object>() {

            int n = 0;

            public String create() {
                return "" + (n++);
            }
        };


        try {
//            JFileChooser fileChooser = new JFileChooser(new File(filename + ".txt"));
//            fileChooser.setAcceptAllFileFilterUsed(false);
//            fileChooser.addChoosableFileFilter(new TextFileFilter());

//            System.out.println(new File(filename+".txt").getPath());
//            fileChooser.showOpenDialog(LouvainClustererTest.this);
//            fileToOpen = fileChooser.getSelectedFile();
            fileToOpen = new File(filename);
            if (fileToOpen == null) {
                fileToOpen = new File(filename + ".txt");

            }
            System.out.println(fileToOpen.getName());
//            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
//            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(filename+".txt"))));
            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));


            PajekNetReader<Graph<Object, Object>, Object, Object> pnr =
                    new PajekNetReader<Graph<Object, Object>, Object, Object>(vertexFactory, edgeFactory);

            realGraph = new SparseMultigraph<Object, Object>();




            StopWatch loadingTime = new StopWatch();
            loadingTime.start();
//             PajekNetReader pnr = new PajekNetReader();
//            Graph realGraph = pnr.load(br,new UserDatumNumberEdgeValue("jung.io.PajekNetFile.EdgeWeight",UserData.SHARED));
//            Graph realGraph = pnr.load(br);
//            pnr.load(br, realGraph);
//            realGraph = load(br);
            realGraph = loadModNet(br);
            originalGraph = realGraph;
            dynamicGraph = realGraph;
            currentLevelGraph = dynamicGraph;
            loadingTime.stop();
            System.out.println("Loading Time: " + loadingTime);
            collapser = new GraphCollapser(realGraph);
//            System.out.println("After loading");

//            System.exit(0);
//            realGraph = DirectionTransformer.toUndirected((Graph)realGraph);
//            realGraph = new SparseGraph();

//            int numnode = 305;//1462
//            int numedge = 6942;
            int numnode = 928;//2708
            int numedge = 7120;
//            int numnode = 2928;//2708
//            int numedge = 10000;
//            int numedgeperstep = 6;
            int numedgeperstep = 4;
//            int numedgeperstep = 4;

            /*Generate Graph using models*/
//            BarabasiAlbertGenerator ba = new BarabasiAlbertGenerator(numnode, numedgeperstep);
//            KleinbergSmallWorldGenerator kg = new KleinbergSmallWorldGenerator(10, 2.5);
//            realGraph.getEdgeConstraints().add(Graph.UNDIRECTED_EDGE);
//            realGraph = DirectionTransformer.toUndirected((Graph)kg.generateGraph());
//            StopWatch baGenTime= new StopWatch();
//            baGenTime.start();
//            realGraph = (Graph)ba.generateGraph();
//            ba.evolveGraph((int)numedge/numedgeperstep);
//            baGenTime.stop();
//            System.out.println("BA Gen Time: "+baGenTime);
//            PajekNetWriter pnw = new PajekNetWriter();
//            pnw.save(realGraph, "ba2708_7120_step4.out");
//           
//            System.exit(0);
//            Set<Vertex> vertices = realGraph.getVertices();
//            for (Vertex v : vertices){
//                System.out.println(v);
//            }

//            Set<Edge> edges = realGraph.getEdges();
//            for (Edge e : edges)
//            {
//                System.out.println(e.getUserDatum("jung.io.PajekNetFile.EdgeWeight").getClass());
//            }

//            final SubLayoutDecorator layout = new SubLayoutDecorator(new FRLayout(realGraph));
//            layout = new AggregateLayout<Object, Object>(new FRLayout<Object, Object>(realGraph));
//            layout = new AggregateLayout<Object, String>(new SpringLayout<Object, String>(realGraph));
            layout = new AggregateLayout<Object, Object>(new CircleLayout<Object, Object>(realGraph));
            System.out.println(layout.getClass());
//            System.out.println("After layout");

            vv = new VisualizationViewer<Object, Object>(layout);//,new Dimension(700, 600));
            System.out.println(vv.getModel().getGraphLayout().getClass());
            vv.setBackground(Color.white);
//            System.out.println("vv "+vv.getSize());
            DefaultParallelEdgeIndexFunction dpeif = DefaultParallelEdgeIndexFunction.getInstance();
            vv.getRenderContext().setParallelEdgeIndexFunction(dpeif);
            medp = new EdgeDisplayPredicate();
//            vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line<Object,Object>());
            vv.getRenderContext().setEdgeLabelTransformer(new EdgeLabeller(ew));
            vv.getRenderContext().setEdgeIncludePredicate(medp);
            //Tell the renderer to use our own customized color rendering
            
            vv.setVertexToolTipTransformer(new NumMemberGOTips());
            vv.getRenderContext().setVertexLabelTransformer(new GOStringLabeller()); 
            vv.getRenderContext().setVertexFontTransformer(new VertexFontTransformer());
            vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
//            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(realGraph));
            


            vv.getRenderContext().setVertexFillPaintTransformer(MapTransformer.<Object, Paint>getInstance(vertexPaints));
            vv.getRenderContext().setVertexDrawPaintTransformer(new Transformer<Object, Paint>() {

                public Paint transform(Object v) {
                    if (vv.getPickedVertexState().isPicked(v)) {
                        return Color.cyan;
                    } else {
                        return Color.BLACK;
                    }
                }
            });

            vv.getRenderContext().setEdgeDrawPaintTransformer(MapTransformer.<Object, Paint>getInstance(edgePaints));

            vv.getRenderContext().setEdgeStrokeTransformer(new EdgeWeightStrokeFunction(ew));
            vv.getRenderContext().setEdgeDrawPaintTransformer( 
                    new PickedEdgePaintFunction<Object,Object>( new PickableEdgePaintTransformer<Object>( vv.getPickedEdgeState(),Color.black,Color.cyan), vv));
//            vv.getRenderContext().setEdgeStrokeTransformer(new Transformer<Object, Stroke>() {
//
//                protected final Stroke THIN = new BasicStroke(1);
//                protected final Stroke THICK = new BasicStroke(2);
//
//                public Stroke transform(Object e) {
//                    Paint c = edgePaints.get(e);
//                    if (c == Color.LIGHT_GRAY) {
//                        return THIN;
//                    } else {
//                        return THICK;
//                    }
//                }
//            });


            final JToggleButton groupVertices = new JToggleButton("Group Clusters");

//            final VisualizationViewer vv = new VisualizationViewer(layout, pr,new Dimension(550,550));

//            getContentPane().add(vv);
//            System.out.println("Visualization Viewer");


            //Tell the renderer to use our own customized color rendering
            JButton openFile = new JButton("Open");
            openFile.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
//                    File ff = new File("../NetBeansProjects/BlondelAlgorithm/src");
//                    System.out.println(ff.getPath());
                    JFileChooser fileChooser = new JFileChooser(fileToOpen);
                    File tempFile = fileToOpen;
//                    fileChooser.addChoosableFileFilter(new TextFileFilter());
                    fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
                    fileChooser.setFileFilter(new MNetFileFilter());
//                    fileChooser.setFileHidingEnabled(false);
                    fileChooser.showOpenDialog(LouvainClustererTest.this);
                    fileToOpen = fileChooser.getSelectedFile();
                    if (fileToOpen != null) {
                        try {
                            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileToOpen)));
                            StopWatch loadingTime  = new StopWatch();
                            loadingTime.start();
//                            realGraph = load(br);
                            realGraph = loadModNet(br);
                            loadingTime.stop();
                            System.out.println("Loading Time: " + loadingTime);
                            originalGraph = realGraph;
//                            collapser = new GraphCollapser(realGraph);
//                            layout.setGraph(realGraph);
                            dynamicGraph = realGraph;
                            currentLevelGraph = dynamicGraph;
                            
                            
//             PajekNetReader pnr = new PajekNetReader();
//            Graph realGraph = pnr.load(br,new UserDatumNumberEdgeValue("jung.io.PajekNetFile.EdgeWeight",UserData.SHARED));
//            Graph realGraph = pnr.load(br);
//            pnr.load(br, realGraph);
//            realGraph = load(br);
            
                            
//                            AggregateLayout<> l = new SubLayoutDecorator(new FRLayout(realGraph));
//                            layout = l;
//                            layout = new ISOMLayout(realGraph);

                            vv.setGraphLayout(layout);
                            clusterAndRecolor(layout, similarColors, groupVertices.isSelected(), true);
                            vv.getRenderContext().getParallelEdgeIndexFunction().reset();

//                            System.out.println("Group Vertices: " + groupVertices.isSelected());
//                            vv.restart();
                            layout.initialize();
                            Relaxer relaxer = vv.getModel().getRelaxer();
                            if (relaxer != null) {
                                relaxer.stop();
                                relaxer.prerelax();
                                relaxer.relax();
                            }
                            currentLevel = 0;
                            zoomInButton.setEnabled(true);
                            zoomOutButton.setEnabled(false);
//                            collapseButton.setEnabled(false);
//                            expandButton.setEnabled(true);

                        } catch (IOException ex) {
                            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    } else {
                        fileToOpen = tempFile;
                    }
                }
            });

//            System.out.println(System.getProperties().getProperty("user.dir"));
//            System.out.println(new File("/").getPath());
//            System.out.println(new File("/").getAbsolutePath());
//            System.out.println(new File("/").getCanonicalPath());
//            System.out.println(new File("/").getParent());
//            System.out.println(new File("/").getName());
//            for (String ss : new File("/").list()){
//                System.out.println(ss);
//            }
//            System.out.println(new File("/").list()[2]);
            JButton saveButton = new JButton("Save");
            saveButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    JFileChooser chooser = new JFileChooser(new File("/Users/Knacky/Desktop"));
//                    chooser.setAcceptAllFileFilterUsed(false);
                    int option = chooser.showSaveDialog(LouvainClustererTest.this);

                    if (option == JFileChooser.APPROVE_OPTION) {
                        File file = chooser.getSelectedFile();
                        int width = vv.getWidth();
                        int height = vv.getHeight();

                        BufferedImage bi = new BufferedImage(width, height,
                                BufferedImage.TYPE_INT_RGB);
                        Graphics2D graphics = bi.createGraphics();
                        vv.paint(graphics);
                        graphics.dispose();

                        try {
                            ImageIO.write(bi, "jpeg", file);
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                    }
                }
            });

            //add restart button
            JButton scramble = new JButton("Restart");
            scramble.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
                    
                    Layout layout = vv.getGraphLayout();
                    layout.setGraph(currentLevelGraph);
                    layout.initialize();
                    colorCluster(curCSet, mainColor);
                    Relaxer relaxer = vv.getModel().getRelaxer();
                    if (relaxer != null) {
                        relaxer.stop();
                        relaxer.prerelax();
                        relaxer.relax();
                    }
                }
            });

            DefaultModalGraphMouse gm = new DefaultModalGraphMouse();
            vv.setGraphMouse(gm);
            
            gm.add(new DoubleClickZoomInPlugin<Object,Object>());



//		edgeBetweennessSlider.setBorder(BorderFactory.createLineBorder(Color.black));
            //TO DO: edgeBetweennessSlider.add(new JLabel("Node Size (PageRank With Priors):"));
            //I also want the slider value to appear
            final JPanel eastControls = new JPanel();
            eastControls.setOpaque(true);
            eastControls.setLayout(new BoxLayout(eastControls, BoxLayout.Y_AXIS));
            eastControls.add(Box.createVerticalGlue());


            //eastControls.add(eastSize);
            eastControls.add(Box.createVerticalGlue());

            groupVertices.addItemListener(new ItemListener() {

                public void itemStateChanged(ItemEvent e) {

//                        clusterAndRecolor(layout, similarColors, e.getStateChange() == ItemEvent.SELECTED, false);
                    recolor(layout, similarColors, e.getStateChange() == ItemEvent.SELECTED);
                    layout.initialize();

                    Relaxer relaxer = new VisRunner((IterativeContext) layout);
                    relaxer.stop();
                    relaxer.prerelax();
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(realGraph, layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(),
                            staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
//				vv.getRenderContext().getMultiLayerTransformer().setToIdentity();
                    vv.repaint();

                }
            });

            zoomOutButton = new JButton("Zoom Out");
            zoomOutButton.setEnabled(false);
            zoomOutButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    boolean isBioObjectSet = false;
                    zoomInButton.setEnabled(true);
                    medp.setLowestLevel(false);
//                    System.out.println("history GOP size "+historyGOProcessors.size());
                    GOProcessor gp = historyGOProcessors.remove(historyGOProcessors.size() - 1);
                    
//                    System.out.println("history cSet "+historyCSetList.size());
                    curCSetBeforeVisClust = (Set<Set>) historyCSetList.remove(historyCSetList.size() - 1);
                    curComNodeCSetBeforeVisClust = (Set<Set>) historyComNodeCSetList.remove(historyComNodeCSetList.size() - 1);
                    
                    System.out.println("cset before size " +curCSetBeforeVisClust.size());
                    System.out.println("cset before " +curCSetBeforeVisClust);
                    System.out.println("com node cset before " +curComNodeCSetBeforeVisClust);
                    
                    if (historyCSetList.size() == 0)
                        zoomOutButton.setEnabled(false);
                    curCSet = curCSetBeforeVisClust;
                    curComNodeCSet = curComNodeCSetBeforeVisClust;
                    curGOP = gp;
                    System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
                    System.out.println("GO Proc: "+curGOP.clusterScoreMap);
                    
                    if (curCSetBeforeVisClust.size() > 0){
                        if (curCSetBeforeVisClust.iterator().next() instanceof BioObject){
                            isBioObjectSet = true;
                        }
                    }
                    if (curCSetBeforeVisClust.size() >= Integer.parseInt(thresholdTextField.getText())) {
                        if (!isBioObjectSet){
                            semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforeVisClust, curCSetBeforeVisClust, Integer.parseInt(thresholdTextField.getText()));
                        } else
                            semanticClusterList = gp.preCluster(curCSet, Integer.parseInt(thresholdTextField.getText()));
                        curCSet = transformDataClusterList(semanticClusterList, false,true);
                    } else {
                        putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSetBeforeVisClust));
                    }
//        dynamicGraph = createGraphFromCSet(cSet);
        
                    if (curCSet.size() > 0){
                        if (curCSet.iterator().next() instanceof BioObject){
                            isBioObjectSet = true;
                        }
                        else{
                            isBioObjectSet = false;
                        }
                    }
                    if (!isBioObjectSet)
                        dynamicGraph = createGraphFromCSet(curCSet);
                    else
                        dynamicGraph = createGraphFromBioNodeSet(curCSet);
                    colorCluster(curCSet, mainColor);

                    vv.repaint();

                    layout.initialize();
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
                    layout.setGraph(dynamicGraph);
                    currentLevelGraph = dynamicGraph;
                    
                }
            });
                        
            collapseButton = new JButton("Collapse");
            collapseButton.setEnabled(false);
            collapseButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {
//                    hierCSet.length - 1 - 1 - displayHieBox.getSelectedIndex()
                    zoomInButton.setEnabled(true);
                    layout.initialize();

                    Relaxer relaxer = new VisRunner((IterativeContext) layout);
                    relaxer.stop();
                    relaxer.prerelax();
//                    dynamicGraph = layout.getGraph();
                    dynamicGraph = realGraph;
                    System.out.println("comnodehierset.length-1 "+(comNodehierSet.length-1));
                    int index = comNodehierSet.length - 1 - currentLevel;
                    
                    System.out.println("\ncomNodeHierSet "+(index)+": " +comNodehierSet[index] +"\n");
                    for (Set clusterOfComNode : comNodehierSet[index]) {
////                    for (int l = 0; l < comNodehierSet[currentLevel-1].size(); l++) {

//                        System.out.println("\nClusterOfComNode: " + clusterOfComNode+"\n");
                        ArrayList toPreCollapse = new ArrayList();
                        toPreCollapse.addAll(clusterOfComNode);

                        /* Codes below is similarPointToCluster to that of precollapse */
//                        dynamicGraph = LouvainClustererTest.this.preCollapse(dynamicGraph,toPreCollapse);

                        ArrayList listComNodeInGraph = new ArrayList();
                        for (Object v : toPreCollapse) {
//            System.out.println("V: "+ v);
                            Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
                            listComNodeInGraph.add(comNodeInGraph);
                        }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
                        Set toCollapseNode = new HashSet();
                        toCollapseNode.addAll(listComNodeInGraph);
//        System.out.println("toCollapseNode: "+toCollapseNode);


                        Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
                        vertexPaints.put(clusterGraph, (Color) vertexPaints.get(listComNodeInGraph.get(0)));
//        System.out.println(clusterGraph);
                        dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);

                    /* end of copied codes */

//                System.out.println(cluster);

                    }
                    dynamicGraph = updateMetaEdges(dynamicGraph);
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
                    layout.setGraph(dynamicGraph);
                    vv.getRenderContext().getParallelEdgeIndexFunction().reset();
//                    System.out.println("\nDynamic Graph: ");
//                    for (Object v : dynamicGraph.getVertices()) {
//                        if (v instanceof Graph) {
//                            System.out.println("Vertex: " + ((Graph) v).getVertices());
//                        } else {
//                            System.out.println("Vertex: " + v);
//                        }
//                    }
                    vv.repaint();
                    expandButton.setEnabled(true);
                    currentLevel--;
                    if (currentLevel == 0) {
                        ((JButton) (arg0.getSource())).setEnabled(false);
                    }
                    System.out.println("\nCollapse complete!!!!\n");
                }
            });
            
            zoomInButton = new JButton("Zoom In");
            zoomInButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    zoomInAction();
                    reLouvainCluster(curCSetBeforeVisClust, true);
                }
            });
            
            expandButton = new JButton("Expand");
            expandButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent arg0) {

                    layout.initialize();

                    Relaxer relaxer = new VisRunner((IterativeContext) layout);
                    relaxer.stop();
                    relaxer.prerelax();

//                    Graph tempGraph = layout.getGraph();
                    Graph tempGraph = realGraph;

                    Collection vertices = tempGraph.getVertices();
//                    System.out.println("\nExpand Start: ");
//                    System.out.println("Current Level: "+currentLevel);
                    System.out.println("current level "+currentLevel+" comNodehierset.length-1 "+(comNodehierSet.length-1));
                    for (Object v : vertices) {
                        boolean isSemiFinalLevel = false;
                        if ((v instanceof Graph)) {
//                            System.out.println("Vertex: "+((Graph)v).getVertices());
//                            System.out.println("Vertex count: "+((Graph)v).getVertexCount());
                            Object vnest = ((Graph) v).getVertices().iterator().next();
                            if (!(vnest instanceof Graph)) {
                                isSemiFinalLevel = true;
                            }
                            
                            if ((currentLevel + 1 >= comNodehierSet.length - 1) || !isSemiFinalLevel) {
//                            Graph g = collapser.expand(layout.getGraph(), (Graph) v);
                                Set set = new HashSet();
                                set.addAll(((Graph) v).getVertices());
                                colorCluster(set, (Color) vertexPaints.get(v));
//                                System.out.println("ver: "+v);
                                Graph g = collapser.expand(tempGraph, (Graph) v);
//                                vv.getRenderContext().getParallelEdgeIndexFunction().reset();
                                tempGraph = g;

//                            System.out.println("\nTemp Graph:");
//                            for (Object ve : tempGraph.getVertices()) {
//                                if (ve instanceof Graph) {
//                                    System.out.println("Vertex: " + ((Graph) ve).getVertices());
//                                } else {
//                                    System.out.println("Vertex: " + ve);
//                                }
//                            }
//                            layout.setGraph(g);

//                                    vv.repaint();
                            }
                        }

//                                vv.repaint();
                    }
                    if (!(vertices.iterator().next() instanceof Graph)) {
                        medp.setLowestLevel(true);
//                    for (Object v : tempGraph.getVertices()){
//                        if (v instanceof Graph){
//                            System.out.println("Vertex: "+((Graph)v).getVertices());
//                        } else
//                            System.out.println("Vertex: "+v);
//                    }
                    }
                    tempGraph = updateMetaEdges(tempGraph);
                    StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(tempGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                    Animator animator = new Animator(lt);
                    animator.start();
//                        }
                    layout.setGraph(tempGraph);
                    vv.getRenderContext().getParallelEdgeIndexFunction().reset();
                    vv.repaint();
                    currentLevel++;
                    collapseButton.setEnabled(true);
                    if (currentLevel == hierCSet.length - 1) {
                        ((JButton) (arg0.getSource())).setEnabled(false);
                    }
                    System.out.println("\nExpand complete!!!!\n");
                }
            });
            
            JPanel clusterPanel = new JPanel(new GridLayout(2, 1));
            clusterPanel.setBorder(BorderFactory.createTitledBorder("Operations"));
            clusterPanel.add(collapseButton);
            clusterPanel.add(expandButton);
            
            JPanel zoomPanel = new JPanel(new GridLayout(2, 1));
            zoomPanel.setBorder(BorderFactory.createTitledBorder("Zooming"));
            zoomPanel.add(zoomInButton);
            zoomPanel.add(zoomOutButton);

//            displayHieBox.addItemListener(new ItemListener() {
//
//                public void itemStateChanged(ItemEvent event) {
////                    System.out.println(displayHieBox.getSelectedIndex());
////                    System.out.println(currentLevel);
////                    if ((event.getStateChange() == ItemEvent.SELECTED) && (displayHieBox.getSelectedIndex() > currentLevel)) {
//                    if (displayHieBox.getSelectedIndex() > currentLevel){
//                        
//                        clusterSet = hierCSet[hierCSet.length - 1 - 1 - displayHieBox.getSelectedIndex()];
////                        System.out.println("length: "+hierCSet.length);
////                        System.out.println("selected index: "+displayHieBox.getSelectedIndex());
////                        System.out.println("index hi set: "+(hierCSet.length-1-1-displayHieBox.getSelectedIndex()));
////                        System.out.println(hierCSet[hierCSet.length-1-1-displayHieBox.getSelectedIndex()]);
////                        System.out.println("hier 0: "+hierCSet[0]);
////                        vv.restart();
////                        recolor(layout, similarColors, groupVertices.isSelected());
//                        
////                        if (groupVertices.isSelected()) {
//                        layout.initialize();
//
//                            Relaxer relaxer = new VisRunner((IterativeContext) layout);
//                            relaxer.stop();
//                            relaxer.prerelax();
//                            
//                            Collection vertices = layout.getGraph().getVertices();
//                            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(layout.getGraph(), layout);
//                            for (Object v : vertices) {
//                                if (v instanceof Graph) {
//                                    
//                                    
//                                    Graph g = collapser.expand(layout.getGraph(), (Graph) v);
////                                vv.getRenderContext().getParallelEdgeIndexFunction().reset();
//                                    layout.setGraph(g);
//                                    
////                                    vv.repaint();
//                                }
//                                
////                                vv.repaint();
//                            }
//                            
//                            LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayout, vv.getGraphLayout());
////                                    staticLayout);
//                        Animator animator = new Animator(lt);
//                        animator.start();
////                        }
//
//                        vv.repaint();
//                    }
//                    currentLevel=displayHieBox.getSelectedIndex();
////                    throw new UnsupportedOperationException("Not supported yet.");
//                }
//            });
            
            Class[] combos = getLayoutCombos();
            final JComboBox jcb = new JComboBox(combos);
            // use a renderer to shorten the layout name presentation
            jcb.setRenderer(new DefaultListCellRenderer() {

                @Override
                public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                    String valueString = value.toString();
                    valueString = valueString.substring(valueString.lastIndexOf('.') + 1);
                    return super.getListCellRendererComponent(list, valueString, index, isSelected,
                            cellHasFocus);
                }
            });
            
            
            
            clusterAndRecolor(layout, similarColors, groupVertices.isSelected(), true);
            vv.getRenderContext().setVertexShapeTransformer(new VertexShapeSizeAspect<Object, Object>(dynamicGraph));
            jcb.addActionListener(new LayoutChooser(jcb, vv));
            jcb.setSelectedItem(CircleLayout.class);

            Container content = getContentPane();
            content.add(new GraphZoomScrollPane(vv));
            JPanel east = new JPanel();
            JPanel west = new JPanel();
            west.setPreferredSize(new Dimension(180,600));
            east.setPreferredSize(new Dimension(180,600));
            JPanel grid = new JPanel(new GridLayout(2, 1));
            JPanel grid2 = new JPanel(new GridLayout(2, 1));
            grid.add(scramble);
//            grid.add(groupVertices);
            grid2.add(openFile);
            grid2.add(saveButton);
           
            JPanel p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Mouse Mode"));
            p.add(gm.getModeComboBox());
            
            
            east.add(grid2);
            east.add(grid);
            east.add(p);
//            east.add(clusterPanel);
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Layout"));
            p.add(jcb);
            east.add(p);
            east.add(zoomPanel);
            
//            east.add(displayHieBox);
            east.add(eastControls);
            
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Louvain Clusterer"));
                        
            JButton reLouvainButton = new JButton("  Perform  ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
            reLouvainButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                   reLouvainCluster(curCSetBeforeVisClust,true);
                }
            });
            p.add(reLouvainButton);
            east.add(p);
            
                       
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Vis Threshold"));
            JPanel grid3 = new JPanel(new GridLayout(2, 1));
            grid3.add(thresholdTextField);
            thresholdTextField.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    reVisCluster(false);
                }
            });
            p.add(grid3);
            JButton visThreshPerform = new JButton("Cluster");
            visThreshPerform.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                   reVisCluster(false);
                }
            });
            grid3.add(visThreshPerform);
            east.add(p);
            
            p = new JPanel();
            
            p.setBorder(BorderFactory.createTitledBorder("GO Namespace Weight"));
            grid3 = new JPanel(new GridLayout(3, 1));
            
            ccSlider.setMajorTickSpacing(2);
//            ccSlider.setPreferredSize(new Dimension(p.getPreferredSize().width-50,ccSlider.getPreferredSize().height));
            ccSlider.setMinorTickSpacing(1);
            ccSlider.setPaintTicks(true);
//            Hashtable labelTable = new Hashtable();
//            ccSlider.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
            
            TitledBorder title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Cellular Component");
            title.setTitleColor(new Color(0xED143F));
            title.setTitlePosition(TitledBorder.CENTER);
            ccSlider.setBorder(title);


//            labelTable.put( new Integer( ccSlider.getMaximum()/2 ), new JLabel("Cellular Component") );
//            ccSlider.setLabelTable(labelTable);
//            ccSlider.setPaintLabels(true);
//            ccSlider.setPaintTrack(true);
            
            bpSlider.setMajorTickSpacing(2);
            bpSlider.setMinorTickSpacing(1);
            bpSlider.setPaintTicks(true);
//            bpSlider.setPaintLabels(true);
//            labelTable = new Hashtable();
//            labelTable.put( new Integer( bpSlider.getMaximum()/2 ), new JLabel("Biological Process") );
//            bpSlider.setLabelTable(labelTable);
            title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Biological Process");
            title.setTitlePosition(TitledBorder.CENTER);
            title.setTitleColor(new Color(0x3425B1));
            bpSlider.setBorder(title);
            
            mfSlider.setMajorTickSpacing(2);
            mfSlider.setMinorTickSpacing(1);
            mfSlider.setPaintTicks(true);
//            mfSlider.setPaintLabels(true);
//            labelTable = new Hashtable();
//            labelTable.put( new Integer( mfSlider.getMaximum()/2 ), new JLabel("Molecular Function") );
//            mfSlider.setLabelTable(labelTable);
            title = BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0), "Molecular Function");
            title.setTitlePosition(TitledBorder.CENTER);
            title.setTitleColor(new Color(0x338F06));
            mfSlider.setBorder(title);

            
            grid3.add(ccSlider);
            grid3.add(mfSlider);
            grid3.add(bpSlider);
//            grid3.setPreferredSize(new Dimension(p.getPreferredSize().width-10,grid3.getPreferredSize().height));
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            p.add(grid3);
            JButton GORefineButton = new JButton("Refine");
            GORefineButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    refineGOAnnot(e);
                }
            });
            p.add(GORefineButton);
            p.setPreferredSize(new Dimension(170,p.getPreferredSize().height+32));
            
            west.add(p);
            
            p = new JPanel();
            
            p.setBorder(BorderFactory.createTitledBorder("GO Edge Filter"));
            goEdgeSlider.setMajorTickSpacing(2);
            goEdgeSlider.setMinorTickSpacing(1);
            goEdgeSlider.setPaintTicks(true);
            goEdgeSlider.addChangeListener(new ChangeListener() {

                public void stateChanged(ChangeEvent e) {
                    JSlider source = (JSlider) e.getSource();
                    if (!source.getValueIsAdjusting()) 
                    {
                        double threshold = source.getValue();
//                        System.out.println("threshold "+threshold);
                        if (threshold == source.getMaximum()){
                            System.out.println("thresh max: "+threshold);
                            medp.setThresholdForSE(0.0);
                        } else if (threshold == 0.0){
                            /* inner product will never be more than 1 */
                            medp.setThresholdForSE(2.0);
                        } else {
                            System.out.println("thresh "+(source.getMaximum()-threshold));
                            medp.setThresholdForSE(0.1*(source.getMaximum()-threshold));
                        }
                        vv.repaint();
                    }
                }

            });
            grid3 = new JPanel(new GridLayout(1, 1));
            grid3.add(goEdgeSlider);
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            p.add(grid3);
            p.setPreferredSize(new Dimension(170,p.getPreferredSize().height));
            west.add(p);
            
            p = new JPanel();
            p.setBorder(BorderFactory.createTitledBorder("Center Node(s)"));
            
            grid3 = new JPanel(new GridLayout(1,2));
            grid3.add(new JLabel("Num Hops: "));
            
            grid3.add(numHops);
            grid3.setPreferredSize(new Dimension(160,grid3.getPreferredSize().height));
            
            JButton centerButton = new JButton("  Perform  ");
//            reLouvainButton.setPreferredSize(new Dimension(100,20));
            centerButton.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                   centerNodes();
                }
            });
            
            p.add(grid3);
            p.add(centerButton);
            p.setPreferredSize(new Dimension(170,p.getPreferredSize().height+30));
            west.add(p);
            
            
//            east.add(p);
            content.add(east, BorderLayout.EAST);
            content.add(west,BorderLayout.WEST);
            pack();
            setVisible(true);

        } catch (IOException e) {
            // TODO Auto-generated catch block
            System.out.println("Error in loading graph");
            e.printStackTrace();
        }
    }
    
    public void refineGOAnnot(ActionEvent e){
        double ccValue = (double)ccSlider.getValue()/10;
        double mfValue = (double)mfSlider.getValue()/10;
        double bpValue = (double)bpSlider.getValue()/10;
//        System.out.println("cc "+ccValue);
//        System.out.println("mf "+mfValue);
//        System.out.println("bp "+bpValue);
        GOProcessor.getWeightMap().put(NameSpace.BP, bpValue);
        GOProcessor.getWeightMap().put(NameSpace.MF, mfValue);
        GOProcessor.getWeightMap().put(NameSpace.CC, ccValue);
        reVisCluster(true);
    }
    
    public void centerNodes(){
        String toNumHops = numHops.getText();
        int numHopsFromCenter = 0;
        try{
            numHopsFromCenter = Integer.parseInt(toNumHops);
        } catch (NumberFormatException e){
            String toShown = "Number of hops should be integer only.";
            JOptionPane.showMessageDialog(LouvainClustererTest.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);
        }
        Set pickedSet = vv.getPickedVertexState().getPicked();
        System.out.println("pickedSet size: "+pickedSet.size());

        if (pickedSet.size() != 0){
            /* check if the vertex is the set (of set or of BioObject) */
            if (pickedSet.iterator().next() instanceof Set) {
                currentLevelGraph = dynamicGraph;
                
//                historyCSetList.add(curCSetBeforeVisClust); historyComNodeCSetList.add(curComNodeCSetBeforeVisClust);
//                historyGOProcessors.add(curGOP);
//                System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
//                zoomOutButton.setEnabled(true);
                Set cSet = new HashSet(), comNodeCSet = new HashSet(),cSetCenter = new HashSet();
                Set nodesInCenterSet = new HashSet();
                Set nodesAroundCenter = new HashSet();
                Set toBeProcessed = new HashSet();
                
                for (Object ver : pickedSet) {
                    Set vertex = (Set) ver;
                    System.out.println("\nVertex: "+vertex);
                    System.out.println("\nVertex size: "+vertex.size());
                    
                    nodesInCenterSet.addAll(vertex);
                    cSet.add(vertex); cSetCenter.add(vertex);
                    comNodeCSet.add(flatClustToComNodeClust.get(vertex));
                }
                
                    
                toBeProcessed.addAll(nodesInCenterSet);
//                System.out.println("nodes in center "+nodesInCenterSet);
//                System.out.println("toBeProcessed "+toBeProcessed);
                for (int i = 1; i <= numHopsFromCenter; i++){
//                    System.out.println("");
//                    System.out.println("nodesaround "+nodesAroundCenter);
                    Set neighbors = new HashSet();
                    Set tmpSet = new HashSet(toBeProcessed);
                    Iterator it = tmpSet.iterator();
                    for (;it.hasNext();){
                        Object object = it.next();
                        BioObject bio = (BioObject)object;
//                        System.out.println("Bio: "+bio);
//                        if (!nodesAroundCenter.contains(bio)){
//                            if (i > 1){
//                                if (nodesInCenterSet.contains(bio))
//                                {
//                                    toBeProcessed.remove(object);
//                                    continue;
//                                }
//                            }
                            for (Object neighbor : originalGraph.getNeighbors(bio)){
//                                System.out.println("neighbor "+neighbor);
                                if (!nodesInCenterSet.contains(neighbor) && !nodesAroundCenter.contains(neighbor)){
                                    neighbors.add(neighbor);
//                                    System.out.println("added!!");
                                }
                            }
                            
                            toBeProcessed.addAll(neighbors);
//                        }
                        toBeProcessed.remove(object);
//                        System.out.println("To be processed "+toBeProcessed);
                    }
                    
                    nodesAroundCenter.addAll(toBeProcessed);
//                    System.out.println("toBeProcessed "+toBeProcessed);
//                    System.out.println("toBeProcessed size "+toBeProcessed.size());
                }
//                System.out.println("nodes around center "+nodesAroundCenter);
//                System.out.println("nodes around center size "+nodesAroundCenter.size());
                Set newCSet = new HashSet();
                newCSet.addAll(reLouvainCluster(nodesAroundCenter, false));
                cSet.addAll(newCSet);
                comNodeCSet.addAll(curComNodeCSetCentered);
                curCSetCentered = cSet;
                curComNodeCSetCentered = comNodeCSet;
                System.out.println("New Set ");
                for (Object obj : newCSet){
                    System.out.println("Vertex : "+obj);
                }
                
//                System.out.println("curGOP size "+curGOP.clusterScoreMap.size() );
//                System.out.println("Picked Set");
//                for (Object ver : pickedSet) {
//                    curGOPCentered.clusterScoreMap.put(ver, curGOP.clusterScoreMap.get(ver));
//                    System.out.println("Vertex : "+ver);
//                    System.out.println("Vertex val: "+curGOPCentered.clusterScoreMap.get(ver));
//                }
//                System.out.println("Current GO Map");
//                putInNodesGOVectorMapRelatively(curGOPCentered.getNodesGOVectorMapBeforeCluster(cSet));
                
////        int thresh = 12;
//                if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
//                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, comNodeCSet, cSet, Integer.parseInt(thresholdTextField.getText()));
//                    cSet = transformDataClusterList(semanticClusterList, isTopLevel, doOnAllNodesInCanVas);
//                } else {
//                    putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
//                }
////        dynamicGraph = createGraphFromCSet(cSet);
//
//                if (doOnAllNodesInCanVas) {
//                    curGOP = gp;
//                    System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
//                } else {
//                    curGOPCentered = gp;
//                }

                System.out.println("cSet: " + cSet.size());
                
                dynamicGraph = createGraphFromCSet(cSet);
//        colorTopLevel(dynamicGraph);
                colorCluster(newCSet, peripheralColor);
                colorCluster(cSetCenter,mainColor);
//        layout.setSize(new Dimension(100,100));
//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
                layout.setGraph(dynamicGraph);
                Graph tempGraph = SparseMultigraph.getFactory().create();
                for (Object object : cSetCenter){
                    tempGraph.addVertex(object);
                
                }
                Layout subLayout = new CircleLayout(tempGraph);
                subLayout.setInitializer(vv.getGraphLayout());
                subLayout.setSize(new Dimension(60,60));
                
//                System.out.println("Center "+vv.getSize().width/2);
                layout.put(subLayout,new Point(vv.getSize().width/2, vv.getSize().height/2));
                
                StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                Animator animator = new Animator(lt);
                animator.start();
                
                
//                currentLevelGraph = dynamicGraph;
//        layout.setGraph(newgraph);
                vv.repaint();
                
            }
        }
    }
    
    public Set reLouvainCluster(Set cSet, boolean doOnAllNodesInCanvas){
        Set<BioObject> bioObjectToClusteredSet = new HashSet<BioObject>();
        int id = 0;
        nodeMap.clear();
        final Map<BioObject,Integer> idMap = new HashMap<BioObject,Integer>();
        Iterator iter = cSet.iterator();
        
        for (;iter.hasNext();){
            Object obj = iter.next();
            if (obj instanceof Set)
            {
                Set<BioObject> set = (Set<BioObject>)obj;
                for (BioObject bio : set){
                    bioObjectToClusteredSet.add(bio);
                    nodeMap.put(id, bio);
                    idMap.put(bio, id);
                    id++;
                }
            }
//                bioObjectToClusteredSet.addAll((Set)obj);
            else if (obj instanceof BioObject){
                bioObjectToClusteredSet.add((BioObject) obj);
                nodeMap.put(id,(BioObject)obj);
                idMap.put((BioObject)obj,id);
                id++;
            }
        }
        Set edgeSet = new TreeSet(new Comparator() {

            public int compare(Object e1, Object e2) {
                Pair pair1 = originalGraph.getEndpoints(e1);
                Object e1v1 = pair1.getFirst();
                Object e1v2 = pair1.getSecond();
                Pair pair2 = originalGraph.getEndpoints(e2);
                Object e2v1 = pair2.getFirst();
                Object e2v2 = pair2.getSecond();
                if (idMap.get(e1v1) < idMap.get(e2v1)){
                    return -1;
                } else if (idMap.get(e1v1) == idMap.get(e2v1)){
                    if (idMap.get(e1v2) < idMap.get(e2v2)){
                        return -1;
                    } else if (idMap.get(e1v2) == idMap.get(e2v2)) {
                        return 0;
                    } else
                        return 1;
                } else
                    return 1;
            }
        });
        for (BioObject bio : bioObjectToClusteredSet){
            for (Object edge : originalGraph.getIncidentEdges(bio))
            {
                Pair pair = originalGraph.getEndpoints(edge);
                Object firstVertex = pair.getFirst();
                Object secondVertex = pair.getSecond();
                if (!idMap.containsKey(firstVertex))
                    continue;
                if (!idMap.containsKey(secondVertex))
                    continue;
                edgeSet.add(edge);
            }
//            edgeSet.addAll(originalGraph.getIncidentEdges(bio));
        }
        int numEdge = edgeSet.size();
        System.out.println("Edge set size "+numEdge);
        System.out.println("Bio set "+bioObjectToClusteredSet.size());
        
        sArr = new int[numEdge];
        dArr = new int[numEdge];
        if (wArr != null)
            wArr = new double[numEdge];
        StopWatch sw = new StopWatch();
        sw.start();
//        String toLouvainClusterer = "";
//        StringBuilder stb = new StringBuilder(10000);
        int i = 0;
        for (Object edge : edgeSet){
            Pair pair = originalGraph.getEndpoints(edge);
            Object firstVertex = pair.getFirst();
            Object secondVertex = pair.getSecond();
//            System.out.println(idMap.get(firstVertex)+":"+idMap.get(secondVertex));
//            toLouvainClusterer += idMap.get(firstVertex)+"\t"+idMap.get(secondVertex)+"\t";
//            stb.append(idMap.get(firstVertex)).append("\t").append(idMap.get(secondVertex)).append("\t");
            sArr[i] = idMap.get(firstVertex); dArr[i] = idMap.get(secondVertex);
            if (isWeightGraph) {
                int weight = ew.getWeight(edge);
//            int weight = 1;

//                if (weight > 0) {
                    wArr[i] = weight;
//                    stb.append(weight);
//                toLouvainClusterer += weight;
//                }
            }
//            stb.append("\n");
//            toLouvainClusterer += "\n";
            i++;
        }
//        System.out.println("toLouvain "+toLouvainClusterer);
//        toLouvainClusterer = stb.toString();
        sw.stop();
        System.out.println("Load to String time "+sw);
        MainLouvain ml = new MainLouvain();
        try {

//            int[][] hierarchyComNode = ml.louvainClusterer(fileToOpen.getPath(),true);
            if (edgeSet.size() > 0) {
//                int[][] hierarchyComNode = ml.louvainClusterer(toLouvainClusterer, false);
                int[][] hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
                cSet = processClusterSet(dynamicGraph, hierarchyComNode, false, doOnAllNodesInCanvas);
            }
            
//        for (Object edge : edgeSet){
//            Pair pair = originalGraph.getEndpoints(edge);
//            Object firstVertex = pair.getFirst();
//            Object secondVertex = pair.getSecond();
//            if (!nodeMap.containsValue(firstVertex))
//                nodeMap.put(id,(BioObject) firstVertex);
//
//        }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
        }
        return cSet;
//        for (Object edge : edgeSet){
//            Pair pair = originalGraph.getEndpoints(edge);
//            Object firstVertex = pair.getFirst();
//            Object secondVertex = pair.getSecond();
//            if (!nodeMap.containsValue(firstVertex))
//                nodeMap.put(id,(BioObject) firstVertex);
//            
//        }
        
    }
    public void reVisCluster(boolean newAnnot){
        
//                    System.out.println("curCSet "+curCSet);
//                    System.out.println("Cur com node cSet "+curComNodeCSet);
//                    System.out.println("curCSet before "+curCSetBeforeVisClust);
//                    System.out.println("Cur com node cSet before "+curComNodeCSetBeforeVisClust);
        if (curCSetBeforeVisClust.size() >= Integer.parseInt(thresholdTextField.getText()) || (newAnnot)) {
//                         GOProcessor gp = new GOProcessor();
            zoomInButton.setEnabled(true);
            GOProcessor gp = curGOP;
            if (newAnnot)
                gp.populateGOTerms(curCSetBeforeVisClust);
            System.out.println("GO Proc size: " + curGOP.clusterScoreMap.size());
//                         gp.populateGOTerms(curCSetBeforeVisClust);
            int numClust = 0;
            if (newAnnot)
                numClust = curCSet.size();
            else
                numClust = Integer.parseInt(thresholdTextField.getText());    
            if (!(curCSetBeforeVisClust.iterator().next() instanceof BioObject)) {
                semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforeVisClust, curCSetBeforeVisClust, numClust);
            } else {
                semanticClusterList = gp.preCluster(curCSetBeforeVisClust, numClust);
            }
//            semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSetBeforeVisClust, curCSetBeforeVisClust, Integer.parseInt(thresholdTextField.getText()));
            curCSet = transformDataClusterList(semanticClusterList, false,true);
            dynamicGraph = createGraphFromCSet(curCSet);
            currentLevelGraph = dynamicGraph;
            colorCluster(curCSet, mainColor);

//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
            Animator animator = new Animator(lt);
            animator.start();
            layout.setGraph(dynamicGraph);
        } else {
            String toShown = "A number of nodes in the canvas are less than/equal to that specified in the text box. " + curCSetBeforeVisClust.size();
            JOptionPane.showMessageDialog(LouvainClustererTest.this, toShown, "Notice", JOptionPane.INFORMATION_MESSAGE);

        }

    }
    
    JTextField thresholdTextField = new JTextField("12",10);
    JTextField numHops = new JTextField("2",5);
    JSlider ccSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);            
    JSlider bpSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider mfSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 10);
    JSlider goEdgeSlider = new JSlider(JSlider.HORIZONTAL, 0, 10, 9);
    JComboBox displayHieBox = new JComboBox();
//    Set<Set<Object>>[] hierCSet = null;
//    Set<Set<Object>>[] comNodehierSet = null;
    Set<Set>[] hierCSet = null;
    Set<Set>[] comNodehierSet = null;
//    BlondelClusterer clusterer;
    /* old clusterSet used in the JUNG demo */
    Set<Set> clusterSet;

//    public BioObject[][] changeToBioObject(int[][] hierarchyComNode){
//
//        return null;
//    }
    public void clusterAndRecolor(AggregateLayout<Object, Object> layout,
                                  Color[] colors, boolean groupClusters, boolean clustering) throws FileNotFoundException, IOException {
        //Now cluster the vertices by removing the top 50 edges with highest betweenness
        //		if (numEdgesToRemove == 0) {
        //			colorCluster( g.getVertices(), colors[0] );
        //		} else {
//        int numClustersWanted = 5;
        Graph<Object, Object> g = layout.getGraph();

        if (clustering == true) {
//            System.out.println("num node: " + g.getVertexCount() + " num edge: " + g.getEdgeCount());
//            clusterer = new BlondelClusterer(threshold);

//        EdgeBetweennessClusterer clusterer =
//                new EdgeBetweennessClusterer(numEdgesToRemove);
            StopWatch stopwatch = new StopWatch();
            stopwatch.start();
//            clusterSet = clusterer.extract(g);
//            clusterer.extractHierarchy(g);
            MainLouvain ml = new MainLouvain();

//            int[][] hierarchyComNode = ml.louvainClusterer(fileToOpen.getPath(),true);
//            int[][] hierarchyComNode = ml.louvainClusterer(stringStream, false);
            int[][] hierarchyComNode = ml.louvainClusterer(sArr, dArr, wArr);
//            BioObject[][] hierBioObjComNode = changeToBioObject(hierarchyComNode);
            System.out.println("After Clustering");
            
            GOProcessor.loadGOTermsMap();
            Map<NameSpace,Double> map = new HashMap<NameSpace, Double>();
            map.put(NameSpace.BP, 1.0);
            map.put(NameSpace.MF, 1.0);
            map.put(NameSpace.CC, 1.0);
            GOProcessor.setWeightMap(map);
            clusterSet = processClusterSet(g, hierarchyComNode,true,true);
            System.out.println("Process After Clustering");
            stopwatch.stop();
//            displayHieBox = new JComboBox();
            displayHieBox.removeAllItems();
//            System.out.println(displayHieBox.getItemListeners().length);
//            for (ItemListener il : displayHieBox.getItemListeners()){
//                System.out.println(il);
//            }
            for (int i = hierarchyComNode.length - 1 - 1; i >= 0; i--) {
                displayHieBox.addItem("level " + (hierarchyComNode.length - 1 - 1 - i) + " (" + hierarchyComNode[i + 1].length + " clusters)");
            }
            displayHieBox.validate();
//            System.out.println(stopwatch);


            if (!UIWanted) {
                System.exit(0);
//        System.out.println("remove num edges: " + clusterer.getNumEdgesRemoved() + " Number of Clusters produced: " + numClustersWanted + " " + clusterSet.size());
            }
        }
//        Iterator s = ((Vertex)(clusterSet.getCluster(0).toArray()[0])).getUserDatumKeyIterator();
        //s.next(); //s.next();
//        System.out.println(s.next());
//        List edges = clusterer.getEdgesRemoved();

        recolor(layout, colors, groupClusters);
//        List edges = new ArrayList();
//
//        int i = 0;
//        //Set the colors of each node so that each cluster's vertices have the same color
//        for (Iterator cIt = clusterSet.iterator(); cIt.hasNext();) {
//
//            Set vertices = (Set) cIt.next();
//            Color c = colors[i % colors.length];
//
//            colorCluster(vertices, c);
//            if (groupClusters == true) {
//                groupCluster(layout, vertices);
//            }
//            i++;
//        }
//        for (Iterator it = g.getEdges().iterator(); it.hasNext();) {
//            Edge e = (Edge) it.next();
//            if (edges.contains(e)) {
//                e.setUserDatum(DEMOKEY, Color.LIGHT_GRAY, UserData.SHARED);
//            } else {
//                e.setUserDatum(DEMOKEY, Color.BLACK, UserData.SHARED);
//            }
//        }

    }

    private void recolor(AggregateLayout<Object, Object> layout, Color[] colors, boolean groupClusters) {
//        List edges = new ArrayList();
        Graph<Object, Object> g = layout.getGraph();
        layout.removeAll();
        int i = 0;
//        clusterSet = hierCSet[hierCSet.length - 1 - currentLevel];
//        System.out.println("clusterSet: "+clusterSet);
        //Set the colors of each node so that each cluster's vertices have the same color
        for (Iterator<Set> cIt = clusterSet.iterator(); cIt.hasNext();) {

            Set<Object> vertices = (Set) cIt.next();
            Color c = colors[i % colors.length];

            colorCluster(vertices, c);
            if (groupClusters == true) {
                groupCluster(layout, vertices);
            }
            i++;
        }
        for (Object e : g.getEdges()) {
//        for (String e : g.getEdges()) {

//            if (edges.contains(e)) {
//                edgePaints.put(e, Color.lightGray);
//            } else {
            if (e instanceof String) {
                edgePaints.put(e, Color.LIGHT_GRAY);
//            }
            }
        }

    }

    private void colorCluster(Set vertices, Color c) {
        for (Object v : vertices) {
            vertexPaints.put(v, c);
        }

    }

    private int currentLevel = 0;
    Map<Set<Set>,Set<Set>> cSetToComNodeCSet = new HashMap<Set<Set>,Set<Set>>();
    Map<Set, Set> flatClustToComNodeClust = new HashMap<Set, Set>();
    Map<Set, Set> comNodeClustToFlatClust = new HashMap<Set, Set>();
//    Map<Set, DataCluster> nodeToDataCluster = new HashMap<Set, DataCluster>();

    private Set<Set> processClusterSet(Graph g, int[][] hierarchyComNode,boolean isTopLevel, boolean doOnAllNodesInCanVas) throws IOException {
        ArrayList<Integer> labelList = new ArrayList();
        ArrayList<Set<Object>> csList = new ArrayList();

        ArrayList<Set<Object>> newCsList = new ArrayList();

        ArrayList<Set<Object>> arrComNode = new ArrayList();
        
        ArrayList<Set<Object>> newArrComNode = new ArrayList();

//        Set<Set<Number>> cSet = new VertexClusterSet(g);
//        Set<Set<Object>> cSet = new HashSet<Set<Object>>();
//        Set<Set<Object>> comNodeCSet = new HashSet<Set<Object>>();
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();
        if (isTopLevel) {
            hierCSet = new HashSet[hierarchyComNode.length];
            comNodehierSet = new HashSet[hierarchyComNode.length];
        }
//        int i = 0;

//        if (hierarchyComNode.length < 2)
//        {
//            
//        }

        System.out.println("Start process cluster set!");
        // hierarchyComNode should have length >= 2
        for (int j = 0; j < hierarchyComNode[1].length; j++) {
//            csList.add(new ArrayList<Object>());
            csList.add(new HashSet<Object>());
//            arrComNode.add(new ArrayList());
            arrComNode.add(new HashSet());
        }
        for (int j = 0; j < hierarchyComNode[0].length; j++) {
            if (!labelList.contains(hierarchyComNode[0][j])) {
                labelList.add(hierarchyComNode[0][j]);
            }
//                StringLabeller sl = StringLabeller.getLabeller(g, "node name");
            int index = labelList.indexOf(hierarchyComNode[0][j]);
//            ArrayList<Object> cluster = csList.get(labelList.indexOf(hierarchyComNode[0][j]));
//            ArrayList<Object> cluster = csList.get(index);
            Set<Object> cluster = csList.get(index);
//            ArrayList clusterOfComNode = arrComNode.get(index);
            Set clusterOfComNode = arrComNode.get(index);
//            cluster.add(j);
//            clusterOfComNode.add(j);
            cluster.add(nodeMap.get(j));
            clusterOfComNode.add(nodeMap.get(j));
            
//                System.out.println(i);

//                cluster.add(sl.getVertex(Integer.toString(j)));

        }
//        System.out.println("Vertices: " + g.getVertices());
//        System.out.println("Edges: " + g.getEdges());
//        Set<Object> tToCSet = new HashSet<Object>();
        comNodeCSet = new HashSet<Set>();
//            System.out.println("arrcomnode: "+arrComNode);
//        System.out.println("csList "+csList.size());
        for (int l = 0; l < csList.size(); l++) {
//        for (ArrayList<Object> cluster : csList) {
            /* only at this level we can use cluster instead of clusterOfComNode */
            Set<Object> cluster = csList.get(l);
//            ArrayList clusterOfComNode = arrComNode.get(l);
            
//            Set<Object> toCSet = new HashSet();
//            Set toComNodeCSet = new HashSet();
            
            
//            toCSet.addAll(cluster);
////            toComNodeCSet.addAll(clusterOfComNode);
//            toComNodeCSet.addAll(cluster);
//            cSet.add(toCSet);
//            comNodeCSet.add(toComNodeCSet);
//            flatClustToComNodeClust.put(toCSet, toComNodeCSet);
//            comNodeClustToFlatClust.put(toComNodeCSet, toCSet);
            cSet.add(cluster);
            comNodeCSet.add(cluster);
            flatClustToComNodeClust.put(cluster, cluster);
            comNodeClustToFlatClust.put(cluster, cluster);
            
//            System.out.println("\ntoCSet: " + cluster+" toComNodeCSet "+cluster);
//            tToCSet = toCSet;
//            dynamicGraph = collapseNodeSet(dynamicGraph, toCSet);

//            cSet.addCluster(toCSet);
//            System.out.println(cluster);
        }
//        System.out.println("Dynamic Graph Vertices: "+dynamicGraph.getVertices());
//        hierCSet[0] = new VertexClusterSet(g);
//        System.out.println(tToCSet);
//        System.out.println("Graph ver: "+layout.getGraph().getVertices());
//        System.out.println(layout.getGraph().getVertices());
//        Graph vx = null;
//        for (Object v: layout.getGraph().getVertices()){
//            System.out.println(v);
//            vx = (Graph) v;
////            System.out.println(((Graph)v). == collapser.getClusterGraph(realGraph, tToCSet));
//        }
//        System.out.println(collapser.getClusterGraph(realGraph, tToCSet));
//        System.out.println(layout.getGraph().containsVertex(collapser.getClusterGraph(realGraph, tToCSet)));
//        System.out.println(layout.getGraph().containsVertex(vx));
        cSetToComNodeCSet.put(cSet, comNodeCSet);
        if (isTopLevel) {
            hierCSet[0] = cSet;
            comNodehierSet[0] = comNodeCSet;
            System.out.println("\ncomNodehierSet "+0+": "+comNodehierSet[0]+"\n");
            System.out.println("\nhierCSet "+0+": "+hierCSet[0]+"\n");
        }
        
//        comNodehierSet[0].addAll(cSet);
//        Set toBeCollpased = new HashSet();

        for (int i = 1; i < hierarchyComNode.length - 1; i++) {
            labelList.clear();
            newCsList.clear();
            newArrComNode.clear();
//            System.out.println("size "+(i)+" "+hierarchyComNode[i].length);
//            System.out.println("size "+(i+1)+" "+hierarchyComNode[i+1].length);
            for (int j = 0; j < hierarchyComNode[i + 1].length; j++) {
                newCsList.add(new HashSet<Object>());
//                arrComNode.add(new HashSet());
                newArrComNode.add(new HashSet());
            }
//            System.out.println("size csList "+csList.size());
//            System.out.println("size new csList "+newCsList.size());
            for (int j = 0; j < hierarchyComNode[i].length; j++) {
                if (!labelList.contains(hierarchyComNode[i][j])) {
                    labelList.add(hierarchyComNode[i][j]);
                }

//                StringLabeller sl = StringLabeller.getLabeller(g,"node name");
                int index = labelList.indexOf(hierarchyComNode[i][j]);
                Set<Object> cluster = newCsList.get(index);
//                Set clusterOfComNode = arrComNode.get(index);
                Set clusterOfComNode = newArrComNode.get(index);
//                System.out.println(i);
                cluster.addAll(csList.get(j));
//                clusterOfComNode.add(csList.get(j));
                clusterOfComNode.add(arrComNode.get(j));
            }

            //clone newCsList to csList safely
            csList.clear();
            for (Set<Object> av : newCsList) {
                Set<Object> list = new HashSet<Object>();
                csList.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }
            
            //clone newArrComNode to arrComNode safely
            arrComNode.clear();
            for (Set<Object> av : newArrComNode) {
                Set<Object> list = new HashSet<Object>();
                arrComNode.add(list);
                for (Object v : av) {
                    list.add(v);
                }
            }
//            csList = newCsList.clone();

//            System.out.println("");
            cSet = new HashSet<Set>();//new VertexClusterSet(g);
            comNodeCSet = new HashSet<Set>();
//            System.out.println("arrcomnode: "+arrComNode);
            for (int l = 0; l < csList.size(); l++) {
//            for (ArrayList<Object> cluster : csList) {
                Set<Object> cluster = csList.get(l);
                Set clusterOfComNode = arrComNode.get(l);
//                Set<Object> toCSet = new HashSet();
//                Set toComNodeCSet = new HashSet();
//                toCSet.addAll(cluster);
//                toComNodeCSet.addAll(clusterOfComNode);
//                cSet.add(toCSet);
//                comNodeCSet.add(toComNodeCSet);
                cSet.add(cluster);
                comNodeCSet.add(clusterOfComNode);
//                flatClustToComNodeClust.put(toCSet, toComNodeCSet);
//                comNodeClustToFlatClust.put(toComNodeCSet, toCSet);
                flatClustToComNodeClust.put(cluster, clusterOfComNode);
                comNodeClustToFlatClust.put(clusterOfComNode, cluster);
//                if (i==3)
//                    System.out.println("\ntoCSet: " + cluster+" toComNodeCSet "+clusterOfComNode);
//                System.out.println("ClusterOfComNode: "+clusterOfComNode);
//                dynamicGraph = preCollapse(dynamicGraph, clusterOfComNode);
//                collapseNodeSet(layout, toCSet);
//                cSet.addCluster(toCSet);
//                System.out.println(cluster);
            }
            cSetToComNodeCSet.put(cSet, comNodeCSet);
            
            if (isTopLevel) {
                hierCSet[i] = cSet;
                comNodehierSet[i] = comNodeCSet;

                System.out.println("\ncomNodehierSet " + i + ": " + comNodehierSet[i] + "\n");
                System.out.println("\nhierCSet " + i + ": " + hierCSet[i] + "\n");
            }
            
        }
        

//        colorTopLevel(dynamicGraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
//        layout.setGraph(dynamicGraph);
//        System.out.println("\nDynamic Graph: ");
//        for (Object v : dynamicGraph.getVertices()) {
//            if (v instanceof Graph) {
//                System.out.println("Vertex: " + ((Graph) v).getVertices());
//            } else {
//                System.out.println("Vertex: " + v);
//            }
//        }
//        System.out.println(hierCSet[0]);
        if (isTopLevel) {
            int numSingle = 0;
            int numClustSizeMore1 = 0;
            double avgClustSize = 0;
            int biggestClustSize = -1;
            int sumClustSize = 0;

            /* calculate some stats */
//        for (int ind = 0; ind < cSet.size(); ind++){
            for (Set<Object> set : cSet) {
//            Set<Number> = cSet.
//            Set set = cSet.getCluster(ind);
                int size = set.size();
                if (size == 1) {
                    numSingle++;
                } else {
                    numClustSizeMore1++;
                }
                if (size > biggestClustSize) {
                    biggestClustSize = size;
                }
                sumClustSize += size;
            }

            avgClustSize = (double) sumClustSize / cSet.size();
            double percSingle = (double) numSingle / g.getVertexCount();
            double percBiggest = (double) biggestClustSize / g.getVertexCount();
            System.out.println("Single node num: " + numSingle + " percent: " + percSingle);
            System.out.println("No. cluster size > 1: " + numClustSizeMore1);
            System.out.println("Avg. cluster size: " + avgClustSize);
            System.out.println("Biggest cluster size: " + biggestClustSize + " percent: " + (percBiggest * 100));
//        try {
//            obosession = GOProcessor.getSession("gene_ontology.1_2.obo");
//        } catch (OBOParseException ex) {
//            Logger.getLogger(LouvainClustererTest.class.getName()).log(Level.SEVERE, null, ex);
//        }
        }
        numOfLouvainClusters = cSet.size();

//        GOTermScoreMap = GOProcessor.populateGOTerms(cSet);
        if (doOnAllNodesInCanVas) {
            curCSetBeforeVisClust = cSet;
            curComNodeCSetBeforeVisClust = comNodeCSet;
        } else {
            curCSetCentered = cSet;
            curComNodeCSetCentered = comNodeCSet;
        }
        GOProcessor gp = new GOProcessor();
        StopWatch sw = new StopWatch();
        sw.start();
        gp.populateGOTerms(cSet);
        sw.stop();
        System.out.println("Populate GO Terms Time Used "+sw);
//        int thresh = 12;
        if (cSet.size() >= Integer.parseInt(thresholdTextField.getText())){
            System.out.println("Start Semantic Clustering!");
            semanticClusterList = gp.preCluster(comNodeClustToFlatClust,comNodeCSet,cSet,Integer.parseInt(thresholdTextField.getText()));
            cSet = transformDataClusterList(semanticClusterList,isTopLevel,doOnAllNodesInCanVas);
            System.out.println("End Semantic Clustering!");
        } else {
            putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(cSet));
        }
//        dynamicGraph = createGraphFromCSet(cSet);
        
        if (doOnAllNodesInCanVas) {
            curGOP = gp;
            System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
        } else {
            curGOPCentered = gp;
        }
        
        System.out.println("cSet: "+cSet.size());
//        Graph newgraph = createGraphFromCSet(cSet);
        if (doOnAllNodesInCanVas) {
            dynamicGraph = createGraphFromCSet(cSet);
//        colorTopLevel(dynamicGraph);
            colorCluster(cSet, mainColor);
//        layout.setSize(new Dimension(100,100));
//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
            Animator animator = new Animator(lt);
            animator.start();

            layout.setGraph(dynamicGraph);
            currentLevelGraph = dynamicGraph;
//        layout.setGraph(newgraph);
            vv.repaint();
        }
        
//        GOProcessor.createClusterCommonGOSet(cSet);
        return cSet;
//        return hierCSet[0];
    }
    
    private GOProcessor curGOP = null;
    private GOProcessor curGOPCentered = null;
    private Set<Set> curCSetCentered = null;
    private Set<Set> curComNodeCSetCentered = null;
    private Set<Set> curCSet = null;
    private Set<Set> curCSetBeforeVisClust = null;
    private Set<Set> curComNodeCSet = null;
    private Set<Set> curComNodeCSetBeforeVisClust = null;
    private ArrayList historyCSetList = new ArrayList<Set<Set<Object>>>();
    private ArrayList historyComNodeCSetList = new ArrayList<Set<Set<Object>>>();
    private ArrayList<GOProcessor> historyGOProcessors = new ArrayList<GOProcessor>();
    
    public Graph createGraphFromCSet(Set<Set> cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        Map<BioObject,Set<Object>> nodeToClusterMap = new HashMap<BioObject, Set<Object>>();
        StopWatch sw = new StopWatch();
        Map<Pair,MetaEdge> newEdgeMap = new HashMap<Pair,MetaEdge>();
        
        Set[] cSetArr = cSet.toArray(new Set[1]);
        for (Set cluster : cSet){
            newgraph.addVertex(cluster);
        }
        for (int i = 0; i < cSetArr.length; i++){
//        for (Set cluster : cSet){
//            if (!newgraph.containsVertex(cSetArr[i]))
//                newgraph.addVertex(cSetArr[i]);
            /* calculate semantic edge between cluster */
//            for (Set cluster2 : cSet){
            for (int j = i+1; j < cSetArr.length; j++){
//                if (cluster == cluster2){
//                    continue;
//                }
                Object edge = newgraph.findEdge(cSetArr[i], cSetArr[j]);
                if (edge == null){           
                    edge = new SemanticEdge(cSetArr[i]+"<->"+cSetArr[j], nodesGOVectorMap.get(cSetArr[i]), nodesGOVectorMap.get(cSetArr[j]));
//                    if (!newgraph.containsVertex(cluster2)){
//                        newgraph.addVertex(cluster2);
//                    }
                    newgraph.addEdge(edge, cSetArr[i],cSetArr[j]);
//                    System.out.println("Edge : "+edge);
                } else if (!(edge instanceof SemanticEdge))
                    System.out.println("What 's edge!!!");
//                Pair newPair = new Pair(cSetArr[i],cSetArr[j]); 
//                MetaEdge tmpEdge = new MetaEdge(cSetArr[i]+":"+cSetArr[j]);
//                newEdgeMap.put(newPair, tmpEdge);
            }
            for (Object obj : cSetArr[i]){
                nodeToClusterMap.put((BioObject) obj,cSetArr[i]);
            }
        }
                
        sw.start();
//        Set newEdgeSet = new HashSet();
        
        
        /* Cluster-centered implementation edge creation, slow because of O(v^2) */
//        Set[] cSetArr = cSet.toArray(new Set[1]);
//        for (int i = 0; i < cSetArr.length; i++){
//            for (int j = i+1; j < cSetArr.length; j++){
//                Pair newPair = new Pair(cSetArr[i],cSetArr[j]); 
//                MetaEdge tmpEdge = new MetaEdge(cSetArr[i]+":"+cSetArr[j]);
//                newEdgeMap.put(newPair, tmpEdge);
//                
//                for (Object obj : cSetArr[i]){
////                    BioObject bioObj1 = (BioObject)obj;
//                    for (Object obj2 : cSetArr[j]){
//                       
////                        BioObject bioObj2 = (BioObject)obj;
//                        Collection edgeSet = originalGraph.findEdgeSet(obj, obj2);
//                        
//                        if (edgeSet.size() > 0){
//                            Object edge = edgeSet.iterator().next();
//                            tmpEdge.addEdge(edge);
//                        } else {
//                            continue;
//                        }
//                    }
//                }
//                if (tmpEdge.getNumEdgeSetBundled() == 0)
//                {
//                    newEdgeMap.remove(newPair);
//                }
//            }
//        }

        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
//            BioObject firstVer = (BioObject)pair.getFirst();
//            BioObject secondVer = (BioObject)pair.getSecond();
            Set clusterFirst = nodeToClusterMap.get(pair.getFirst());
            Set clusterSecond = nodeToClusterMap.get(pair.getSecond());
            
            if (clusterFirst == null || clusterSecond == null)
                continue;
            if (clusterFirst == clusterSecond)
                continue;
            
            Pair newPair = new Pair(clusterFirst,clusterSecond);
            Object tmpEdge = newEdgeMap.get(newPair);
            if (tmpEdge == null)
            {
                newPair = new Pair(clusterSecond,clusterFirst);
                tmpEdge = newEdgeMap.get(newPair);
                if (tmpEdge == null){
                    newEdgeMap.put(newPair, new MetaEdge(clusterFirst+":"+clusterSecond, edge));
                }
            } else {
                ((MetaEdge)tmpEdge).addEdge(edge);
            }
            
            
            
//            Collection edgeSet = newgraph.findEdgeSet(clusterFirst,clusterSecond);
//            
//            if ((edgeSet.size() == 0) || ((edgeSet.size() == 1) && (edgeSet.iterator().next() instanceof SemanticEdge))){
//                HashSet set = new HashSet(); set.add(edge);
//                MetaEdge metaedge = new MetaEdge(clusterFirst+":"+clusterSecond, set);
//                newgraph.addEdge(metaedge, clusterFirst, clusterSecond);
//            } else {
//                Iterator it = edgeSet.iterator();
//                Object alreadyEdge = it.next();
//                if (alreadyEdge instanceof SemanticEdge)
//                    alreadyEdge = it.next();
//                MetaEdge metaedge = (MetaEdge) alreadyEdge;
//                metaedge.addEdge(edge);
//            }
        
           
//            if (alreadyEdge == null){
//                HashSet set = new HashSet(); set.add(edge);
//                MetaEdge metaedge = new MetaEdge(nodeToClusterMap.get(firstVer)+":"+nodeToClusterMap.get(secondVer), set);
//                newgraph.addEdge(metaedge, nodeToClusterMap.get(firstVer),nodeToClusterMap.get(secondVer));
//            } else if (!(alreadyEdge instanceof SemanticEdge)){
//                MetaEdge metaedge = (MetaEdge) alreadyEdge;
//                metaedge.addEdge(edge);
//            }
        }
        for (Pair key : newEdgeMap.keySet()){
//            System.out.println(newEdgeMap.get(key) instanceof MetaEdge);
//            System.out.println(newgraph.findEdgeSet(key.getFirst(), key.getSecond()));
//            if (!newgraph.containsEdge(newEdgeMap.get(key)))
            if (newEdgeMap.get(key).getNumEdgeSetBundled() > 0)
                newgraph.addEdge(newEdgeMap.get(key),key.getFirst(),key.getSecond());
        }
        sw.stop();
        System.out.println("Time for edge set: "+sw);
//        for (Set<Object> cluster : cSet){
//            for (Object obj : cluster){
//                BioObject bio = (BioObject) obj;
//                originalGraph.getNeighbors(bio);
//            }
//        }
        
        
        return newgraph;
    }
    public Graph createGraphFromBioNodeSet(Set cSet){
        Graph<Object, Object> newgraph = new SparseMultigraph<Object, Object>();
        Map<BioObject,BioObject> nodeToClusterMap = new HashMap<BioObject, BioObject>();
        for (Object obj : cSet){
            newgraph.addVertex(obj);
            
//            for (Object obj : cluster){
            nodeToClusterMap.put((BioObject) obj,(BioObject) obj);
//            }
        }
        for (Object edge : originalGraph.getEdges()){
            Pair pair = originalGraph.getEndpoints(edge);
            BioObject firstVer = (BioObject)pair.getFirst();
            BioObject secondVer = (BioObject)pair.getSecond();
            if (nodeToClusterMap.get(firstVer) == null || nodeToClusterMap.get(secondVer) == null)
                continue;
            if (nodeToClusterMap.get(firstVer) == nodeToClusterMap.get(secondVer))
                continue;
            
            newgraph.addEdge(edge, pair);
            
        }
//        for (Set<Object> cluster : cSet){
//            for (Object obj : cluster){
//                BioObject bio = (BioObject) obj;
//                originalGraph.getNeighbors(bio);
//            }
//        }
        
        
        return newgraph;
    }
    OBOSession obosession = null;
    public int numOfLouvainClusters = 0;
    DataVector centroid = new DataVector();
    
    
//    public void findCentroid(){
//        System.out.println("Num of Louvain Clusters: "+numOfLouvainClusters);
//        Map<String,Double> valMap = new TreeMap<String,Double>();
//        for (DataCluster dc : semanticClusterList){
//                        
//            for (DataVector member : dc.getMembers()){
////                System.out.println("member: "+member);
////                for (int j = 0; j < member.dimValueList.length; j++) {
//                for (String key : member.getValueMap().keySet()) {
////                    int index = nameArrList.indexOf(member.dimNameList[j]);
////                    int index = nameArrList.indexOf(key);
////                    if (index == -1){
//                    if (!valMap.containsKey(key)){
////                        nameArrList.add(member.dimNameList[j]);
////                        zigmaList.add((double)member.dimValueList[j]/clusterList[i].members.size());
//                        valMap.put(key, (double)member.getValueMap().get(key)/numOfLouvainClusters);
//                    } else {
//                        valMap.put(key, valMap.get(key)+(double)member.getValueMap().get(key)/numOfLouvainClusters);
////                        zigmaList.set(index,zigmaList.get(index)+(double)member.dimValueList[j]/clusterList[i].members.size());
//                    }
////                    zigmaList[j] += (double)member.dimValueList[j]/clusterList[i].members.size();
//                }
//                
//            }
//            
//        }
//        centroid = new MeanVector(valMap);
//    }
//    Set<Graph> debugSet = new HashSet<Graph>();
    /** 
     * put obtained nodesGoVectorMap into the global one.
     * GO Vector to be put will be subtracted from the local centroid of the data set
     * @param localNodesGOVectorMap
     */
    public void putInNodesGOVectorMapRelatively(Map<Object,DataVector> localNodesGOVectorMap){
        int allNumMember = 0;
       
        DataCluster dc = new DataCluster();
        dc.addAll(localNodesGOVectorMap.values());
        allNumMember = dc.getMembers().size();
//        for (DataVector dv: dc.getMembers()){
//            allNumMember += ((Set)dv.nodeRef).size();
//        }
        System.out.println("putInNodesGOVectorMap all num member "+allNumMember);
        DataVector localCentroid = DataCluster.findCentroidFromDCList(new DataCluster[]{dc},allNumMember);
        
        for (DataVector dv: dc.getMembers()){
            DataVector resultVector = DataVector.minusVector(dv, localCentroid);
            nodesGOVectorMap.put(dv.nodeRef, resultVector);
        }

    }
    public Set<Set> transformDataClusterList(DataCluster[] dcList,boolean topLevel,boolean doOnAllNodesInCanvas){
        
//        Set<Set<Number>> cSet = new VertexClusterSet(g);
        Set<Set> cSet = new HashSet<Set>();
        Set<Set> comNodeCSet = new HashSet<Set>();
        Set cluster = new HashSet();
        Set clusterComNode = new HashSet();
//        Set<Graph> tmpSet = new HashSet<Graph>();
        int sumOfAllMembers = 0;
        for (DataCluster dc : dcList){
                sumOfAllMembers += dc.getMembers().size();
        }
        
//        System.out.println("sum of all: "+sumOfAllMembers);
//        System.out.println("num of louvain "+numOfLouvainClusters);
//        centroid = DataCluster.findCentroidFromDCList(dcList,numOfLouvainClusters);
        centroid = DataCluster.findCentroidFromDCList(dcList,sumOfAllMembers);
//        findCentroid();
        for (int i = 0; i < dcList.length; i++){
            DataCluster dc = dcList[i];
            if (dc.getMembers().size() == 0){
                System.out.println("Found zero member cluster!!!!!!");
                continue;
            }
            DataVector[] dvList = dc.getMembers().toArray(new DataVector[1]);
            cluster = new HashSet();
            clusterComNode = new HashSet();
            for (DataVector dv :dvList) {
//                System.out.println(dv);

                //nodeRef points to a cluster (set of set) not a real metanode in the graph
                if (dv.nodeRef instanceof Set){
                    cluster.addAll((Set)dv.nodeRef);
                } else // nodeRef is BioObject
                {
                    cluster.add(dv.nodeRef);
                }
                clusterComNode.add(dv.comNodeClusterRef);


            }
//            nodeToDataCluster.put(cluster, dc);
            flatClustToComNodeClust.put(cluster, clusterComNode);
            comNodeClustToFlatClust.put(clusterComNode,cluster);
            cSet.add(cluster);
            comNodeCSet.add(clusterComNode);
            
            /* for graph collapser previously used */
//            ArrayList toPreCollapse = new ArrayList(clusterComNode.size());
//            toPreCollapse.addAll(clusterComNode);
//            dynamicGraph = preCollapse(dynamicGraph, toPreCollapse);
//            ArrayList listComNodeInGraph = new ArrayList();
//            Set toCollapseNode = new HashSet();
//            for (Object v : toPreCollapse) {
////            System.out.println("V: "+ v);
//                Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
////            System.out.println("comNodeInGraph: "+comNodeInGraph);
////                listComNodeInGraph.add(comNodeInGraph);
//                toCollapseNode.add(comNodeInGraph);
//            }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
//            toCollapseNode.addAll(listComNodeInGraph);
//            Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
//            tmpSet.add(clusterGraph);
            DataVector resultVector = DataVector.minusVector(dc.getRepresentative(), centroid);
            nodesGOVectorMap.put(cluster, resultVector);
//            nodesGOVectorMap.put(clusterGraph, resultVector);
//            debugSet.add(clusterGraph);
//        System.out.println(clusterGraph);
//            dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);
        }
        
        if (topLevel){
            //extend capacity and copy the contents for hierCSet and ComNodeHierSet
            Set<Set>[] tmpHierCSet = new HashSet[hierCSet.length + 1];
            for (int i = 0; i < hierCSet.length; i++) {
                tmpHierCSet[i] = hierCSet[i];
            }
            tmpHierCSet[hierCSet.length - 1] = cSet;
            hierCSet = tmpHierCSet;

            tmpHierCSet = new HashSet[comNodehierSet.length + 1];
            for (int i = 0; i < comNodehierSet.length; i++) {
                tmpHierCSet[i] = comNodehierSet[i];
            }
            tmpHierCSet[comNodehierSet.length - 1] = comNodeCSet;
            comNodehierSet = tmpHierCSet;
            System.out.println("\ncomNodehierSet " + (comNodehierSet.length-2) + ": " + comNodehierSet[comNodehierSet.length-2] + "\n");
            System.out.println("\nhierCSet " + (hierCSet.length-2) + ": " + hierCSet[hierCSet.length-2] + "\n");
        }
        if (doOnAllNodesInCanvas) {
            curComNodeCSet = comNodeCSet;
            curCSet = cSet;
        } else {
            curComNodeCSetCentered = comNodeCSet;
            curCSetCentered = cSet;
        }
        
        
        cSetToComNodeCSet.put(cSet, comNodeCSet);
        
//        System.out.println("comNodeHierSet.length-1 "+(comNodehierSet.length-1));
        for (Set set : cSet){
            System.out.println("cluster with size "+set.size());
        }
//        for (Graph set : tmpSet){
//            System.out.println("cluster with size "+set.getVertexCount());
//        }
//        processGOLabel();
        
        return cSet;
        
    }
    
    DataCluster[] semanticClusterList = new DataCluster[1];
    Map <Object,DataVector> nodesGOVectorMap = new HashMap<Object, DataVector>();
//    private Map<Object, Map<GOTerm, Double>> GOTermScoreMap = new HashMap<Object, Map<GOTerm, Double>>();
//    private void createClusterCommonGOSet(Set<Set<Object>> cSet){
//        System.out.println("\nCalculate GO Stat\n");
//        for(Set<Object> cluster : cSet){
//            Set commonGOId = new HashSet();
//            int i = 0;
//            String name = "";
//            for (Object node : cluster)
//            {
//                BioObject bioNode = (BioObject)node;
//                if (i == 0){
//                    commonGOId.addAll(bioNode.getGoIdList());
//                    name = bioNode.toString();
//                }
//                else
//                    commonGOId.retainAll(bioNode.getGoIdList());
//                i++;
//            }
//            System.out.println("Num Common GO Id for cluster of "+name+" with size "+cluster.size()+": "+commonGOId.size()+" List: "+commonGOId);
//        }
//    }
    /** 
     * Unused now, old updateMetaEdges method used to update meta edges for 
     * the graph created by JUNG's GraphCollapser
     * @param graph
     * @return
     */
    private Graph updateMetaEdges(Graph graph) {
//        realGraph = graph;
        dynamicGraph = graph;
        graph = SparseMultigraph.getFactory().create();
//        for (Object v : realGraph.getVertices()) {
        for (Object v : dynamicGraph.getVertices()) {
            graph.addVertex(v);
        }
//        Collection allEdge = realGraph.getEdges();
        Collection allEdge = dynamicGraph.getEdges();
//        System.out.println("All edges: "+allEdge);
        ArrayList allEdgeList = new ArrayList(allEdge);
//        allEdgeSet.addAll(allEdge);
        while (allEdgeList.size() > 0) {
            Object e = allEdgeList.get(0);
//            Pair p = realGraph.getEndpoints(e);
            Pair p = dynamicGraph.getEndpoints(e);
            Object first = p.getFirst(), second = p.getSecond();
//            Collection edgeSet = realGraph.findEdgeSet(first, second);
            Collection edgeSet = dynamicGraph.findEdgeSet(first, second);
//            System.out.println("Edge set: "+edgeSet);
            Set set = new HashSet();
            set.addAll(edgeSet);
            MetaEdge me = new MetaEdge(edgeSet.toString(), set);
            graph.addEdge(me, p);
//            System.out.println("Pair: "+p);
//            System.out.println("First: "+first);
//            System.out.println("Second: "+second);
//            System.out.println("Meta edges: "+me);
            allEdgeList.removeAll(edgeSet);
//            System.out.println("me first"+realGraph.getEndpoints(me).getFirst());
        }
        return graph;
//        System.out.println("All edges: "+allEdge);

    }
    
    public class NumMemberGOTips<V,E>
    	implements Transformer<V,String> {
        
        public String transform(V vertex) {
            String res = "<html>";
            
            if (vertex instanceof Graph){
                res += "Num Nodes Inside: "+findNoMemInHier(vertex);
                DataVector vec = nodesGOVectorMap.get(vertex);
                if (vec == null) {
                    Graph vert = (Graph) vertex;
                    for (Object ver : nodesGOVectorMap.keySet()) {
                        if (ver instanceof Graph) {
                            Graph vv = (Graph) ver;
//                            Set verSet = new HashSet(vv.getVertices());
                            Object rest = findVertex(vv, vert);
                            if (rest != null) {
//                                System.out.println("rest : " + vv);
                                vec = nodesGOVectorMap.get(ver);
                                break;
                            }
                        }
                    }
                }
                if (vec != null){
                
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
                        res += "<p>" + entry.getKey() + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            } else if (vertex instanceof Set){
                res += "Num Nodes Inside: "+((Set)vertex).size();
                DataVector vec = nodesGOVectorMap.get(vertex);
                
                if (vec != null){
                
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
                        res += "<p>" + entry.getKey() + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            } else if (vertex instanceof BioObject){
                
                DataVector vec = nodesGOVectorMap.get(vertex);
                if (vec != null) {
                    
                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
//                                IdentifiedObject obj = obosession.getObject((String)entry.getKey());
//                                res += "<p>" + entry.getKey() + " with " + entry.getValue();
//                                String toPrint = obj.getName();
                        String toPrint = GOProcessor.goTermsMap.get((String) entry.getKey()).getName();
                        if (toPrint.length() > 20) {
                            toPrint = toPrint.substring(0, 20);
                            toPrint += "...";
                        }
//                                if (i > 1)
//                                    res += "";
                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());

                        res += "<p>" + toPrint + " (" + output + ")";
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
//                    res += "</center>";
                } else {

                    BioObject bio = (BioObject) vertex;
                    ArrayList<String> goidList = bio.getGoIdList();
                    int i = 0;
                    for (String s : goidList) {
                        res += "<p>" + s;// + " with " + String.format("%.3f", entry.getValue());
                        i++;
                        if (i == 5) {
                            break;
                        }
                    }
                }
            }
            res += "</html>";
            return res;
        }
    }
    private class TextFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("txt")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Just text file";
        }
    }
    private class MNetFileFilter extends FileFilter {

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String ext = null;
            String s = f.getName();
            int i = s.lastIndexOf('.');

            if (i > 0 && i < s.length() - 1) {
                ext = s.substring(i + 1).toLowerCase();
            }

            if (ext != null) {
                if (ext.equals("mnet")) {
                    return true;
                } else {
                    return false;
                }
            }

            return false;
        }

        @Override
        public String getDescription() {
            return "Modified .net Pajek file";
        }
    }

//    private static int numMemberInClusteredGraph(Object v){
//        int numMember = 0;
//        Graph g = (Graph) v;
//        for (Object ver : g.getVertices()){
//           if (ver instanceof Graph) 
//               numMember += numMemberInClusteredGraph(ver);
//           else
//               numMember += 1;
//        }
//        
//        return numMember;
//    }
    private final class EdgeDisplayPredicate<V, E>
            implements Predicate<Context<Graph<V, E>, E>> //extends AbstractGraphPredicate<V,E>
    {
        private double thresholdForSE = .1;

        private boolean isLowestLevel = false;

        public void setLowestLevel(boolean value) {
            isLowestLevel = value;
        }
        
        public double getThresholdForSE() {
            return thresholdForSE;
        }

        public void setThresholdForSE(double thresholdForSE) {
            this.thresholdForSE = thresholdForSE;
        }
        
        public boolean evaluate(Context<Graph<V, E>, E> context) {
//            Graph<V, E> graph = context.graph;
            E e = context.element;
            if ((e instanceof MetaEdge) || (isLowestLevel)) {
                return true;
            }
            if (e instanceof SemanticEdge){
                if (((SemanticEdge)e).getInnerProduct() >= thresholdForSE)
                    return true;
            }
                
            return false;
//            if (realGraph.getEdgeType(e) == EdgeType.DIRECTED && show_d) {
//                return true;
//            }
//            if (realGraph.getEdgeType(e) == EdgeType.UNDIRECTED && show_u) {
//                return true;
//            }
//            return false;
        }
    }

    private final class EdgeLabeller<E> implements Transformer<E, String> {

        protected EdgeWeightLabeller edge_weight;

        public EdgeLabeller(EdgeWeightLabeller edgeWeight) {
            this.edge_weight = edgeWeight;
        }

        public String transform(E e) {
            double value = 1;
            if (e instanceof MetaEdge) //                return (((MetaEdge)e).edgeSetBundled).toString();
            {
                value = ((MetaEdge) e).numEdgeSetBundled;
            } else if (e instanceof SemanticEdge){
                value = ((SemanticEdge)e).getInnerProduct();
                return ""+ String.format("%.3f",value);
            } else {
                value = edge_weight.getWeight(e);
//                return Integer.toString(edge_weight.getWeight(e));
            }
            if (value > 1) {
                return "" + String.format("%d", (int)value);
            } else {
                return "";
            }
        }
    }

    private final class EdgeWeightStrokeFunction<E>
            implements Transformer<E, Stroke> {
        float [] Dashes = {10.0F, 3.0F, 3.0F, 3.0F};
        protected final Stroke basic = new BasicStroke(1);
        protected final Stroke heavy = new BasicStroke(3);
        protected final Stroke heavy2 = new BasicStroke(6);
        
        protected final Stroke sBasic = new BasicStroke (1.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy =  new BasicStroke (3.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);
        protected final Stroke sHeavy2 = new BasicStroke (6.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0F, Dashes, 0.F);;
        
//        protected static final Stroke heavy = new BasicStroke();
        protected final Stroke dotted = RenderContext.DOTTED;//        protected boolean weighted = false;
//        protected Map<E,Number> edge_weight;
        protected EdgeWeightLabeller edge_weight;
        protected Graph graph;

//        public EdgeWeightStrokeFunction(Map<E,Number> edge_weight)
        public EdgeWeightStrokeFunction(EdgeWeightLabeller edge_weight) {
            this.edge_weight = edge_weight;
//            this.graph = graph;   
        }

//        public void setWeighted(boolean weighted)
//        {
//            this.weighted = weighted;
//        }
        public Stroke transform(E e) {
//            if (weighted)
//            {
//             double value = edge_weight.get(e).doubleValue();
            double value;
            if (e instanceof MetaEdge) {
                value = ((MetaEdge) e).getNumEdgeSetBundled();
                if (value > 7) {
                    return heavy2;
                } else if (value > 3) {
                    return heavy;
                } else {
                    return basic;
                }
            } else if (e instanceof SemanticEdge) {
                value = ((SemanticEdge) e).getInnerProduct();
                if (value > 0.8) {
                    return sHeavy2;
                } else if (value > 0.3) {
                    return sHeavy;
                } else {
                    return sBasic;
                }
            } else {
                value = edge_weight.getWeight(e);
                if (value > 7) {
                    return heavy;
                } else if (value > 3) {
                    return new BasicStroke(3);
                } else {
                    return basic;
                }
                
            }
            
//            }
//            else
//                return basic;
            
        }//        protected boolean drawHeavy(E e)
//        {
//            double value = edge_weight.get(e).doubleValue();
//            if (value > 0.7)
//                return true;
//            else if (value > 5)
//
//                return false;
//        }
    }
    private void zoomInAction(){
        
        Set pickedSet = vv.getPickedVertexState().getPicked();
        System.out.println("pickedSet size: "+pickedSet.size());
        int countBioObjSet = 0;
        Set setOfcomNodeCSet = new HashSet();
        if (pickedSet.size() != 0){
            /* check if the vertex is the set (of set or of BioObject) */
            if (pickedSet.iterator().next() instanceof Set) {
                boolean lastLevel = false;
                historyCSetList.add(curCSetBeforeVisClust); historyComNodeCSetList.add(curComNodeCSetBeforeVisClust);
                historyGOProcessors.add(curGOP);
                System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
                zoomOutButton.setEnabled(true);
                Set set = new HashSet();
                Set comNodeSet = new HashSet();
                for (Object ver : pickedSet) {
                    Set vertex = (Set) ver;
                    System.out.println("\nVertex: "+vertex);
                    System.out.println("\nVertex size: "+vertex.size());
                    
                    /* consider the case when mixing clusters together later */ 
                    curComNodeCSet = flatClustToComNodeClust.get(vertex);
//                            BioObject bioObj = (BioObject)((Set)vertex).iterator().next();
//                            System.out.println("bioObj "+bioObj);

                    System.out.println("curComNodeCSet: " + curComNodeCSet);
                    
                    /* to be considered later */
                    while ((curComNodeCSet.size() == 1) && (curComNodeCSet.iterator().next() instanceof Set)) {
                        /* for [[A,B]] set, it will terminate immediately and do not run in this loop */
                        Set tmpSet = curComNodeCSet.iterator().next();
                        if ((tmpSet.iterator().next() instanceof BioObject)){
                            countBioObjSet++;
                            break;
                        }
                        curComNodeCSet = tmpSet;
//                        tmpSet = curComNodeCSet.iterator().next();
                        System.out.println("curComNodeCSet: " + curComNodeCSet);
//                        if (tmpSet.iterator().next() instanceof BioObject) {
//                            countBioObjSet++;
//                            break;
//                        }
                    }
                    setOfcomNodeCSet.add(curComNodeCSet);
                }
                /* if not all pickedSet vertex contains BioObject directly,
                 *  Just treat them as normal set
                 * Set of one member containing BioObject is also treated normally.
                 * I will not extract a member of such sets anymore
                 */
                if (countBioObjSet != pickedSet.size()) {
                    for (Object object : setOfcomNodeCSet) {
                        Set comNodeCSet = (Set) object;
                        Iterator it = comNodeCSet.iterator();
//                            for (Object obj : curComNodeCSet)
                        for (; it.hasNext();) {
                            Object obj = it.next();
                            System.out.println("Obj " + obj);
                            /* may not be used, need to be confirmed */
                            if (obj instanceof BioObject) {
//                                    Set tmpSet = new HashSet(); tmpSet.add(obj);
//                                    set.add(tmpSet);
                                set.add(obj);
                                lastLevel = true;
                            } else {

                                if (comNodeClustToFlatClust.get(obj) != null) {
                                    System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
                                }
                                set.add(comNodeClustToFlatClust.get(obj));
//                            System.out.println("vertex size "+comNodeClustToFlatClust.get(obj).size());
                            }

                        }
                        comNodeSet.addAll(comNodeCSet);
//                    System.out.println("cur Set: " + set);
//                    System.out.println("cur Set size: " + set.size());
                    }
                }
                /* Extract BioObjects of each set and mix them together to get one larger set
                 */
                else {
                    for (Object object : setOfcomNodeCSet) {
                        Set comNodeCSet = (Set) object;
                        /* assume that there is only one member (set of bioObj)*/
                        lastLevel = true;
                        Set setOfBioObj = (Set)comNodeCSet.iterator().next();
                        Iterator it = setOfBioObj.iterator();
//                            for (Object obj : curComNodeCSet)
                       
                        for (; it.hasNext();) {
                            Object obj = it.next();
                            
                            System.out.println("Obj " + obj);
                            
                            if (obj instanceof BioObject) {
//                                    Set tmpSet = new HashSet(); tmpSet.add(obj);
//                                    set.add(tmpSet);
                                set.add(obj);
                                
                            } 
                            /* may not be used, need to be confirmed */
                            else {

                                if (comNodeClustToFlatClust.get(obj) != null) {
                                    System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
                                }
                                set.add(comNodeClustToFlatClust.get(obj));
//                            System.out.println("vertex size "+comNodeClustToFlatClust.get(obj).size());
                            }

                        }
                        comNodeSet.addAll(setOfBioObj);
//                    System.out.println("cur Set: " + set);
//                    System.out.println("cur Set size: " + set.size());
                    }
                }
                curCSet = set;
                curComNodeCSet = comNodeSet;
//                System.out.println("curCSet: " + curCSet);
//                System.out.println("curCSet size: "+curCSet.size());
//                int num = 0;
//                for (Set s : curCSet){
//                    System.out.println("vertex size: "+s.size());
//                    num += s.size();
//                }
//                System.out.println("Size: "+num);


                layout.initialize();

                Relaxer relaxer = new VisRunner((IterativeContext) layout);
                relaxer.stop();
                relaxer.prerelax();

//                if (!lastLevel) {
//                    GOProcessor gp = new GOProcessor();
//                    gp.populateGOTerms(curCSet);
//                    
//                    curCSetBeforeVisClust = curCSet;
//                    curComNodeCSetBeforeVisClust = curComNodeCSet;
//                    curGOP = gp;
//                    System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
//                    if (curCSet.size() > Integer.parseInt(thresholdTextField.getText())) {
//                        semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSet, curCSet, Integer.parseInt(thresholdTextField.getText()));
//                        curCSet = transformDataClusterList(semanticClusterList, false);
//                    } else {
//                        putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
//                    }
//
//                    dynamicGraph = createGraphFromCSet(curCSet);
//                    colorCluster(curCSet, mainColor);
//                } else {
//                    medp.setLowestLevel(true);
//                    zoomInButton.setEnabled(false);
//                    dynamicGraph = createGraphFromBioNodeSet(curCSet);
//                }
                
                GOProcessor gp = new GOProcessor();
                gp.populateGOTerms(curCSet);
//                            if (!lastLevel){
                                /* In the case which cSet is the set of BioObject, curCSet is the same as curComNodeCSet */
                curCSetBeforeVisClust = curCSet;
                curComNodeCSetBeforeVisClust = curComNodeCSet;
                curGOP = gp;
                System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
//                            }

                if (curCSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
//                          

                    if (!lastLevel) {
                        semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSet, curCSet, Integer.parseInt(thresholdTextField.getText()));
                    } else {
                        semanticClusterList = gp.preCluster(curCSet, Integer.parseInt(thresholdTextField.getText()));
                    }

                    curCSet = transformDataClusterList(semanticClusterList, false,true);
                    System.out.println("cur C Set after seman clust: " + curCSet);

                    dynamicGraph = createGraphFromCSet(curCSet);
                    colorCluster(curCSet, mainColor);



                } else {
                    putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
                    if (lastLevel) {

                        medp.setLowestLevel(true);
                        zoomInButton.setEnabled(false);
                        dynamicGraph = createGraphFromBioNodeSet(curCSet);
                    } else {

                        System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
                        dynamicGraph = createGraphFromCSet(curCSet);
                        colorCluster(curCSet, mainColor);
                    }
                }


                layout.setGraph(dynamicGraph);
                currentLevelGraph = dynamicGraph;
                StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);

//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), layout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                Animator animator = new Animator(lt);
                animator.start();

//        layout.setGraph(newgraph);
                vv.repaint();
                
            }
        }
        
    }
    public class DoubleClickZoomInPlugin<V,E> extends AbstractGraphMousePlugin
        implements MouseListener{
        public DoubleClickZoomInPlugin(){
            this(MouseEvent.BUTTON1_DOWN_MASK);
        }
        public DoubleClickZoomInPlugin(int modifier){
            super(modifier);
        }
        private boolean isContainedIn(BioObject bioObj,Set hierSet){
            boolean isContained = false;
            if (hierSet.contains(bioObj)){
                    return true;
            }
            for (Object obj : hierSet){
                if (obj instanceof Set){
                    
                    
                    isContained |= isContainedIn(bioObj,(Set) obj);   
                }
            }
            return isContained;
        }
        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2 && !e.isConsumed()) {
                e.consume();
                final VisualizationViewer<V,E> vv =
                        (VisualizationViewer<V, E>) e.getSource();
                final Point2D p = e.getPoint();
                GraphElementAccessor<V, E> pickSupport = vv.getPickSupport();
                if (pickSupport != null) {
//                    Graph<V, E> graph = vv.getModel().getGraphLayout().getGraph();
                   
                    
                    
                    final V vertex = pickSupport.getVertex(vv.getModel().getGraphLayout(), p.getX(), p.getY());
                    if (vertex != null){
//                        zoomInAction();
                        zoomOutButton.setEnabled(true);
                        System.out.println("\nVertex: "+vertex);
//                        for (Object ver : vv.getModel().getGraphLayout().getGraph().getVertices()){
//                            System.out.println("flat "+flatClustToComNodeClust.get(ver));
//                        }
                        if (vertex instanceof Set){
                            historyCSetList.add(curCSetBeforeVisClust); historyComNodeCSetList.add(curComNodeCSetBeforeVisClust);
                            historyGOProcessors.add(curGOP);
                            System.out.println("GO Proc size: "+curGOP.clusterScoreMap.size());
                            curComNodeCSet = flatClustToComNodeClust.get(vertex);
//                            BioObject bioObj = (BioObject)((Set)vertex).iterator().next();
//                            System.out.println("bioObj "+bioObj);
                            Set set = new HashSet();
                            
                            System.out.println("curComNodeCSet: "+curComNodeCSet);
                            while ((curComNodeCSet.size() == 1) && (curComNodeCSet.iterator().next() instanceof Set)) {
                                
                                curComNodeCSet = curComNodeCSet.iterator().next();
//                                Set tmpSet = curComNodeCSet.iterator().next();
                                System.out.println("curComNodeCSet: "+curComNodeCSet);
//                                if (tmpSet.iterator().next() instanceof BioObject)
//                                    break;
                            }
                            
//                            if (curComNodeCSet.iterator().next() instanceof BioObject){
//                                System.out.println("BioObject");
//                            } else {
                            Iterator it = curComNodeCSet.iterator();
                            boolean lastLevel = false;
                            for (;it.hasNext();)
//                            for (Object obj : curComNodeCSet)
                            {
                                Object obj = it.next();
                                System.out.println("Obj "+obj);
//                                System.out.println(obj);
//                                Set hierSet = (Set)obj;
                                if (obj instanceof BioObject){
//                                    Set tmpSet = new HashSet(); tmpSet.add(obj);
//                                    set.add(tmpSet);
                                    set.add(obj);
                                    lastLevel = true;
                                } else {
                                
//                                if (isContainedIn(bioObj,hierSet))
//                                    System.out.println("bio obj "+bioObj+" Obj "+hierSet);
                                
                                    if (comNodeClustToFlatClust.get(obj) != null) {
                                        System.out.println("key comnode " + obj + " flat clust: " + comNodeClustToFlatClust.get(obj));
                                    }
                                    set.add(comNodeClustToFlatClust.get(obj));
                                }
//                                else {
//                                    System.out.println("No!");
//                                }
//                                Set tmpSet = null;
                                
//                                for (Entry<Set,Set> entry : flatClustToComNodeClust.entrySet()){
////                                    System.out.println(entry.getValue());
////                                    if (isContainedIn(bioObj, entry.getValue())){
////                                        System.out.println("Entry getvalue (Com Node) "+entry.getValue()+" key (flat clust) "+entry.getKey());
////                                    }
//                                    if (entry.getValue().equals(hierSet)){
////                                    if (((Set)entry.getValue()).containsAll((Set)obj)){
//                                        tmpSet =  entry.getKey();
//                                        break;
//                                    }
//                                }
//                                if (tmpSet != null){
//                                    System.out.println("tmp Set: "+tmpSet);
//                                    set.add(tmpSet);
//                                } else {
////                                    System.out.println("Oh no");
//                                }
//                                System.out.println("");
                            }
                            
                            curCSet = set;
//                            System.out.println(flatClustToComNodeClust.get(vertex));
                            System.out.println("curCSet: " + curCSet);
                            System.out.println("curComNodeSet: "+curComNodeCSet);
                            
                           
                            layout.initialize();

                            Relaxer relaxer = new VisRunner((IterativeContext) layout);
                            relaxer.stop();
                            relaxer.prerelax();
                            
                            GOProcessor gp = new GOProcessor();
                            gp.populateGOTerms(curCSet);
//                            if (!lastLevel){
                                /* In the case which cSet is the set of BioObject, curCSet is the same as curComNodeCSet */
                            curCSetBeforeVisClust = curCSet;
                            curComNodeCSetBeforeVisClust = curComNodeCSet;
                            curGOP = gp;
                            System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
//                            }
                            
                            if (curCSet.size() >= Integer.parseInt(thresholdTextField.getText())) {
//                          
                                
                                if (!lastLevel)
                                    semanticClusterList = gp.preCluster(comNodeClustToFlatClust, curComNodeCSet, curCSet, Integer.parseInt(thresholdTextField.getText()));
                                else{
                                    semanticClusterList = gp.preCluster(curCSet, Integer.parseInt(thresholdTextField.getText()));
                                }
                                    
                                curCSet = transformDataClusterList(semanticClusterList, false,true);
                                System.out.println("cur C Set after seman clust: "+curCSet);
                                
                                dynamicGraph = createGraphFromCSet(curCSet);
                                colorCluster(curCSet, mainColor);
                                
                                
                                
                            } else {
                                putInNodesGOVectorMapRelatively(gp.getNodesGOVectorMapBeforeCluster(curCSet));
                                if (lastLevel) {
                            
                                    medp.setLowestLevel(true);
                                    zoomInButton.setEnabled(false);
                                    dynamicGraph = createGraphFromBioNodeSet(curCSet);
                                } else {
                            
                                    System.out.println("GO Proc size before Vis clust: " + curGOP.clusterScoreMap.size());
                                    dynamicGraph = createGraphFromCSet(curCSet);
                                    colorCluster(curCSet, mainColor);
                                }
                            }


//        colorTopLevel(newgraph);
//        dynamicGraph = updateMetaEdges(dynamicGraph);
//        System.out.println("Dynamic Graph:"+dynamicGraph);
                            
                            layout.setGraph(dynamicGraph);
                            currentLevelGraph = dynamicGraph;
                            StaticLayout<Object, Object> staticLayout = new StaticLayout<Object, Object>(dynamicGraph, layout);
                            
//                    StaticLayout<Object, Object> staticLayoutStart = new StaticLayout<Object, Object>(layout.getGraph(), layout);
                            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), staticLayout);
//                            LayoutTransition<Object, Object> lt = new LayoutTransition(vv, vv.getGraphLayout(), layout);
//                    LayoutTransition<Object, Object> lt = new LayoutTransition<Object, Object>(vv, staticLayoutStart, staticLayout);
//                                    staticLayout);
                            Animator animator = new Animator(lt);
                            animator.start();
                            
//        layout.setGraph(newgraph);
                            vv.repaint();
                            reLouvainCluster(curCSetBeforeVisClust, true);
               
//                        }
                        }
                    }
                }
//                System.out.println(e.getSource());
            }
        }
       
        public void mouseEntered(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(cursor);
        }

        public void mouseExited(MouseEvent e) {
            JComponent c = (JComponent) e.getSource();
            c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }

        public void mouseMoved(MouseEvent e) {
        }

        public void mousePressed(MouseEvent e) {
            
        }

        public void mouseReleased(MouseEvent e) {
           
        }
    }
    public class VertexFontTransformer implements Transformer<Object,Font>{
        
        public Font transform(Object vertex) {
           return new Font("Serif",Font.PLAIN,13);
        }
        
    }
    public class GOStringLabeller extends ToStringLabeller {
        /* (non-Javadoc)
         * @see edu.uci.ics.jung.visualization.decorators.DefaultToolTipFunction#getToolTipText(java.lang.Object)
         */

        @Override
        public String transform(Object v) {
//                    int numMember = 0;
//
//                    if (v instanceof Graph) {
////                        numMember = numMemberInClusteredGraph(v);
//                        numMember = findNoMemInHier(v);
////                        System.out.println("");
////                        System.out.println("Ver: "+v+" Num member: "+numMember);
////                        System.out.println("");
////                        return (int) ((Graph) v).getVertexCount() * 15;
//                        return numMember + " nodes";
////                        return ((Graph) v).getVertices().size()+" nodes";
//                    } else {
//                        return super.transform(v);
//                    }
            String res = "<html><center>";

            if (v instanceof Graph) {

                DataVector vec = nodesGOVectorMap.get(v);
                if (vec == null) {
                    Graph vertex = (Graph) v;
                    for (Object ver : nodesGOVectorMap.keySet()) {
                        if (ver instanceof Graph) {
                            Graph vv = (Graph) ver;
//                            Set verSet = new HashSet(vv.getVertices());
                            Object rest = findVertex(vv, vertex);
                            if (rest != null) {
                                System.out.println("rest : " + vv);
                                vec = nodesGOVectorMap.get(ver);
                                break;
                            }
                        }
                    }
                }


                if (vec != null) {

                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
//                                IdentifiedObject obj = obosession.getObject((String)entry.getKey());
//                                res += "<p>" + entry.getKey() + " with " + entry.getValue();
//                                String toPrint = obj.getName();
                        String toPrint = GOProcessor.goTermsMap.get((String) entry.getKey()).getName();
                        if (toPrint.length() > 20) {
                            toPrint = toPrint.substring(0, 20);
                            toPrint += "...";
                        }
//                                if (i > 1)
//                                    res += "";
                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());

                        res += "<p>" + toPrint + " (" + output + ")";
                        i++;
                        if (i == 3) {
                            break;
                        }
                    }
                    res += "</center></html>";
                } else {
//                            Graph vertex = (Graph) v;
//                            for (Object ver : nodesGOVectorMap.keySet()) {
//                                if (ver instanceof Graph) {
//                                    Graph vv = (Graph) ver;
////                            Set verSet = new HashSet(vv.getVertices());
//                                    Object rest = findVertex(vv, vertex);
//                                    if (rest != null) {
//                                        System.out.println("rest : " + vv);
//                                    }
//                                }
//                            }
//                            System.out.println("");
                    res += "#Nodes: " + findNoMemInHier(v);
                    res += "</html>";
//                            System.out.println("!!!");
                }
            } else if (v instanceof Set) {

                DataVector vec = nodesGOVectorMap.get(v);
//                        if (vec == null){
//                            Graph vertex = (Graph) v;
//                            for (Object ver : nodesGOVectorMap.keySet()) {
//                                if (ver instanceof Graph) {
//                                    Graph vv = (Graph) ver;
////                            Set verSet = new HashSet(vv.getVertices());
//                                    Object rest = findVertex(vv, vertex);
//                                    if (rest != null) {
//                                        System.out.println("rest : " + vv);
//                                        vec = nodesGOVectorMap.get(ver);
//                                        break;
//                                    }
//                                }
//                            }
//                        }


                if (vec != null) {

                    Set<Entry<String, Double>> sortedMap = new TreeSet<Entry<String, Double>>(new Comparator() {

                        public int compare(Object o1, Object o2) {
                            Entry<String, Double> e1 = (Entry<String, Double>) o1;
                            Entry<String, Double> e2 = (Entry<String, Double>) o2;
                            if (e1.getValue() > e2.getValue()) {
                                return -1;
                            } else if (e1.getValue() < e2.getValue()) {
                                return 1;
                            } else {
                                return 0;
//                        throw new UnsupportedOperationException("Not supported yet.");
                            }
                        }
                    });
                    sortedMap.addAll(vec.getValueMap().entrySet());
                    int i = 0;
                    for (Entry entry : sortedMap) {
//                                IdentifiedObject obj = obosession.getObject((String)entry.getKey());
//                                res += "<p>" + entry.getKey() + " with " + entry.getValue();
//                                String toPrint = obj.getName();
                        GOTerm goTerm = GOProcessor.goTermsMap.get((String) entry.getKey());
                        String toPrint = goTerm.getName();
                        
                        if (toPrint.length() > 20) {
                            toPrint = toPrint.substring(0, 20);
                            toPrint += "...";
                        }
//                                if (i > 1)
//                                    res += "";
                        DecimalFormat myFormatter = new DecimalFormat(".00");
                        String output = myFormatter.format(entry.getValue());
                        
                        res += "<p>";
                        if (goTerm.getNamespace().equals(NameSpace.CC))
                            res += "<font color = #ED143F>";
                        else if (goTerm.getNamespace().equals(NameSpace.MF)) 
                            res += "<font color = #338F06>";
                        else 
                            res += "<font color = #3425B1>";
                        res += toPrint + " (" + output + ")";
                        res += "</font>";
                        i++;
                        if (i == 3) {
                            break;
                        }
                    }
                    res += "</center></html>";
                } else {
//                            Graph vertex = (Graph) v;
//                            for (Object ver : nodesGOVectorMap.keySet()) {
//                                if (ver instanceof Graph) {
//                                    Graph vv = (Graph) ver;
////                            Set verSet = new HashSet(vv.getVertices());
//                                    Object rest = findVertex(vv, vertex);
//                                    if (rest != null) {
//                                        System.out.println("rest : " + vv);
//                                    }
//                                }
//                            }
//                            System.out.println("");
                    res += "#Nodes: " + ((Set) v).size();
                    res += "</html>";
//                            System.out.println("!!!");
                }
            } else if (v instanceof BioObject) {
                res += ((BioObject)v).getName();
//                res += "#Nodes: " + findNoMemInHier(v);
                res += "</html>";

            }

            return res;
        }
    }
    private final class VertexShapeSizeAspect<V, E>
            extends AbstractVertexShapeTransformer<V>
            implements Transformer<V, Shape> {

//        protected boolean stretch = false;
//        protected boolean scale = false;
//        protected boolean funny_shapes = false;
//        protected Map<V, Number> voltages;
//        protected Graph<V, E> graph;
//        protected AffineTransform scaleTransform = new AffineTransform();
        public VertexShapeSizeAspect(Graph<V, E> graphIn) {//, Map<V, Number> voltagesIn) {
//            this.graph = graphIn;
//            this.voltages = voltagesIn;
            setSizeTransformer(new Transformer<V, Integer>() {

                public Integer transform(V v) {
//                    if (scale) {
                    int numMember = 0;

                    if (v instanceof Graph) {
                        //                        numMember = numMemberInClusteredGraph(v);
                        numMember = findNoMemInHier(v);
                        if (numMember == 0)
                            return 20;
                        
//                        System.out.println("");
//                        System.out.println("Ver: "+v+" Num member: "+numMember);
//                        System.out.println("");
//                        return (int) ((Graph) v).getVertexCount() * 15;
//                       System.out.println("num mem: "+numMember+" size: "+(Math.log10(numMember)/Math.log10(2)*20));
                        return (int) (Math.log10(numMember) / Math.log10(2) * 20);

                    } else if (v instanceof Set) {
                        
                        numMember = ((Set)v).size();
                        if (numMember == 0)
                            return 20;
                        else if (numMember == 1)
                            return 20;
//                        System.out.println("");
//                        System.out.println("Ver: "+v+" Num member: "+numMember);
//                        System.out.println("");
//                        return (int) ((Graph) v).getVertexCount() * 15;
//                       System.out.println("num mem: "+numMember+" size: "+(Math.log10(numMember)/Math.log10(2)*20));
                        return (int) (Math.log10(numMember) / Math.log10(4) * 20);


                    } else
                    {
                        return 20;
                    }
                }
            });
//            setAspectRatioTransformer(new Transformer<V, Float>() {
//
//                public Float transform(V v) {
//                    if (stretch) {
//                        return (float) (realGraph.inDegree(v) + 1) /
//                                (realGraph.outDegree(v) + 1);
//                    } else {
//                        return 1.0f;
//                    }
//                }
//            });
        }

//        public void setStretching(boolean stretch) {
//            this.stretch = stretch;
//        }

//        public void setScaling(boolean scale) {
//            this.scale = scale;
//        }

//        public void useFunnyShapes(boolean use) {
//            this.funny_shapes = use;
//        }
        public Shape transform(V v) {
//            if (funny_shapes) {
//                if (realGraph.degree(v) < 5) {
//                    int sides = Math.max(realGraph.degree(v), 3);
//                    return factory.getRegularPolygon(v, sides);
//                } else {
//                    return factory.getRegularStar(v, realGraph.degree(v));
//                }
//            } else {
            return factory.getEllipse(v);
//            }
        }
    }

    public class PickedEdgePaintFunction<V, E> implements Transformer<E,Paint>{

        private Transformer<E, Paint> defaultFunc;
//        protected boolean fill_edge = false;
//        Predicate<Context<Graph<V, E>, E>> selfLoop = new SelfLoopEdgePredicate<V, E>();

        public PickedEdgePaintFunction(Transformer<E, Paint> defaultEdgePaintFunction,
                                               VisualizationViewer<V, E> vv) {
//            super(Color.WHITE, Color.BLACK, vv);
            this.defaultFunc = defaultEdgePaintFunction;
        }

//        public void useFill(boolean b) {
//            fill_edge = b;
//        }

        public Paint transform(E e) {
//            if (gradient_level == GRADIENT_NONE) {
            if (e instanceof SemanticEdge)
                return new Color(182,182,182);
            else
                return defaultFunc.transform(e);
//            } else {
//                return super.transform(e);
//            }
        }

//        protected Color getColor2(E e) {
//            return vv.getPickedEdgeState().isPicked(e) ? Color.CYAN : c2;
//        }//        public Paint getFillPaint(E e)
//        {
//            if (selfLoop.evaluateEdge(vv.getGraphLayout().getGraph(), e) || !fill_edge)
//                return null;
//            else
//                return getDrawPaint(e);
//        }
    }

    private final class LayoutChooser implements ActionListener {

        private final JComboBox jcb;
        private final VisualizationViewer<Object, Object> vv;

        private LayoutChooser(JComboBox jcb, VisualizationViewer<Object,Object> vv)
        {
            super();
            this.jcb = jcb;
            this.vv = vv;
        }

        public void actionPerformed(ActionEvent arg0)
        {
            Object[] constructorArgs = {dynamicGraph};

            Class<? extends Layout<Integer,Number>> layoutC = 
                (Class<? extends Layout<Integer,Number>>) jcb.getSelectedItem();
//            Class lay = layoutC;
            try
            {
                Constructor<? extends Layout<Integer, Number>> constructor = layoutC
                        .getConstructor(new Class[] {Graph.class});
                Object o = constructor.newInstance(constructorArgs);
                Layout<Object,Object> l = (Layout<Object,Object>) o;
                l.setInitializer(vv.getGraphLayout());
                l.setSize(vv.getSize());
                
                LayoutTransition<Object, Object> lt =
                        new LayoutTransition<Object, Object>(vv, vv.getGraphLayout(), l);
                Animator animator = new Animator(lt);
                animator.start();
                vv.getModel().setGraphLayout(l);
                
                vv.getRenderContext().getMultiLayerTransformer().setToIdentity();
                vv.repaint();
                
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
    
    
    /*********************
     * Unused zone
     * ********************
     */
    
    /** unused anymore, for the Graph of GraphCollapser
     * 
     * @param v
     * @return
     */
    private int findNoMemInHier(Object v) {
        //assume that v is instance of Graph
//        int num = 0;
        
        int num = hierCSet.length-1-currentLevel;
//        System.out.println("num "+num);
        while (v instanceof Graph) {
            Graph g = (Graph) v;
            v = (Object) g.getVertices().iterator().next();
//            num++;
        }
        // v becomes a vertex 
//        int index = hierCSet.length - 1 - num;
//        System.out.println("\nhierCSet "+ hierCSet[0]);
        int index = num - 1;
        if (index < 0)
            return 0;
//        System.out.println("\nhierCSet "+ hierCSet[index]);
        for (Set verSet : hierCSet[index]) {
            if (verSet.contains( v)) {
//                System.out.println("Ver set: "+verSet);
                return verSet.size();
            }
        }
        return 0;
    }
    /** for old Graph Collapser
     * 
     * @param inGraph
     * @param toBeColl
     * @return
     */
    private Graph collapseNodeSet(Graph inGraph, Set toBeColl) {
//        Graph inGraph = layout.getGraph();
        Graph clusterGraph = collapser.getClusterGraph(inGraph, toBeColl);

//        System.out.println(clusterGraph);
        return collapser.collapse(inGraph, clusterGraph);
//        System.out.println("Vertices:--- " + g.getVertices());
//        System.out.println("Edges:--- " + g.getEdges());
//        double sumx = 0;
//        double sumy = 0;
//        for (Object v : toBeColl) {
//            Point2D p = (Point2D) layout.transform(v);
//            sumx += p.getX();
//            sumy += p.getY();
//        }
//        Point2D cp = new Point2D.Double(sumx / toBeColl.size(), sumy / toBeColl.size());
//        layout.setGraph(g);

//        layout.setLocation(clusterGraph, cp);
//        vertexPaints.put(clusterGraph, similarColors[0]);
//        vv.repaint();
    }
    /**
     * Search in the inGraph for the (meta)vertex which corresponds to the vertex
     * @param inGraph
     * @param vertex
     * @return real vertex in the JUNG Graph corresponding to the vertex
     */
    Object findVertexInClusteredGraph(Graph inGraph, Object vertex) {

        while (vertex instanceof Collection) {
//            System.out.println("Vertex: "+vertex);
            Collection c = (Collection) vertex;
            vertex = c.iterator().next();
        }
//        System.out.println("Final Vertex: "+vertex);
        return findVertex(inGraph, vertex);
    }
    /**
     * find vertex in the given inGraph recursively
     *  
     * @param inGraph
     * @param vertex
     * @return v which contains the vertex
     */
    Object findVertex(Graph inGraph, Object vertex) {
        Collection vertices = inGraph.getVertices();
        if (vertices.contains(vertex)) {
            return vertex;
        }
        for (Object v : vertices) {
            if (v instanceof Graph) {
                Graph g = (Graph) v;
                if (contains(g, vertex)) {
                    return v;
                }
            }
        }
        return null;
    }

    private boolean contains(Graph inGraph, Object vertex) {
        boolean contained = false;
        if (inGraph.getVertices().contains(vertex)) {
            return true;
        }
        for (Object v : inGraph.getVertices()) {
            if (v instanceof Graph) {
                contained |= contains((Graph) v, vertex);
            }
        }
        return contained;
    }
    private void colorTopLevel(Graph graph) {
        int i = 0;
//        System.out.println("comNode: "+comNodehierSet.length);
        /* old version */
//        for (Set set : comNodehierSet[comNodehierSet.length - 2]) {
//            Color c = similarColors[i % similarColors.length];
//
//            vertexPaints.put(findVertexInClusteredGraph(graph, set), c);
//            i++;
//        }
        for (Set set : hierCSet[hierCSet.length - 2]) {
//            Color c = similarColors[i % similarColors.length];
            Color c = mainColor;

            vertexPaints.put(set, c);
            i++;
        }
    }
    private void groupCluster(AggregateLayout<Object, Object> layout, Set<Object> vertices) {

        if (vertices.size() < layout.getGraph().getVertexCount()) {
            Point2D center = layout.transform(vertices.iterator().next());
            Graph<Object, Object> subGraph = SparseMultigraph.<Object, Object>getFactory().create();
            for (Object v : vertices) {
                subGraph.addVertex(v);
            }
            Layout<Object, Object> subLayout =
                    new CircleLayout<Object, Object>(subGraph);
            subLayout.setInitializer(vv.getGraphLayout());
            subLayout.setSize(new Dimension(40, 40));

            layout.put(subLayout, center);
            vv.repaint();
        }
    }
    /** for old GraphCollapser
     * 
     * @param inGraph
     * @param toCollapse
     * @return
     */
    Graph preCollapse(Graph inGraph, ArrayList toCollapse) {
        ArrayList listComNodeInGraph = new ArrayList();
        for (Object v : toCollapse) {
//            System.out.println("V: "+ v);
            Object comNodeInGraph = findVertexInClusteredGraph(inGraph, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
            listComNodeInGraph.add(comNodeInGraph);
        }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
        Set toCollapseNode = new HashSet();
        toCollapseNode.addAll(listComNodeInGraph);
//        System.out.println("toCollapseNode: "+toCollapseNode);
        return collapseNodeSet(inGraph, toCollapseNode);
    }
    /**
     * unused now
     * @param g
     */
    public void processGOLabel(Graph g){
        
        int index = comNodehierSet.length - 1 - currentLevel - 1;
        for (Set clusterOfComNode : comNodehierSet[index]) {
////                    for (int l = 0; l < comNodehierSet[currentLevel-1].size(); l++) {

////                        System.out.println("\nClusterOfComNode: " + clusterOfComNode+"\n");
//                        ArrayList toPreCollapse = new ArrayList();
//                        toPreCollapse.addAll(clusterOfComNode);

            /* Codes below is similarPointToCluster to that of precollapse */
//                        dynamicGraph = LouvainClustererTest.this.preCollapse(dynamicGraph,toPreCollapse);

            ArrayList listComNodeInGraph = new ArrayList();
//                        for (Object v : toPreCollapse) {
            for (Object v : clusterOfComNode) {
//            System.out.println("V: "+ v);
//                Object comNodeInGraph = findVertexInClusteredGraph(dynamicGraph, v);
                Object comNodeInGraph = findVertexInClusteredGraph(g, v);
//            System.out.println("comNodeInGraph: "+comNodeInGraph);
                listComNodeInGraph.add(comNodeInGraph);
            }
//        System.out.println("listComNodeInGraph: "+listComNodeInGraph);
            Set toCollapseNode = new HashSet();
            toCollapseNode.addAll(listComNodeInGraph);
//        System.out.println("toCollapseNode: "+toCollapseNode);


//            Graph clusterGraph = collapser.getClusterGraph(dynamicGraph, toCollapseNode);
            Graph clusterGraph = collapser.getClusterGraph(g, toCollapseNode);
            vertexPaints.put(clusterGraph, (Color) vertexPaints.get(listComNodeInGraph.get(0)));
//        System.out.println(clusterGraph);
//            dynamicGraph = collapser.collapse(dynamicGraph, clusterGraph);
            g = collapser.collapse(g, clusterGraph);

        /* end of copied codes */

//                System.out.println(cluster);

        }
//        dynamicGraph = updateMetaEdges(dynamicGraph);
        g = updateMetaEdges(g);
        dynamicGraph = g;
    }
}

class SemanticEdge extends Object{
    String name = "";

    public double getInnerProduct() {
        return innerProduct;
    }

    public void setInnerProduct(double innerProduct) {
        this.innerProduct = innerProduct;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    DataVector dv1, dv2;
    double innerProduct = 0;
    public SemanticEdge(String name,DataVector dv1, DataVector dv2){
        this.name = name;
        this.dv1 = dv1;
        this.dv2 = dv2;
        innerProduct = KMeanClusterer.similarity(dv1, dv2);
    }
    @Override
    public String toString() {
        return "Inner Product: " + innerProduct;
    }
}
class MetaEdge<E> extends Object {

    String name = "";
    Set<E> edgeSetBundled = new HashSet<E>();
    int numEdgeSetBundled = 0;
    //Intentionally not clone or copy. Just refer to the edgeSet
    public MetaEdge(String s, Set<E> edgeSet) {
        name = s;
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }
    public MetaEdge(String s, E edge) {
        name = s;
        this.addEdge(edge);
    }
    public MetaEdge(String s) {
        name = s;
        
    }

    public void setName(String s) {
        name = s;
    }

    public void setEdgeSetBundled(Set<E> edgeSet) {
        edgeSetBundled = edgeSet;
        numEdgeSetBundled = edgeSetBundled.size();
    }

    public void addEdge(E edge){
        edgeSetBundled.add(edge);
        numEdgeSetBundled += 1;
    }
    public String getName() {
        return name;
    }

    public Set<E> getEdgeSetBundled() {
        return edgeSetBundled;
    }

    public int getNumEdgeSetBundled() {
        return numEdgeSetBundled;
    }

    @Override
    public String toString() {
        return "Num edge: " + numEdgeSetBundled + " " + edgeSetBundled;
    }
}

